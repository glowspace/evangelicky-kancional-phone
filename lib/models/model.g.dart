// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Author.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Author TABLE
class TableAuthor extends SqfEntityTableBase {
  TableAuthor() {
    // declare properties of EntityTable
    tableName = 'authors';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAuthor();
  }
}

// External TABLE
class TableExternal extends SqfEntityTableBase {
  TableExternal() {
    // declare properties of EntityTable
    tableName = 'externals';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('public_name', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('media_id', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('media_type', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isUnique: false,
          isNotNull: false,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExternal();
  }
}

// Playlist TABLE
class TablePlaylist extends SqfEntityTableBase {
  TablePlaylist() {
    // declare properties of EntityTable
    tableName = 'playlists';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('is_archived', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: true,
          isIndex: false),
      SqfEntityFieldBase('rank', DbType.integer,
          isUnique: false, isNotNull: true, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylist();
  }
}

// PlaylistRecord TABLE
class TablePlaylistRecord extends SqfEntityTableBase {
  TablePlaylistRecord() {
    // declare properties of EntityTable
    tableName = 'playlist_records';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('rank', DbType.integer,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TablePlaylist.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'playlistsId',
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isUnique: false,
          isNotNull: false,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylistRecord();
  }
}

// Song TABLE
class TableSong extends SqfEntityTableBase {
  TableSong() {
    // declare properties of EntityTable
    tableName = 'songs';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong();
  }
}

// Songbook TABLE
class TableSongbook extends SqfEntityTableBase {
  TableSongbook() {
    // declare properties of EntityTable
    tableName = 'songbooks';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('shortcut', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('color', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('color_text', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('is_private', DbType.bool,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('is_pinned', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: true,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongbook();
  }
}

// SongbookRecord TABLE
class TableSongbookRecord extends SqfEntityTableBase {
  TableSongbookRecord() {
    // declare properties of EntityTable
    tableName = 'songbook_records';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('number', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableSongbook.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'songbooksId',
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isUnique: false,
          isNotNull: false,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongbookRecord();
  }
}

// SongLyric TABLE
class TableSongLyric extends SqfEntityTableBase {
  TableSongLyric() {
    // declare properties of EntityTable
    tableName = 'song_lyrics';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('secondary_name_1', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('secondary_name_2', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('lyrics', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('lang_string', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('type_enum', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('lilypond_svg', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('favorite_rank', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('transposition', DbType.integer,
          defaultValue: 0, isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('show_chords', DbType.bool,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('accidentals', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldRelationshipBase(TableSong.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'songsId',
          isUnique: false,
          isNotNull: false,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongLyric();
  }
}

// Tag TABLE
class TableTag extends SqfEntityTableBase {
  TableTag() {
    // declare properties of EntityTable
    tableName = 'tags';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('type_enum', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTag();
  }
}

// ExternalsAuthors TABLE
class TableExternalsAuthors extends SqfEntityTableBase {
  TableExternalsAuthors() {
    // declare properties of EntityTable
    tableName = 'externalsAuthors';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableExternal.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'externalsId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(
          TableAuthor.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'authorsId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExternalsAuthors();
  }
}

// Song_lyricsAuthors TABLE
class TableSong_lyricsAuthors extends SqfEntityTableBase {
  TableSong_lyricsAuthors() {
    // declare properties of EntityTable
    tableName = 'song_lyricsAuthors';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(
          TableAuthor.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'authorsId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong_lyricsAuthors();
  }
}

// Song_lyricsTags TABLE
class TableSong_lyricsTags extends SqfEntityTableBase {
  TableSong_lyricsTags() {
    // declare properties of EntityTable
    tableName = 'song_lyricsTags';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(TableTag.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'tagsId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong_lyricsTags();
  }
}
// END TABLES

// BEGIN SEQUENCES
// END SEQUENCES

// BEGIN DATABASE MODEL
class Model extends SqfEntityModelProvider {
  Model() {
    databaseName = model.databaseName;
    password = model.password;
    dbVersion = model.dbVersion;
    preSaveAction = model.preSaveAction;
    logFunction = model.logFunction;
    databaseTables = [
      TableAuthor.getInstance,
      TableExternal.getInstance,
      TablePlaylist.getInstance,
      TablePlaylistRecord.getInstance,
      TableSong.getInstance,
      TableSongbook.getInstance,
      TableSongbookRecord.getInstance,
      TableSongLyric.getInstance,
      TableTag.getInstance,
      TableExternalsAuthors.getInstance,
      TableSong_lyricsAuthors.getInstance,
      TableSong_lyricsTags.getInstance,
    ];

    bundledDatabasePath = model
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Author
class Author extends TableBase {
  Author({this.id, this.name}) {
    _setDefaultValues();
  }
  Author.withFields(this.id, this.name) {
    _setDefaultValues();
  }
  Author.withId(this.id, this.name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Author.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Author)
  int? id;
  String? name;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Author)

// COLLECTIONS & VIRTUALS (Author)
  ///(RelationType.MANY_TO_MANY) (externalsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plExternals', 'plField2'..]) or so on..
  List<External>? plExternals;

  /// get External(s) filtered by externalsId IN externalsAuthors
  ExternalFilterBuilder? getExternals(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return External()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT externalsId FROM externalsAuthors WHERE authorsId=?)',
            parameterValue: id)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (song_lyricsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyrics', 'plField2'..]) or so on..
  List<SongLyric>? plSongLyrics;

  /// get SongLyric(s) filtered by song_lyricsId IN song_lyricsAuthors
  SongLyricFilterBuilder? getSongLyrics(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongLyric()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT song_lyricsId FROM song_lyricsAuthors WHERE authorsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Author)

  static const bool _softDeleteActivated = false;
  AuthorManager? __mnAuthor;

  AuthorManager get _mnAuthor {
    return __mnAuthor = __mnAuthor ?? AuthorManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

// COLLECTIONS (Author)
    if (!forQuery) {
      map['Externals'] = await getExternals()!.toMapList();
    }
    if (!forQuery) {
      map['SongLyrics'] = await getSongLyrics()!.toMapList();
    }
// END COLLECTIONS (Author)

    return map;
  }

  /// This method returns Json String [Author]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Author]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name];
  }

  static Future<List<Author>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Author.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Author>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Author>[];
    try {
      objList = list
          .map((author) => Author.fromMap(author as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Author.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Author>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Author> objList = <Author>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Author.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('authors.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('authors.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('authors.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Author by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Author if exist, otherwise returns null
  Future<Author?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Author? obj;
    final data = await _mnAuthor.getById([id]);
    if (data.length != 0) {
      obj = Author.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('authors.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('authors.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('authors.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Author) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnAuthor.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAuthor.update(this);
    }

    return id;
  }

  /// Saves the (Author) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnAuthor.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAuthor.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Author> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Author> authors) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in authors) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnAuthor.rawInsert(
          'INSERT OR REPLACE INTO authors (id, name)  VALUES (?,?)',
          [id, name]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Author id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Author id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Author Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Author>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Author> authors) async {
    final results = await _mnAuthor.rawInsertAll(
        'INSERT OR REPLACE INTO authors (id, name)  VALUES (?,?)', authors);
    return results;
  }

  /// Deletes Author

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Author invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnAuthor
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnAuthor.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  AuthorFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AuthorFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  AuthorFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AuthorFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion author

// region AuthorField
class AuthorField extends SearchCriteria {
  AuthorField(this.authorFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  AuthorFilterBuilder authorFB;

  AuthorField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  AuthorFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    authorFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorFB.parameters, param, SqlSyntax.EQuals,
            authorFB._addedBlocks)
        : setCriteria(pValue, authorFB.parameters, param, SqlSyntax.NotEQuals,
            authorFB._addedBlocks);
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }

  AuthorFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    authorFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorFB.parameters, param,
            SqlSyntax.EQualsOrNull, authorFB._addedBlocks)
        : setCriteria(pValue, authorFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, authorFB._addedBlocks);
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }

  AuthorFilterBuilder isNull() {
    authorFB._addedBlocks = setCriteria(
        0,
        authorFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        authorFB._addedBlocks);
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }

  AuthorFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      authorFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          authorFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          authorFB._addedBlocks);
      _waitingNot = '';
      authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
          authorFB._addedBlocks.retVal;
    }
    return authorFB;
  }

  AuthorFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      authorFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          authorFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          authorFB._addedBlocks);
      _waitingNot = '';
      authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
          authorFB._addedBlocks.retVal;
      authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
          authorFB._addedBlocks.retVal;
    }
    return authorFB;
  }

  AuthorFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      authorFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          authorFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          authorFB._addedBlocks);
      _waitingNot = '';
      authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
          authorFB._addedBlocks.retVal;
    }
    return authorFB;
  }

  AuthorFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      authorFB._addedBlocks = setCriteria(
          pFirst,
          authorFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          authorFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        authorFB._addedBlocks = setCriteria(pFirst, authorFB.parameters, param,
            SqlSyntax.LessThan, authorFB._addedBlocks);
      } else {
        authorFB._addedBlocks = setCriteria(pFirst, authorFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, authorFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        authorFB._addedBlocks = setCriteria(pLast, authorFB.parameters, param,
            SqlSyntax.GreaterThan, authorFB._addedBlocks);
      } else {
        authorFB._addedBlocks = setCriteria(pLast, authorFB.parameters, param,
            SqlSyntax.LessThanOrEquals, authorFB._addedBlocks);
      }
    }
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }

  AuthorFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    authorFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorFB.parameters, param, SqlSyntax.GreaterThan,
            authorFB._addedBlocks)
        : setCriteria(pValue, authorFB.parameters, param,
            SqlSyntax.LessThanOrEquals, authorFB._addedBlocks);
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }

  AuthorFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    authorFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorFB.parameters, param, SqlSyntax.LessThan,
            authorFB._addedBlocks)
        : setCriteria(pValue, authorFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, authorFB._addedBlocks);
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }

  AuthorFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    authorFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, authorFB._addedBlocks)
        : setCriteria(pValue, authorFB.parameters, param, SqlSyntax.LessThan,
            authorFB._addedBlocks);
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }

  AuthorFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    authorFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorFB.parameters, param,
            SqlSyntax.LessThanOrEquals, authorFB._addedBlocks)
        : setCriteria(pValue, authorFB.parameters, param, SqlSyntax.GreaterThan,
            authorFB._addedBlocks);
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }

  AuthorFilterBuilder inValues(dynamic pValue) {
    authorFB._addedBlocks = setCriteria(
        pValue,
        authorFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        authorFB._addedBlocks);
    _waitingNot = '';
    authorFB._addedBlocks.needEndBlock![authorFB._blockIndex] =
        authorFB._addedBlocks.retVal;
    return authorFB;
  }
}
// endregion AuthorField

// region AuthorFilterBuilder
class AuthorFilterBuilder extends SearchCriteria {
  AuthorFilterBuilder(Author obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Author? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  AuthorFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  AuthorFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  AuthorFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  AuthorFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  AuthorFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  AuthorFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  AuthorFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  AuthorFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  AuthorFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  AuthorFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  AuthorFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  AuthorField setField(AuthorField? field, String colName, DbType dbtype) {
    return AuthorField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  AuthorField? _id;
  AuthorField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  AuthorField? _name;
  AuthorField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Author._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Author> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Author._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnAuthor.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnAuthor.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from authors ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnAuthor.updateBatch(qparams, values);
  }

  /// This method always returns Author Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Author>
  Future<Author?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnAuthor.toList(qparams);
    final data = await objFuture;
    Author? obj;
    if (data.isNotEmpty) {
      obj = Author.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('authors.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('authors.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('authors.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Author]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? authorCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final authorsFuture = await _obj!._mnAuthor.toList(qparams);
    final int count = authorsFuture[0]['CNT'] as int;
    if (authorCount != null) {
      authorCount(count);
    }
    return count;
  }

  /// This method returns List<Author> [Author]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Author>
  Future<List<Author>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Author> authorsData = await Author.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return authorsData;
  }

  /// This method returns Json String [Author]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Author]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Author]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnAuthor.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Author]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM authors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnAuthor.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Author]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnAuthor.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Author.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnAuthor.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AuthorFilterBuilder

// region AuthorFields
class AuthorFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }
}
// endregion AuthorFields

//region AuthorManager
class AuthorManager extends SqfEntityProvider {
  AuthorManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'authors';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion AuthorManager
// region External
class External extends TableBase {
  External(
      {this.id,
      this.public_name,
      this.media_id,
      this.media_type,
      this.song_lyricsId}) {
    _setDefaultValues();
  }
  External.withFields(this.id, this.public_name, this.media_id, this.media_type,
      this.song_lyricsId) {
    _setDefaultValues();
  }
  External.withId(this.id, this.public_name, this.media_id, this.media_type,
      this.song_lyricsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  External.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['public_name'] != null) {
      public_name = o['public_name'].toString();
    }
    if (o['media_id'] != null) {
      media_id = o['media_id'].toString();
    }
    if (o['media_type'] != null) {
      media_type = o['media_type'].toString();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (External)
  int? id;
  String? public_name;
  String? media_id;
  String? media_type;
  int? song_lyricsId;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (External)

// RELATIONSHIPS (External)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (External)

// COLLECTIONS & VIRTUALS (External)
  ///(RelationType.MANY_TO_MANY) (externalsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAuthors', 'plField2'..]) or so on..
  List<Author>? plAuthors;

  /// get Author(s) filtered by authorsId IN externalsAuthors
  AuthorFilterBuilder? getAuthors(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Author()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT authorsId FROM externalsAuthors WHERE externalsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (External)

  static const bool _softDeleteActivated = false;
  ExternalManager? __mnExternal;

  ExternalManager get _mnExternal {
    return __mnExternal = __mnExternal ?? ExternalManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (public_name != null) {
      map['public_name'] = public_name;
    }

    if (media_id != null) {
      map['media_id'] = media_id;
    }

    if (media_type != null) {
      map['media_type'] = media_type;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (public_name != null) {
      map['public_name'] = public_name;
    }

    if (media_id != null) {
      map['media_id'] = media_id;
    }

    if (media_type != null) {
      map['media_type'] = media_type;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

// COLLECTIONS (External)
    if (!forQuery) {
      map['Authors'] = await getAuthors()!.toMapList();
    }
// END COLLECTIONS (External)

    return map;
  }

  /// This method returns Json String [External]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [External]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, public_name, media_id, media_type, song_lyricsId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, public_name, media_id, media_type, song_lyricsId];
  }

  static Future<List<External>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR External.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<External>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <External>[];
    try {
      objList = list
          .map((external) => External.fromMap(external as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR External.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<External>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<External> objList = <External>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = External.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('externals.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns External by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns External if exist, otherwise returns null
  Future<External?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    External? obj;
    final data = await _mnExternal.getById([id]);
    if (data.length != 0) {
      obj = External.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('externals.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (External) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnExternal.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExternal.update(this);
    }

    return id;
  }

  /// Saves the (External) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnExternal.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExternal.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<External> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<External> externals) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in externals) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnExternal.rawInsert(
          'INSERT OR REPLACE INTO externals (id, public_name, media_id, media_type, song_lyricsId)  VALUES (?,?,?,?,?)',
          [id, public_name, media_id, media_type, song_lyricsId]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'External id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'External id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'External Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<External>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<External> externals) async {
    final results = await _mnExternal.rawInsertAll(
        'INSERT OR REPLACE INTO externals (id, public_name, media_id, media_type, song_lyricsId)  VALUES (?,?,?,?,?)',
        externals);
    return results;
  }

  /// Deletes External

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete External invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExternal
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnExternal.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  ExternalFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExternalFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ExternalFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExternalFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion external

// region ExternalField
class ExternalField extends SearchCriteria {
  ExternalField(this.externalFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  ExternalFilterBuilder externalFB;

  ExternalField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ExternalFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    externalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalFB.parameters, param, SqlSyntax.EQuals,
            externalFB._addedBlocks)
        : setCriteria(pValue, externalFB.parameters, param, SqlSyntax.NotEQuals,
            externalFB._addedBlocks);
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }

  ExternalFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    externalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalFB.parameters, param,
            SqlSyntax.EQualsOrNull, externalFB._addedBlocks)
        : setCriteria(pValue, externalFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, externalFB._addedBlocks);
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }

  ExternalFilterBuilder isNull() {
    externalFB._addedBlocks = setCriteria(
        0,
        externalFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        externalFB._addedBlocks);
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }

  ExternalFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      externalFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          externalFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalFB._addedBlocks);
      _waitingNot = '';
      externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
          externalFB._addedBlocks.retVal;
    }
    return externalFB;
  }

  ExternalFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      externalFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          externalFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalFB._addedBlocks);
      _waitingNot = '';
      externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
          externalFB._addedBlocks.retVal;
      externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
          externalFB._addedBlocks.retVal;
    }
    return externalFB;
  }

  ExternalFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      externalFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          externalFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalFB._addedBlocks);
      _waitingNot = '';
      externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
          externalFB._addedBlocks.retVal;
    }
    return externalFB;
  }

  ExternalFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      externalFB._addedBlocks = setCriteria(
          pFirst,
          externalFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        externalFB._addedBlocks = setCriteria(pFirst, externalFB.parameters,
            param, SqlSyntax.LessThan, externalFB._addedBlocks);
      } else {
        externalFB._addedBlocks = setCriteria(pFirst, externalFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, externalFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        externalFB._addedBlocks = setCriteria(pLast, externalFB.parameters,
            param, SqlSyntax.GreaterThan, externalFB._addedBlocks);
      } else {
        externalFB._addedBlocks = setCriteria(pLast, externalFB.parameters,
            param, SqlSyntax.LessThanOrEquals, externalFB._addedBlocks);
      }
    }
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }

  ExternalFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    externalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalFB.parameters, param,
            SqlSyntax.GreaterThan, externalFB._addedBlocks)
        : setCriteria(pValue, externalFB.parameters, param,
            SqlSyntax.LessThanOrEquals, externalFB._addedBlocks);
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }

  ExternalFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    externalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalFB.parameters, param, SqlSyntax.LessThan,
            externalFB._addedBlocks)
        : setCriteria(pValue, externalFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, externalFB._addedBlocks);
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }

  ExternalFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    externalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, externalFB._addedBlocks)
        : setCriteria(pValue, externalFB.parameters, param, SqlSyntax.LessThan,
            externalFB._addedBlocks);
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }

  ExternalFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    externalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalFB.parameters, param,
            SqlSyntax.LessThanOrEquals, externalFB._addedBlocks)
        : setCriteria(pValue, externalFB.parameters, param,
            SqlSyntax.GreaterThan, externalFB._addedBlocks);
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }

  ExternalFilterBuilder inValues(dynamic pValue) {
    externalFB._addedBlocks = setCriteria(
        pValue,
        externalFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        externalFB._addedBlocks);
    _waitingNot = '';
    externalFB._addedBlocks.needEndBlock![externalFB._blockIndex] =
        externalFB._addedBlocks.retVal;
    return externalFB;
  }
}
// endregion ExternalField

// region ExternalFilterBuilder
class ExternalFilterBuilder extends SearchCriteria {
  ExternalFilterBuilder(External obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  External? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  ExternalFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ExternalFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ExternalFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ExternalFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ExternalFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ExternalFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ExternalFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExternalFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExternalFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExternalFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExternalFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ExternalField setField(ExternalField? field, String colName, DbType dbtype) {
    return ExternalField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  ExternalField? _id;
  ExternalField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  ExternalField? _public_name;
  ExternalField get public_name {
    return _public_name = setField(_public_name, 'public_name', DbType.text);
  }

  ExternalField? _media_id;
  ExternalField get media_id {
    return _media_id = setField(_media_id, 'media_id', DbType.text);
  }

  ExternalField? _media_type;
  ExternalField get media_type {
    return _media_type = setField(_media_type, 'media_type', DbType.text);
  }

  ExternalField? _song_lyricsId;
  ExternalField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (External._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<External> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (External._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnExternal.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnExternal.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from externals ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnExternal.updateBatch(qparams, values);
  }

  /// This method always returns External Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<External>
  Future<External?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnExternal.toList(qparams);
    final data = await objFuture;
    External? obj;
    if (data.isNotEmpty) {
      obj = External.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('externals.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [External]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? externalCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final externalsFuture = await _obj!._mnExternal.toList(qparams);
    final int count = externalsFuture[0]['CNT'] as int;
    if (externalCount != null) {
      externalCount(count);
    }
    return count;
  }

  /// This method returns List<External> [External]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<External>
  Future<List<External>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<External> externalsData = await External.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return externalsData;
  }

  /// This method returns Json String [External]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [External]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [External]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnExternal.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [External]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM externals WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnExternal.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [External]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnExternal.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await External.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnExternal.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExternalFilterBuilder

// region ExternalFields
class ExternalFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fPublic_name;
  static TableField get public_name {
    return _fPublic_name = _fPublic_name ??
        SqlSyntax.setField(_fPublic_name, 'public_name', DbType.text);
  }

  static TableField? _fMedia_id;
  static TableField get media_id {
    return _fMedia_id =
        _fMedia_id ?? SqlSyntax.setField(_fMedia_id, 'media_id', DbType.text);
  }

  static TableField? _fMedia_type;
  static TableField get media_type {
    return _fMedia_type = _fMedia_type ??
        SqlSyntax.setField(_fMedia_type, 'media_type', DbType.text);
  }

  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }
}
// endregion ExternalFields

//region ExternalManager
class ExternalManager extends SqfEntityProvider {
  ExternalManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'externals';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ExternalManager
// region Playlist
class Playlist extends TableBase {
  Playlist({this.id, this.name, this.is_archived, this.rank}) {
    _setDefaultValues();
  }
  Playlist.withFields(this.name, this.is_archived, this.rank) {
    _setDefaultValues();
  }
  Playlist.withId(this.id, this.name, this.is_archived, this.rank) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Playlist.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['is_archived'] != null) {
      is_archived = o['is_archived'].toString() == '1' ||
          o['is_archived'].toString() == 'true';
    }
    if (o['rank'] != null) {
      rank = int.tryParse(o['rank'].toString());
    }
  }
  // FIELDS (Playlist)
  int? id;
  String? name;
  bool? is_archived;
  int? rank;

  BoolResult? saveResult;
  // end FIELDS (Playlist)

// COLLECTIONS & VIRTUALS (Playlist)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPlaylistRecords', 'plField2'..]) or so on..
  List<PlaylistRecord>? plPlaylistRecords;

  /// get PlaylistRecord(s) filtered by id=playlistsId
  PlaylistRecordFilterBuilder? getPlaylistRecords(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return PlaylistRecord()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .playlistsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Playlist)

  static const bool _softDeleteActivated = false;
  PlaylistManager? __mnPlaylist;

  PlaylistManager get _mnPlaylist {
    return __mnPlaylist = __mnPlaylist ?? PlaylistManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (is_archived != null) {
      map['is_archived'] = forQuery ? (is_archived! ? 1 : 0) : is_archived;
    }

    if (rank != null) {
      map['rank'] = rank;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (is_archived != null) {
      map['is_archived'] = forQuery ? (is_archived! ? 1 : 0) : is_archived;
    }

    if (rank != null) {
      map['rank'] = rank;
    }

// COLLECTIONS (Playlist)
    if (!forQuery) {
      map['PlaylistRecords'] = await getPlaylistRecords()!.toMapList();
    }
// END COLLECTIONS (Playlist)

    return map;
  }

  /// This method returns Json String [Playlist]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Playlist]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, is_archived, rank];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, is_archived, rank];
  }

  static Future<List<Playlist>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Playlist.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Playlist>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Playlist>[];
    try {
      objList = list
          .map((playlist) => Playlist.fromMap(playlist as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Playlist.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Playlist>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Playlist> objList = <Playlist>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Playlist.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('playlists.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Playlist by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Playlist if exist, otherwise returns null
  Future<Playlist?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Playlist? obj;
    final data = await _mnPlaylist.getById([id]);
    if (data.length != 0) {
      obj = Playlist.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('playlists.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Playlist) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPlaylist.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylist.update(this);
    }

    return id;
  }

  /// Saves the (Playlist) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPlaylist.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylist.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Playlist. Returns a new Primary Key value of Playlist

  /// <returns>Returns a new Primary Key value of Playlist
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Playlist> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Playlist> playlists) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in playlists) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
      for (int i = 0; i < playlists.length; i++) {
        if (playlists[i].id == null) {
          playlists[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnPlaylist.rawInsert(
          'INSERT OR REPLACE INTO playlists (id, name, is_archived, rank)  VALUES (?,?,?,?)',
          [id, name, is_archived, rank]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Playlist id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Playlist id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Playlist Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Playlist>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Playlist> playlists) async {
    final results = await _mnPlaylist.rawInsertAll(
        'INSERT OR REPLACE INTO playlists (id, name, is_archived, rank)  VALUES (?,?,?,?)',
        playlists);
    return results;
  }

  /// Deletes Playlist

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Playlist invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await PlaylistRecord()
          .select()
          .playlistsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylist
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPlaylist.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  PlaylistFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  PlaylistFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    is_archived = is_archived ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion playlist

// region PlaylistField
class PlaylistField extends SearchCriteria {
  PlaylistField(this.playlistFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  PlaylistFilterBuilder playlistFB;

  PlaylistField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  PlaylistFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param, SqlSyntax.EQuals,
            playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param, SqlSyntax.NotEQuals,
            playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.EQualsOrNull, playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder isNull() {
    playlistFB._addedBlocks = setCriteria(
        0,
        playlistFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      playlistFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          playlistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistFB._addedBlocks);
      _waitingNot = '';
      playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
          playlistFB._addedBlocks.retVal;
    }
    return playlistFB;
  }

  PlaylistFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      playlistFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          playlistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistFB._addedBlocks);
      _waitingNot = '';
      playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
          playlistFB._addedBlocks.retVal;
      playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
          playlistFB._addedBlocks.retVal;
    }
    return playlistFB;
  }

  PlaylistFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      playlistFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          playlistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistFB._addedBlocks);
      _waitingNot = '';
      playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
          playlistFB._addedBlocks.retVal;
    }
    return playlistFB;
  }

  PlaylistFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      playlistFB._addedBlocks = setCriteria(
          pFirst,
          playlistFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        playlistFB._addedBlocks = setCriteria(pFirst, playlistFB.parameters,
            param, SqlSyntax.LessThan, playlistFB._addedBlocks);
      } else {
        playlistFB._addedBlocks = setCriteria(pFirst, playlistFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, playlistFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        playlistFB._addedBlocks = setCriteria(pLast, playlistFB.parameters,
            param, SqlSyntax.GreaterThan, playlistFB._addedBlocks);
      } else {
        playlistFB._addedBlocks = setCriteria(pLast, playlistFB.parameters,
            param, SqlSyntax.LessThanOrEquals, playlistFB._addedBlocks);
      }
    }
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.GreaterThan, playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param, SqlSyntax.LessThan,
            playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param, SqlSyntax.LessThan,
            playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.GreaterThan, playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder inValues(dynamic pValue) {
    playlistFB._addedBlocks = setCriteria(
        pValue,
        playlistFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock![playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }
}
// endregion PlaylistField

// region PlaylistFilterBuilder
class PlaylistFilterBuilder extends SearchCriteria {
  PlaylistFilterBuilder(Playlist obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Playlist? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  PlaylistFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  PlaylistFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  PlaylistFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  PlaylistFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  PlaylistFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  PlaylistFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  PlaylistFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  PlaylistField setField(PlaylistField? field, String colName, DbType dbtype) {
    return PlaylistField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  PlaylistField? _id;
  PlaylistField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  PlaylistField? _name;
  PlaylistField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  PlaylistField? _is_archived;
  PlaylistField get is_archived {
    return _is_archived = setField(_is_archived, 'is_archived', DbType.bool);
  }

  PlaylistField? _rank;
  PlaylistField get rank {
    return _rank = setField(_rank, 'rank', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Playlist._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Playlist> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (PlaylistRecord) according to DeleteRule.CASCADE
    final idListPlaylistRecordBYplaylistsId = toListPrimaryKeySQL(false);
    final resPlaylistRecordBYplaylistsId = await PlaylistRecord()
        .select()
        .where('playlistsId IN (${idListPlaylistRecordBYplaylistsId['sql']})',
            parameterValue: idListPlaylistRecordBYplaylistsId['args'])
        .delete(hardDelete);
    if (!resPlaylistRecordBYplaylistsId.success) {
      return resPlaylistRecordBYplaylistsId;
    }

    if (Playlist._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnPlaylist.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnPlaylist.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from playlists ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnPlaylist.updateBatch(qparams, values);
  }

  /// This method always returns Playlist Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Playlist>
  Future<Playlist?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnPlaylist.toList(qparams);
    final data = await objFuture;
    Playlist? obj;
    if (data.isNotEmpty) {
      obj = Playlist.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('playlists.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Playlist]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? playlistCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlistsFuture = await _obj!._mnPlaylist.toList(qparams);
    final int count = playlistsFuture[0]['CNT'] as int;
    if (playlistCount != null) {
      playlistCount(count);
    }
    return count;
  }

  /// This method returns List<Playlist> [Playlist]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Playlist>
  Future<List<Playlist>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Playlist> playlistsData = await Playlist.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return playlistsData;
  }

  /// This method returns Json String [Playlist]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Playlist]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Playlist]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnPlaylist.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Playlist]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM playlists WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnPlaylist.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Playlist]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnPlaylist.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Playlist.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnPlaylist.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistFilterBuilder

// region PlaylistFields
class PlaylistFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fIs_archived;
  static TableField get is_archived {
    return _fIs_archived = _fIs_archived ??
        SqlSyntax.setField(_fIs_archived, 'is_archived', DbType.bool);
  }

  static TableField? _fRank;
  static TableField get rank {
    return _fRank =
        _fRank ?? SqlSyntax.setField(_fRank, 'rank', DbType.integer);
  }
}
// endregion PlaylistFields

//region PlaylistManager
class PlaylistManager extends SqfEntityProvider {
  PlaylistManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'playlists';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PlaylistManager
// region PlaylistRecord
class PlaylistRecord extends TableBase {
  PlaylistRecord({this.id, this.rank, this.playlistsId, this.song_lyricsId}) {
    _setDefaultValues();
  }
  PlaylistRecord.withFields(
      this.id, this.rank, this.playlistsId, this.song_lyricsId) {
    _setDefaultValues();
  }
  PlaylistRecord.withId(
      this.id, this.rank, this.playlistsId, this.song_lyricsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PlaylistRecord.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['rank'] != null) {
      rank = int.tryParse(o['rank'].toString());
    }
    playlistsId = int.tryParse(o['playlistsId'].toString());

    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    // RELATIONSHIPS FromMAP
    plPlaylist = o['playlist'] != null
        ? Playlist.fromMap(o['playlist'] as Map<String, dynamic>)
        : null;
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (PlaylistRecord)
  int? id;
  int? rank;
  int? playlistsId;
  int? song_lyricsId;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (PlaylistRecord)

// RELATIONSHIPS (PlaylistRecord)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPlaylist', 'plField2'..]) or so on..
  Playlist? plPlaylist;

  /// get Playlist By PlaylistsId
  Future<Playlist?> getPlaylist(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Playlist().getById(playlistsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (PlaylistRecord)

  static const bool _softDeleteActivated = false;
  PlaylistRecordManager? __mnPlaylistRecord;

  PlaylistRecordManager get _mnPlaylistRecord {
    return __mnPlaylistRecord = __mnPlaylistRecord ?? PlaylistRecordManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (rank != null) {
      map['rank'] = rank;
    }

    if (playlistsId != null) {
      map['playlistsId'] = forView
          ? plPlaylist == null
              ? playlistsId
              : plPlaylist!.name
          : playlistsId;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (rank != null) {
      map['rank'] = rank;
    }

    if (playlistsId != null) {
      map['playlistsId'] = forView
          ? plPlaylist == null
              ? playlistsId
              : plPlaylist!.name
          : playlistsId;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    return map;
  }

  /// This method returns Json String [PlaylistRecord]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PlaylistRecord]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, rank, playlistsId, song_lyricsId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, rank, playlistsId, song_lyricsId];
  }

  static Future<List<PlaylistRecord>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PlaylistRecord.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PlaylistRecord>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PlaylistRecord>[];
    try {
      objList = list
          .map((playlistrecord) =>
              PlaylistRecord.fromMap(playlistrecord as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PlaylistRecord.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PlaylistRecord>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PlaylistRecord> objList = <PlaylistRecord>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PlaylistRecord.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          /*_loadedfields!.add('playlists.plPlaylist');*/ obj.plPlaylist = obj
                  .plPlaylist ??
              await obj.getPlaylist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PlaylistRecord by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns PlaylistRecord if exist, otherwise returns null
  Future<PlaylistRecord?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    PlaylistRecord? obj;
    final data = await _mnPlaylistRecord.getById([id]);
    if (data.length != 0) {
      obj = PlaylistRecord.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          /*_loadedfields!.add('playlists.plPlaylist');*/ obj.plPlaylist = obj
                  .plPlaylist ??
              await obj.getPlaylist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PlaylistRecord) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnPlaylistRecord.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylistRecord.update(this);
    }

    return id;
  }

  /// Saves the (PlaylistRecord) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnPlaylistRecord.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylistRecord.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<PlaylistRecord> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<PlaylistRecord> playlistrecords) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in playlistrecords) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnPlaylistRecord.rawInsert(
          'INSERT OR REPLACE INTO playlist_records (id, rank, playlistsId, song_lyricsId)  VALUES (?,?,?,?)',
          [id, rank, playlistsId, song_lyricsId]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'PlaylistRecord id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PlaylistRecord id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PlaylistRecord Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<PlaylistRecord>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<PlaylistRecord> playlistrecords) async {
    final results = await _mnPlaylistRecord.rawInsertAll(
        'INSERT OR REPLACE INTO playlist_records (id, rank, playlistsId, song_lyricsId)  VALUES (?,?,?,?)',
        playlistrecords);
    return results;
  }

  /// Deletes PlaylistRecord

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete PlaylistRecord invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylistRecord
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPlaylistRecord.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  PlaylistRecordFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistRecordFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  PlaylistRecordFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistRecordFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion playlistrecord

// region PlaylistRecordField
class PlaylistRecordField extends SearchCriteria {
  PlaylistRecordField(this.playlistrecordFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  PlaylistRecordFilterBuilder playlistrecordFB;

  PlaylistRecordField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  PlaylistRecordFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    playlistrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.EQuals, playlistrecordFB._addedBlocks)
        : setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.NotEQuals, playlistrecordFB._addedBlocks);
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    playlistrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.EQualsOrNull, playlistrecordFB._addedBlocks)
        : setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, playlistrecordFB._addedBlocks);
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder isNull() {
    playlistrecordFB._addedBlocks = setCriteria(
        0,
        playlistrecordFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlistrecordFB._addedBlocks);
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      playlistrecordFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          playlistrecordFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistrecordFB._addedBlocks);
      _waitingNot = '';
      playlistrecordFB
              ._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
          playlistrecordFB._addedBlocks.retVal;
    }
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      playlistrecordFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          playlistrecordFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistrecordFB._addedBlocks);
      _waitingNot = '';
      playlistrecordFB
              ._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
          playlistrecordFB._addedBlocks.retVal;
      playlistrecordFB
              ._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
          playlistrecordFB._addedBlocks.retVal;
    }
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      playlistrecordFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          playlistrecordFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistrecordFB._addedBlocks);
      _waitingNot = '';
      playlistrecordFB
              ._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
          playlistrecordFB._addedBlocks.retVal;
    }
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      playlistrecordFB._addedBlocks = setCriteria(
          pFirst,
          playlistrecordFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistrecordFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        playlistrecordFB._addedBlocks = setCriteria(
            pFirst,
            playlistrecordFB.parameters,
            param,
            SqlSyntax.LessThan,
            playlistrecordFB._addedBlocks);
      } else {
        playlistrecordFB._addedBlocks = setCriteria(
            pFirst,
            playlistrecordFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            playlistrecordFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        playlistrecordFB._addedBlocks = setCriteria(
            pLast,
            playlistrecordFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            playlistrecordFB._addedBlocks);
      } else {
        playlistrecordFB._addedBlocks = setCriteria(
            pLast,
            playlistrecordFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            playlistrecordFB._addedBlocks);
      }
    }
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    playlistrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.GreaterThan, playlistrecordFB._addedBlocks)
        : setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlistrecordFB._addedBlocks);
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    playlistrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.LessThan, playlistrecordFB._addedBlocks)
        : setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlistrecordFB._addedBlocks);
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    playlistrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlistrecordFB._addedBlocks)
        : setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.LessThan, playlistrecordFB._addedBlocks);
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    playlistrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlistrecordFB._addedBlocks)
        : setCriteria(pValue, playlistrecordFB.parameters, param,
            SqlSyntax.GreaterThan, playlistrecordFB._addedBlocks);
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }

  PlaylistRecordFilterBuilder inValues(dynamic pValue) {
    playlistrecordFB._addedBlocks = setCriteria(
        pValue,
        playlistrecordFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlistrecordFB._addedBlocks);
    _waitingNot = '';
    playlistrecordFB._addedBlocks.needEndBlock![playlistrecordFB._blockIndex] =
        playlistrecordFB._addedBlocks.retVal;
    return playlistrecordFB;
  }
}
// endregion PlaylistRecordField

// region PlaylistRecordFilterBuilder
class PlaylistRecordFilterBuilder extends SearchCriteria {
  PlaylistRecordFilterBuilder(PlaylistRecord obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  PlaylistRecord? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  PlaylistRecordFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  PlaylistRecordFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  PlaylistRecordFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  PlaylistRecordFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  PlaylistRecordFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  PlaylistRecordFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  PlaylistRecordFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistRecordFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistRecordFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistRecordFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistRecordFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  PlaylistRecordField setField(
      PlaylistRecordField? field, String colName, DbType dbtype) {
    return PlaylistRecordField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  PlaylistRecordField? _id;
  PlaylistRecordField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  PlaylistRecordField? _rank;
  PlaylistRecordField get rank {
    return _rank = setField(_rank, 'rank', DbType.integer);
  }

  PlaylistRecordField? _playlistsId;
  PlaylistRecordField get playlistsId {
    return _playlistsId = setField(_playlistsId, 'playlistsId', DbType.integer);
  }

  PlaylistRecordField? _song_lyricsId;
  PlaylistRecordField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (PlaylistRecord._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<PlaylistRecord> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (PlaylistRecord._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnPlaylistRecord.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnPlaylistRecord.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from playlist_records ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnPlaylistRecord.updateBatch(qparams, values);
  }

  /// This method always returns PlaylistRecord Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PlaylistRecord>
  Future<PlaylistRecord?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnPlaylistRecord.toList(qparams);
    final data = await objFuture;
    PlaylistRecord? obj;
    if (data.isNotEmpty) {
      obj = PlaylistRecord.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          /*_loadedfields!.add('playlists.plPlaylist');*/ obj.plPlaylist = obj
                  .plPlaylist ??
              await obj.getPlaylist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [PlaylistRecord]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? playlistrecordCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlistrecordsFuture = await _obj!._mnPlaylistRecord.toList(qparams);
    final int count = playlistrecordsFuture[0]['CNT'] as int;
    if (playlistrecordCount != null) {
      playlistrecordCount(count);
    }
    return count;
  }

  /// This method returns List<PlaylistRecord> [PlaylistRecord]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PlaylistRecord>
  Future<List<PlaylistRecord>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PlaylistRecord> playlistrecordsData =
        await PlaylistRecord.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return playlistrecordsData;
  }

  /// This method returns Json String [PlaylistRecord]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PlaylistRecord]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PlaylistRecord]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnPlaylistRecord.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PlaylistRecord]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM playlist_records WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnPlaylistRecord.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PlaylistRecord]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnPlaylistRecord.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await PlaylistRecord.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnPlaylistRecord.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistRecordFilterBuilder

// region PlaylistRecordFields
class PlaylistRecordFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fRank;
  static TableField get rank {
    return _fRank =
        _fRank ?? SqlSyntax.setField(_fRank, 'rank', DbType.integer);
  }

  static TableField? _fPlaylistsId;
  static TableField get playlistsId {
    return _fPlaylistsId = _fPlaylistsId ??
        SqlSyntax.setField(_fPlaylistsId, 'playlistsId', DbType.integer);
  }

  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }
}
// endregion PlaylistRecordFields

//region PlaylistRecordManager
class PlaylistRecordManager extends SqfEntityProvider {
  PlaylistRecordManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'playlist_records';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PlaylistRecordManager
// region Song
class Song extends TableBase {
  Song({this.id, this.name}) {
    _setDefaultValues();
  }
  Song.withFields(this.id, this.name) {
    _setDefaultValues();
  }
  Song.withId(this.id, this.name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Song.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Song)
  int? id;
  String? name;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Song)

// COLLECTIONS & VIRTUALS (Song)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyrics', 'plField2'..]) or so on..
  List<SongLyric>? plSongLyrics;

  /// get SongLyric(s) filtered by id=songsId
  SongLyricFilterBuilder? getSongLyrics(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongLyric()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .songsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Song)

  static const bool _softDeleteActivated = false;
  SongManager? __mnSong;

  SongManager get _mnSong {
    return __mnSong = __mnSong ?? SongManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

// COLLECTIONS (Song)
    if (!forQuery) {
      map['SongLyrics'] = await getSongLyrics()!.toMapList();
    }
// END COLLECTIONS (Song)

    return map;
  }

  /// This method returns Json String [Song]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name];
  }

  static Future<List<Song>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Song>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song>[];
    try {
      objList = list
          .map((song) => Song.fromMap(song as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song> objList = <Song>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('songs.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Song if exist, otherwise returns null
  Future<Song?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Song? obj;
    final data = await _mnSong.getById([id]);
    if (data.length != 0) {
      obj = Song.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('songs.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSong.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSong.update(this);
    }

    return id;
  }

  /// Saves the (Song) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSong.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSong.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Song> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Song> songs) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in songs) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnSong.rawInsert(
          'INSERT OR REPLACE INTO songs (id, name)  VALUES (?,?)', [id, name]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Song id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Song id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Song Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Song>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Song> songs) async {
    final results = await _mnSong.rawInsertAll(
        'INSERT OR REPLACE INTO songs (id, name)  VALUES (?,?)', songs);
    return results;
  }

  /// Deletes Song

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Song invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result =
          await SongLyric().select().songsId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSong.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  SongFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  SongFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion song

// region SongField
class SongField extends SearchCriteria {
  SongField(this.songFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  SongFilterBuilder songFB;

  SongField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  SongFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    songFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songFB.parameters, param, SqlSyntax.EQuals,
            songFB._addedBlocks)
        : setCriteria(pValue, songFB.parameters, param, SqlSyntax.NotEQuals,
            songFB._addedBlocks);
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }

  SongFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    songFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songFB.parameters, param, SqlSyntax.EQualsOrNull,
            songFB._addedBlocks)
        : setCriteria(pValue, songFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, songFB._addedBlocks);
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }

  SongFilterBuilder isNull() {
    songFB._addedBlocks = setCriteria(
        0,
        songFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songFB._addedBlocks);
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }

  SongFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      songFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          songFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songFB._addedBlocks);
      _waitingNot = '';
      songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
          songFB._addedBlocks.retVal;
    }
    return songFB;
  }

  SongFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      songFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          songFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songFB._addedBlocks);
      _waitingNot = '';
      songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
          songFB._addedBlocks.retVal;
      songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
          songFB._addedBlocks.retVal;
    }
    return songFB;
  }

  SongFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      songFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          songFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songFB._addedBlocks);
      _waitingNot = '';
      songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
          songFB._addedBlocks.retVal;
    }
    return songFB;
  }

  SongFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      songFB._addedBlocks = setCriteria(
          pFirst,
          songFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        songFB._addedBlocks = setCriteria(pFirst, songFB.parameters, param,
            SqlSyntax.LessThan, songFB._addedBlocks);
      } else {
        songFB._addedBlocks = setCriteria(pFirst, songFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        songFB._addedBlocks = setCriteria(pLast, songFB.parameters, param,
            SqlSyntax.GreaterThan, songFB._addedBlocks);
      } else {
        songFB._addedBlocks = setCriteria(pLast, songFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songFB._addedBlocks);
      }
    }
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }

  SongFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    songFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songFB.parameters, param, SqlSyntax.GreaterThan,
            songFB._addedBlocks)
        : setCriteria(pValue, songFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songFB._addedBlocks);
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }

  SongFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    songFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songFB.parameters, param, SqlSyntax.LessThan,
            songFB._addedBlocks)
        : setCriteria(pValue, songFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songFB._addedBlocks);
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }

  SongFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    songFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songFB._addedBlocks)
        : setCriteria(pValue, songFB.parameters, param, SqlSyntax.LessThan,
            songFB._addedBlocks);
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }

  SongFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    songFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songFB._addedBlocks)
        : setCriteria(pValue, songFB.parameters, param, SqlSyntax.GreaterThan,
            songFB._addedBlocks);
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }

  SongFilterBuilder inValues(dynamic pValue) {
    songFB._addedBlocks = setCriteria(
        pValue,
        songFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songFB._addedBlocks);
    _waitingNot = '';
    songFB._addedBlocks.needEndBlock![songFB._blockIndex] =
        songFB._addedBlocks.retVal;
    return songFB;
  }
}
// endregion SongField

// region SongFilterBuilder
class SongFilterBuilder extends SearchCriteria {
  SongFilterBuilder(Song obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Song? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  SongFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  SongFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  SongFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  SongFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  SongFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  SongFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  SongFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  SongField setField(SongField? field, String colName, DbType dbtype) {
    return SongField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  SongField? _id;
  SongField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  SongField? _name;
  SongField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Song._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Song> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (SongLyric) according to DeleteRule.CASCADE
    final idListSongLyricBYsongsId = toListPrimaryKeySQL(false);
    final resSongLyricBYsongsId = await SongLyric()
        .select()
        .where('songsId IN (${idListSongLyricBYsongsId['sql']})',
            parameterValue: idListSongLyricBYsongsId['args'])
        .delete(hardDelete);
    if (!resSongLyricBYsongsId.success) {
      return resSongLyricBYsongsId;
    }

    if (Song._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnSong.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnSong.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from songs ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnSong.updateBatch(qparams, values);
  }

  /// This method always returns Song Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song>
  Future<Song?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnSong.toList(qparams);
    final data = await objFuture;
    Song? obj;
    if (data.isNotEmpty) {
      obj = Song.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('songs.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Song]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? songCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songsFuture = await _obj!._mnSong.toList(qparams);
    final int count = songsFuture[0]['CNT'] as int;
    if (songCount != null) {
      songCount(count);
    }
    return count;
  }

  /// This method returns List<Song> [Song]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song>
  Future<List<Song>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Song> songsData = await Song.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return songsData;
  }

  /// This method returns Json String [Song]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnSong.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM songs WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnSong.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnSong.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Song.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnSong.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongFilterBuilder

// region SongFields
class SongFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }
}
// endregion SongFields

//region SongManager
class SongManager extends SqfEntityProvider {
  SongManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'songs';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SongManager
// region Songbook
class Songbook extends TableBase {
  Songbook(
      {this.id,
      this.name,
      this.shortcut,
      this.color,
      this.color_text,
      this.is_private,
      this.is_pinned}) {
    _setDefaultValues();
  }
  Songbook.withFields(this.id, this.name, this.shortcut, this.color,
      this.color_text, this.is_private, this.is_pinned) {
    _setDefaultValues();
  }
  Songbook.withId(this.id, this.name, this.shortcut, this.color,
      this.color_text, this.is_private, this.is_pinned) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Songbook.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['shortcut'] != null) {
      shortcut = o['shortcut'].toString();
    }
    if (o['color'] != null) {
      color = o['color'].toString();
    }
    if (o['color_text'] != null) {
      color_text = o['color_text'].toString();
    }
    if (o['is_private'] != null) {
      is_private = o['is_private'].toString() == '1' ||
          o['is_private'].toString() == 'true';
    }
    if (o['is_pinned'] != null) {
      is_pinned = o['is_pinned'].toString() == '1' ||
          o['is_pinned'].toString() == 'true';
    }

    isSaved = true;
  }
  // FIELDS (Songbook)
  int? id;
  String? name;
  String? shortcut;
  String? color;
  String? color_text;
  bool? is_private;
  bool? is_pinned;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Songbook)

// COLLECTIONS & VIRTUALS (Songbook)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongbookRecords', 'plField2'..]) or so on..
  List<SongbookRecord>? plSongbookRecords;

  /// get SongbookRecord(s) filtered by id=songbooksId
  SongbookRecordFilterBuilder? getSongbookRecords(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongbookRecord()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .songbooksId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Songbook)

  static const bool _softDeleteActivated = false;
  SongbookManager? __mnSongbook;

  SongbookManager get _mnSongbook {
    return __mnSongbook = __mnSongbook ?? SongbookManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (shortcut != null) {
      map['shortcut'] = shortcut;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (color_text != null) {
      map['color_text'] = color_text;
    }

    if (is_private != null) {
      map['is_private'] = forQuery ? (is_private! ? 1 : 0) : is_private;
    }

    if (is_pinned != null) {
      map['is_pinned'] = forQuery ? (is_pinned! ? 1 : 0) : is_pinned;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (shortcut != null) {
      map['shortcut'] = shortcut;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (color_text != null) {
      map['color_text'] = color_text;
    }

    if (is_private != null) {
      map['is_private'] = forQuery ? (is_private! ? 1 : 0) : is_private;
    }

    if (is_pinned != null) {
      map['is_pinned'] = forQuery ? (is_pinned! ? 1 : 0) : is_pinned;
    }

// COLLECTIONS (Songbook)
    if (!forQuery) {
      map['SongbookRecords'] = await getSongbookRecords()!.toMapList();
    }
// END COLLECTIONS (Songbook)

    return map;
  }

  /// This method returns Json String [Songbook]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Songbook]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name, shortcut, color, color_text, is_private, is_pinned];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, shortcut, color, color_text, is_private, is_pinned];
  }

  static Future<List<Songbook>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Songbook.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Songbook>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Songbook>[];
    try {
      objList = list
          .map((songbook) => Songbook.fromMap(songbook as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Songbook.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Songbook>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Songbook> objList = <Songbook>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Songbook.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('songbooks.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Songbook by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Songbook if exist, otherwise returns null
  Future<Songbook?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Songbook? obj;
    final data = await _mnSongbook.getById([id]);
    if (data.length != 0) {
      obj = Songbook.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('songbooks.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Songbook) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongbook.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongbook.update(this);
    }

    return id;
  }

  /// Saves the (Songbook) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongbook.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongbook.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Songbook> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Songbook> songbooks) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in songbooks) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnSongbook.rawInsert(
          'INSERT OR REPLACE INTO songbooks (id, name, shortcut, color, color_text, is_private, is_pinned)  VALUES (?,?,?,?,?,?,?)',
          [id, name, shortcut, color, color_text, is_private, is_pinned]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Songbook id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Songbook id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Songbook Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Songbook>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Songbook> songbooks) async {
    final results = await _mnSongbook.rawInsertAll(
        'INSERT OR REPLACE INTO songbooks (id, name, shortcut, color, color_text, is_private, is_pinned)  VALUES (?,?,?,?,?,?,?)',
        songbooks);
    return results;
  }

  /// Deletes Songbook

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Songbook invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await SongbookRecord()
          .select()
          .songbooksId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongbook
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongbook.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  SongbookFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongbookFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  SongbookFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongbookFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    is_pinned = is_pinned ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion songbook

// region SongbookField
class SongbookField extends SearchCriteria {
  SongbookField(this.songbookFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  SongbookFilterBuilder songbookFB;

  SongbookField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  SongbookFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    songbookFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookFB.parameters, param, SqlSyntax.EQuals,
            songbookFB._addedBlocks)
        : setCriteria(pValue, songbookFB.parameters, param, SqlSyntax.NotEQuals,
            songbookFB._addedBlocks);
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }

  SongbookFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    songbookFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookFB.parameters, param,
            SqlSyntax.EQualsOrNull, songbookFB._addedBlocks)
        : setCriteria(pValue, songbookFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, songbookFB._addedBlocks);
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }

  SongbookFilterBuilder isNull() {
    songbookFB._addedBlocks = setCriteria(
        0,
        songbookFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songbookFB._addedBlocks);
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }

  SongbookFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      songbookFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          songbookFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookFB._addedBlocks);
      _waitingNot = '';
      songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
          songbookFB._addedBlocks.retVal;
    }
    return songbookFB;
  }

  SongbookFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      songbookFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          songbookFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookFB._addedBlocks);
      _waitingNot = '';
      songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
          songbookFB._addedBlocks.retVal;
      songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
          songbookFB._addedBlocks.retVal;
    }
    return songbookFB;
  }

  SongbookFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      songbookFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          songbookFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookFB._addedBlocks);
      _waitingNot = '';
      songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
          songbookFB._addedBlocks.retVal;
    }
    return songbookFB;
  }

  SongbookFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      songbookFB._addedBlocks = setCriteria(
          pFirst,
          songbookFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        songbookFB._addedBlocks = setCriteria(pFirst, songbookFB.parameters,
            param, SqlSyntax.LessThan, songbookFB._addedBlocks);
      } else {
        songbookFB._addedBlocks = setCriteria(pFirst, songbookFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, songbookFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        songbookFB._addedBlocks = setCriteria(pLast, songbookFB.parameters,
            param, SqlSyntax.GreaterThan, songbookFB._addedBlocks);
      } else {
        songbookFB._addedBlocks = setCriteria(pLast, songbookFB.parameters,
            param, SqlSyntax.LessThanOrEquals, songbookFB._addedBlocks);
      }
    }
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }

  SongbookFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    songbookFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookFB.parameters, param,
            SqlSyntax.GreaterThan, songbookFB._addedBlocks)
        : setCriteria(pValue, songbookFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songbookFB._addedBlocks);
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }

  SongbookFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    songbookFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookFB.parameters, param, SqlSyntax.LessThan,
            songbookFB._addedBlocks)
        : setCriteria(pValue, songbookFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songbookFB._addedBlocks);
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }

  SongbookFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    songbookFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songbookFB._addedBlocks)
        : setCriteria(pValue, songbookFB.parameters, param, SqlSyntax.LessThan,
            songbookFB._addedBlocks);
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }

  SongbookFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    songbookFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songbookFB._addedBlocks)
        : setCriteria(pValue, songbookFB.parameters, param,
            SqlSyntax.GreaterThan, songbookFB._addedBlocks);
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }

  SongbookFilterBuilder inValues(dynamic pValue) {
    songbookFB._addedBlocks = setCriteria(
        pValue,
        songbookFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songbookFB._addedBlocks);
    _waitingNot = '';
    songbookFB._addedBlocks.needEndBlock![songbookFB._blockIndex] =
        songbookFB._addedBlocks.retVal;
    return songbookFB;
  }
}
// endregion SongbookField

// region SongbookFilterBuilder
class SongbookFilterBuilder extends SearchCriteria {
  SongbookFilterBuilder(Songbook obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Songbook? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  SongbookFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  SongbookFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  SongbookFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  SongbookFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  SongbookFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  SongbookFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  SongbookFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongbookFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongbookFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongbookFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongbookFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  SongbookField setField(SongbookField? field, String colName, DbType dbtype) {
    return SongbookField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  SongbookField? _id;
  SongbookField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  SongbookField? _name;
  SongbookField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  SongbookField? _shortcut;
  SongbookField get shortcut {
    return _shortcut = setField(_shortcut, 'shortcut', DbType.text);
  }

  SongbookField? _color;
  SongbookField get color {
    return _color = setField(_color, 'color', DbType.text);
  }

  SongbookField? _color_text;
  SongbookField get color_text {
    return _color_text = setField(_color_text, 'color_text', DbType.text);
  }

  SongbookField? _is_private;
  SongbookField get is_private {
    return _is_private = setField(_is_private, 'is_private', DbType.bool);
  }

  SongbookField? _is_pinned;
  SongbookField get is_pinned {
    return _is_pinned = setField(_is_pinned, 'is_pinned', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Songbook._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Songbook> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (SongbookRecord) according to DeleteRule.CASCADE
    final idListSongbookRecordBYsongbooksId = toListPrimaryKeySQL(false);
    final resSongbookRecordBYsongbooksId = await SongbookRecord()
        .select()
        .where('songbooksId IN (${idListSongbookRecordBYsongbooksId['sql']})',
            parameterValue: idListSongbookRecordBYsongbooksId['args'])
        .delete(hardDelete);
    if (!resSongbookRecordBYsongbooksId.success) {
      return resSongbookRecordBYsongbooksId;
    }

    if (Songbook._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnSongbook.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnSongbook.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from songbooks ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnSongbook.updateBatch(qparams, values);
  }

  /// This method always returns Songbook Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Songbook>
  Future<Songbook?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnSongbook.toList(qparams);
    final data = await objFuture;
    Songbook? obj;
    if (data.isNotEmpty) {
      obj = Songbook.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('songbooks.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Songbook]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? songbookCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songbooksFuture = await _obj!._mnSongbook.toList(qparams);
    final int count = songbooksFuture[0]['CNT'] as int;
    if (songbookCount != null) {
      songbookCount(count);
    }
    return count;
  }

  /// This method returns List<Songbook> [Songbook]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Songbook>
  Future<List<Songbook>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Songbook> songbooksData = await Songbook.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return songbooksData;
  }

  /// This method returns Json String [Songbook]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Songbook]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Songbook]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnSongbook.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Songbook]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM songbooks WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnSongbook.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Songbook]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnSongbook.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Songbook.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnSongbook.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongbookFilterBuilder

// region SongbookFields
class SongbookFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fShortcut;
  static TableField get shortcut {
    return _fShortcut =
        _fShortcut ?? SqlSyntax.setField(_fShortcut, 'shortcut', DbType.text);
  }

  static TableField? _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.text);
  }

  static TableField? _fColor_text;
  static TableField get color_text {
    return _fColor_text = _fColor_text ??
        SqlSyntax.setField(_fColor_text, 'color_text', DbType.text);
  }

  static TableField? _fIs_private;
  static TableField get is_private {
    return _fIs_private = _fIs_private ??
        SqlSyntax.setField(_fIs_private, 'is_private', DbType.bool);
  }

  static TableField? _fIs_pinned;
  static TableField get is_pinned {
    return _fIs_pinned = _fIs_pinned ??
        SqlSyntax.setField(_fIs_pinned, 'is_pinned', DbType.bool);
  }
}
// endregion SongbookFields

//region SongbookManager
class SongbookManager extends SqfEntityProvider {
  SongbookManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'songbooks';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SongbookManager
// region SongbookRecord
class SongbookRecord extends TableBase {
  SongbookRecord({this.id, this.number, this.songbooksId, this.song_lyricsId}) {
    _setDefaultValues();
  }
  SongbookRecord.withFields(
      this.id, this.number, this.songbooksId, this.song_lyricsId) {
    _setDefaultValues();
  }
  SongbookRecord.withId(
      this.id, this.number, this.songbooksId, this.song_lyricsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SongbookRecord.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['number'] != null) {
      number = o['number'].toString();
    }
    songbooksId = int.tryParse(o['songbooksId'].toString());

    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongbook = o['songbook'] != null
        ? Songbook.fromMap(o['songbook'] as Map<String, dynamic>)
        : null;
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (SongbookRecord)
  int? id;
  String? number;
  int? songbooksId;
  int? song_lyricsId;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (SongbookRecord)

// RELATIONSHIPS (SongbookRecord)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongbook', 'plField2'..]) or so on..
  Songbook? plSongbook;

  /// get Songbook By SongbooksId
  Future<Songbook?> getSongbook(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Songbook().getById(songbooksId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (SongbookRecord)

  static const bool _softDeleteActivated = false;
  SongbookRecordManager? __mnSongbookRecord;

  SongbookRecordManager get _mnSongbookRecord {
    return __mnSongbookRecord = __mnSongbookRecord ?? SongbookRecordManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (number != null) {
      map['number'] = number;
    }

    if (songbooksId != null) {
      map['songbooksId'] = forView
          ? plSongbook == null
              ? songbooksId
              : plSongbook!.name
          : songbooksId;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (number != null) {
      map['number'] = number;
    }

    if (songbooksId != null) {
      map['songbooksId'] = forView
          ? plSongbook == null
              ? songbooksId
              : plSongbook!.name
          : songbooksId;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    return map;
  }

  /// This method returns Json String [SongbookRecord]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SongbookRecord]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, number, songbooksId, song_lyricsId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, number, songbooksId, song_lyricsId];
  }

  static Future<List<SongbookRecord>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SongbookRecord.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SongbookRecord>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SongbookRecord>[];
    try {
      objList = list
          .map((songbookrecord) =>
              SongbookRecord.fromMap(songbookrecord as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SongbookRecord.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SongbookRecord>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SongbookRecord> objList = <SongbookRecord>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SongbookRecord.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbook') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongbook'))) {
          /*_loadedfields!.add('songbooks.plSongbook');*/ obj.plSongbook = obj
                  .plSongbook ??
              await obj.getSongbook(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SongbookRecord by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns SongbookRecord if exist, otherwise returns null
  Future<SongbookRecord?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SongbookRecord? obj;
    final data = await _mnSongbookRecord.getById([id]);
    if (data.length != 0) {
      obj = SongbookRecord.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbook') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongbook'))) {
          /*_loadedfields!.add('songbooks.plSongbook');*/ obj.plSongbook = obj
                  .plSongbook ??
              await obj.getSongbook(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SongbookRecord) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongbookRecord.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongbookRecord.update(this);
    }

    return id;
  }

  /// Saves the (SongbookRecord) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongbookRecord.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongbookRecord.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<SongbookRecord> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SongbookRecord> songbookrecords) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in songbookrecords) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnSongbookRecord.rawInsert(
          'INSERT OR REPLACE INTO songbook_records (id, number, songbooksId, song_lyricsId)  VALUES (?,?,?,?)',
          [id, number, songbooksId, song_lyricsId]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SongbookRecord id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SongbookRecord id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SongbookRecord Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SongbookRecord>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<SongbookRecord> songbookrecords) async {
    final results = await _mnSongbookRecord.rawInsertAll(
        'INSERT OR REPLACE INTO songbook_records (id, number, songbooksId, song_lyricsId)  VALUES (?,?,?,?)',
        songbookrecords);
    return results;
  }

  /// Deletes SongbookRecord

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SongbookRecord invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongbookRecord
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongbookRecord.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  SongbookRecordFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongbookRecordFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  SongbookRecordFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongbookRecordFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion songbookrecord

// region SongbookRecordField
class SongbookRecordField extends SearchCriteria {
  SongbookRecordField(this.songbookrecordFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  SongbookRecordFilterBuilder songbookrecordFB;

  SongbookRecordField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  SongbookRecordFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    songbookrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.EQuals, songbookrecordFB._addedBlocks)
        : setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.NotEQuals, songbookrecordFB._addedBlocks);
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    songbookrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.EQualsOrNull, songbookrecordFB._addedBlocks)
        : setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, songbookrecordFB._addedBlocks);
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder isNull() {
    songbookrecordFB._addedBlocks = setCriteria(
        0,
        songbookrecordFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songbookrecordFB._addedBlocks);
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      songbookrecordFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          songbookrecordFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookrecordFB._addedBlocks);
      _waitingNot = '';
      songbookrecordFB
              ._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
          songbookrecordFB._addedBlocks.retVal;
    }
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      songbookrecordFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          songbookrecordFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookrecordFB._addedBlocks);
      _waitingNot = '';
      songbookrecordFB
              ._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
          songbookrecordFB._addedBlocks.retVal;
      songbookrecordFB
              ._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
          songbookrecordFB._addedBlocks.retVal;
    }
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      songbookrecordFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          songbookrecordFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookrecordFB._addedBlocks);
      _waitingNot = '';
      songbookrecordFB
              ._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
          songbookrecordFB._addedBlocks.retVal;
    }
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      songbookrecordFB._addedBlocks = setCriteria(
          pFirst,
          songbookrecordFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookrecordFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        songbookrecordFB._addedBlocks = setCriteria(
            pFirst,
            songbookrecordFB.parameters,
            param,
            SqlSyntax.LessThan,
            songbookrecordFB._addedBlocks);
      } else {
        songbookrecordFB._addedBlocks = setCriteria(
            pFirst,
            songbookrecordFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            songbookrecordFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        songbookrecordFB._addedBlocks = setCriteria(
            pLast,
            songbookrecordFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            songbookrecordFB._addedBlocks);
      } else {
        songbookrecordFB._addedBlocks = setCriteria(
            pLast,
            songbookrecordFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            songbookrecordFB._addedBlocks);
      }
    }
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    songbookrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.GreaterThan, songbookrecordFB._addedBlocks)
        : setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songbookrecordFB._addedBlocks);
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    songbookrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.LessThan, songbookrecordFB._addedBlocks)
        : setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songbookrecordFB._addedBlocks);
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    songbookrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songbookrecordFB._addedBlocks)
        : setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.LessThan, songbookrecordFB._addedBlocks);
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    songbookrecordFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songbookrecordFB._addedBlocks)
        : setCriteria(pValue, songbookrecordFB.parameters, param,
            SqlSyntax.GreaterThan, songbookrecordFB._addedBlocks);
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }

  SongbookRecordFilterBuilder inValues(dynamic pValue) {
    songbookrecordFB._addedBlocks = setCriteria(
        pValue,
        songbookrecordFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songbookrecordFB._addedBlocks);
    _waitingNot = '';
    songbookrecordFB._addedBlocks.needEndBlock![songbookrecordFB._blockIndex] =
        songbookrecordFB._addedBlocks.retVal;
    return songbookrecordFB;
  }
}
// endregion SongbookRecordField

// region SongbookRecordFilterBuilder
class SongbookRecordFilterBuilder extends SearchCriteria {
  SongbookRecordFilterBuilder(SongbookRecord obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  SongbookRecord? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  SongbookRecordFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  SongbookRecordFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  SongbookRecordFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  SongbookRecordFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  SongbookRecordFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  SongbookRecordFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  SongbookRecordFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongbookRecordFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongbookRecordFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongbookRecordFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongbookRecordFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  SongbookRecordField setField(
      SongbookRecordField? field, String colName, DbType dbtype) {
    return SongbookRecordField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  SongbookRecordField? _id;
  SongbookRecordField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  SongbookRecordField? _number;
  SongbookRecordField get number {
    return _number = setField(_number, 'number', DbType.text);
  }

  SongbookRecordField? _songbooksId;
  SongbookRecordField get songbooksId {
    return _songbooksId = setField(_songbooksId, 'songbooksId', DbType.integer);
  }

  SongbookRecordField? _song_lyricsId;
  SongbookRecordField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (SongbookRecord._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<SongbookRecord> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (SongbookRecord._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnSongbookRecord.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnSongbookRecord.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from songbook_records ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnSongbookRecord.updateBatch(qparams, values);
  }

  /// This method always returns SongbookRecord Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongbookRecord>
  Future<SongbookRecord?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnSongbookRecord.toList(qparams);
    final data = await objFuture;
    SongbookRecord? obj;
    if (data.isNotEmpty) {
      obj = SongbookRecord.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbook') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongbook'))) {
          /*_loadedfields!.add('songbooks.plSongbook');*/ obj.plSongbook = obj
                  .plSongbook ??
              await obj.getSongbook(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [SongbookRecord]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? songbookrecordCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songbookrecordsFuture = await _obj!._mnSongbookRecord.toList(qparams);
    final int count = songbookrecordsFuture[0]['CNT'] as int;
    if (songbookrecordCount != null) {
      songbookrecordCount(count);
    }
    return count;
  }

  /// This method returns List<SongbookRecord> [SongbookRecord]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongbookRecord>
  Future<List<SongbookRecord>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SongbookRecord> songbookrecordsData =
        await SongbookRecord.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return songbookrecordsData;
  }

  /// This method returns Json String [SongbookRecord]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SongbookRecord]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SongbookRecord]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnSongbookRecord.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SongbookRecord]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM songbook_records WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnSongbookRecord.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SongbookRecord]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnSongbookRecord.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await SongbookRecord.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnSongbookRecord.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongbookRecordFilterBuilder

// region SongbookRecordFields
class SongbookRecordFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fNumber;
  static TableField get number {
    return _fNumber =
        _fNumber ?? SqlSyntax.setField(_fNumber, 'number', DbType.text);
  }

  static TableField? _fSongbooksId;
  static TableField get songbooksId {
    return _fSongbooksId = _fSongbooksId ??
        SqlSyntax.setField(_fSongbooksId, 'songbooksId', DbType.integer);
  }

  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }
}
// endregion SongbookRecordFields

//region SongbookRecordManager
class SongbookRecordManager extends SqfEntityProvider {
  SongbookRecordManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'songbook_records';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SongbookRecordManager
// region SongLyric
class SongLyric extends TableBase {
  SongLyric(
      {this.id,
      this.name,
      this.secondary_name_1,
      this.secondary_name_2,
      this.lyrics,
      this.lang_string,
      this.type_enum,
      this.lilypond_svg,
      this.favorite_rank,
      this.transposition,
      this.show_chords,
      this.accidentals,
      this.songsId}) {
    _setDefaultValues();
  }
  SongLyric.withFields(
      this.id,
      this.name,
      this.secondary_name_1,
      this.secondary_name_2,
      this.lyrics,
      this.lang_string,
      this.type_enum,
      this.lilypond_svg,
      this.favorite_rank,
      this.transposition,
      this.show_chords,
      this.accidentals,
      this.songsId) {
    _setDefaultValues();
  }
  SongLyric.withId(
      this.id,
      this.name,
      this.secondary_name_1,
      this.secondary_name_2,
      this.lyrics,
      this.lang_string,
      this.type_enum,
      this.lilypond_svg,
      this.favorite_rank,
      this.transposition,
      this.show_chords,
      this.accidentals,
      this.songsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SongLyric.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['secondary_name_1'] != null) {
      secondary_name_1 = o['secondary_name_1'].toString();
    }
    if (o['secondary_name_2'] != null) {
      secondary_name_2 = o['secondary_name_2'].toString();
    }
    if (o['lyrics'] != null) {
      lyrics = o['lyrics'].toString();
    }
    if (o['lang_string'] != null) {
      lang_string = o['lang_string'].toString();
    }
    if (o['type_enum'] != null) {
      type_enum = o['type_enum'].toString();
    }
    if (o['lilypond_svg'] != null) {
      lilypond_svg = o['lilypond_svg'].toString();
    }
    if (o['favorite_rank'] != null) {
      favorite_rank = int.tryParse(o['favorite_rank'].toString());
    }
    if (o['transposition'] != null) {
      transposition = int.tryParse(o['transposition'].toString());
    }
    if (o['show_chords'] != null) {
      show_chords = o['show_chords'].toString() == '1' ||
          o['show_chords'].toString() == 'true';
    }
    if (o['accidentals'] != null) {
      accidentals = int.tryParse(o['accidentals'].toString());
    }
    songsId = int.tryParse(o['songsId'].toString());

    // RELATIONSHIPS FromMAP
    plSong = o['song'] != null
        ? Song.fromMap(o['song'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (SongLyric)
  int? id;
  String? name;
  String? secondary_name_1;
  String? secondary_name_2;
  String? lyrics;
  String? lang_string;
  String? type_enum;
  String? lilypond_svg;
  int? favorite_rank;
  int? transposition;
  bool? show_chords;
  int? accidentals;
  int? songsId;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (SongLyric)

// RELATIONSHIPS (SongLyric)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSong', 'plField2'..]) or so on..
  Song? plSong;

  /// get Song By SongsId
  Future<Song?> getSong(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Song()
        .getById(songsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (SongLyric)

// COLLECTIONS & VIRTUALS (SongLyric)
  ///(RelationType.MANY_TO_MANY) (song_lyricsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAuthors', 'plField2'..]) or so on..
  List<Author>? plAuthors;

  /// get Author(s) filtered by authorsId IN song_lyricsAuthors
  AuthorFilterBuilder? getAuthors(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Author()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT authorsId FROM song_lyricsAuthors WHERE song_lyricsId=?)',
            parameterValue: id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plExternals', 'plField2'..]) or so on..
  List<External>? plExternals;

  /// get External(s) filtered by id=song_lyricsId
  ExternalFilterBuilder? getExternals(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return External()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .song_lyricsId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPlaylistRecords', 'plField2'..]) or so on..
  List<PlaylistRecord>? plPlaylistRecords;

  /// get PlaylistRecord(s) filtered by id=song_lyricsId
  PlaylistRecordFilterBuilder? getPlaylistRecords(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return PlaylistRecord()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .song_lyricsId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongbookRecords', 'plField2'..]) or so on..
  List<SongbookRecord>? plSongbookRecords;

  /// get SongbookRecord(s) filtered by id=song_lyricsId
  SongbookRecordFilterBuilder? getSongbookRecords(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongbookRecord()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .song_lyricsId
        .equals(id)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (song_lyricsTags) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTags', 'plField2'..]) or so on..
  List<Tag>? plTags;

  /// get Tag(s) filtered by tagsId IN song_lyricsTags
  TagFilterBuilder? getTags(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Tag()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT tagsId FROM song_lyricsTags WHERE song_lyricsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (SongLyric)

  static const bool _softDeleteActivated = false;
  SongLyricManager? __mnSongLyric;

  SongLyricManager get _mnSongLyric {
    return __mnSongLyric = __mnSongLyric ?? SongLyricManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (secondary_name_1 != null) {
      map['secondary_name_1'] = secondary_name_1;
    }

    if (secondary_name_2 != null) {
      map['secondary_name_2'] = secondary_name_2;
    }

    if (lyrics != null) {
      map['lyrics'] = lyrics;
    }

    if (lang_string != null) {
      map['lang_string'] = lang_string;
    }

    if (type_enum != null) {
      map['type_enum'] = type_enum;
    }

    if (lilypond_svg != null) {
      map['lilypond_svg'] = lilypond_svg;
    }

    if (favorite_rank != null) {
      map['favorite_rank'] = favorite_rank;
    }

    if (transposition != null) {
      map['transposition'] = transposition;
    }

    if (show_chords != null) {
      map['show_chords'] = forQuery ? (show_chords! ? 1 : 0) : show_chords;
    }

    if (accidentals != null) {
      map['accidentals'] = accidentals;
    }

    if (songsId != null) {
      map['songsId'] = forView
          ? plSong == null
              ? songsId
              : plSong!.name
          : songsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (secondary_name_1 != null) {
      map['secondary_name_1'] = secondary_name_1;
    }

    if (secondary_name_2 != null) {
      map['secondary_name_2'] = secondary_name_2;
    }

    if (lyrics != null) {
      map['lyrics'] = lyrics;
    }

    if (lang_string != null) {
      map['lang_string'] = lang_string;
    }

    if (type_enum != null) {
      map['type_enum'] = type_enum;
    }

    if (lilypond_svg != null) {
      map['lilypond_svg'] = lilypond_svg;
    }

    if (favorite_rank != null) {
      map['favorite_rank'] = favorite_rank;
    }

    if (transposition != null) {
      map['transposition'] = transposition;
    }

    if (show_chords != null) {
      map['show_chords'] = forQuery ? (show_chords! ? 1 : 0) : show_chords;
    }

    if (accidentals != null) {
      map['accidentals'] = accidentals;
    }

    if (songsId != null) {
      map['songsId'] = forView
          ? plSong == null
              ? songsId
              : plSong!.name
          : songsId;
    }

// COLLECTIONS (SongLyric)
    if (!forQuery) {
      map['Authors'] = await getAuthors()!.toMapList();
    }
    if (!forQuery) {
      map['Externals'] = await getExternals()!.toMapList();
    }
    if (!forQuery) {
      map['PlaylistRecords'] = await getPlaylistRecords()!.toMapList();
    }
    if (!forQuery) {
      map['SongbookRecords'] = await getSongbookRecords()!.toMapList();
    }
    if (!forQuery) {
      map['Tags'] = await getTags()!.toMapList();
    }
// END COLLECTIONS (SongLyric)

    return map;
  }

  /// This method returns Json String [SongLyric]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SongLyric]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      name,
      secondary_name_1,
      secondary_name_2,
      lyrics,
      lang_string,
      type_enum,
      lilypond_svg,
      favorite_rank,
      transposition,
      show_chords,
      accidentals,
      songsId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      secondary_name_1,
      secondary_name_2,
      lyrics,
      lang_string,
      type_enum,
      lilypond_svg,
      favorite_rank,
      transposition,
      show_chords,
      accidentals,
      songsId
    ];
  }

  static Future<List<SongLyric>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SongLyric.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SongLyric>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SongLyric>[];
    try {
      objList = list
          .map((songlyric) =>
              SongLyric.fromMap(songlyric as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SongLyric.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SongLyric>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SongLyric> objList = <SongLyric>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SongLyric.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('song_lyrics.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('song_lyrics.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('song_lyrics.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('song_lyrics.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTags'))) {
          /*_loadedfields!.add('song_lyrics.plTags'); */ obj.plTags =
              obj.plTags ??
                  await obj.getTags()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSong') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSong'))) {
          /*_loadedfields!.add('songs.plSong');*/ obj.plSong = obj.plSong ??
              await obj.getSong(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SongLyric by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns SongLyric if exist, otherwise returns null
  Future<SongLyric?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SongLyric? obj;
    final data = await _mnSongLyric.getById([id]);
    if (data.length != 0) {
      obj = SongLyric.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('song_lyrics.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('song_lyrics.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('song_lyrics.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('song_lyrics.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTags'))) {
          /*_loadedfields!.add('song_lyrics.plTags'); */ obj.plTags =
              obj.plTags ??
                  await obj.getTags()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSong') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSong'))) {
          /*_loadedfields!.add('songs.plSong');*/ obj.plSong = obj.plSong ??
              await obj.getSong(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SongLyric) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongLyric.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongLyric.update(this);
    }

    return id;
  }

  /// Saves the (SongLyric) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongLyric.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongLyric.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<SongLyric> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<SongLyric> songlyrics) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in songlyrics) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnSongLyric.rawInsert(
          'INSERT OR REPLACE INTO song_lyrics (id, name, secondary_name_1, secondary_name_2, lyrics, lang_string, type_enum, lilypond_svg, favorite_rank, transposition, show_chords, accidentals, songsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            name,
            secondary_name_1,
            secondary_name_2,
            lyrics,
            lang_string,
            type_enum,
            lilypond_svg,
            favorite_rank,
            transposition,
            show_chords,
            accidentals,
            songsId
          ]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SongLyric id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'SongLyric id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SongLyric Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SongLyric>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<SongLyric> songlyrics) async {
    final results = await _mnSongLyric.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyrics (id, name, secondary_name_1, secondary_name_2, lyrics, lang_string, type_enum, lilypond_svg, favorite_rank, transposition, show_chords, accidentals, songsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
        songlyrics);
    return results;
  }

  /// Deletes SongLyric

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SongLyric invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await External()
          .select()
          .song_lyricsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await PlaylistRecord()
          .select()
          .song_lyricsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await SongbookRecord()
          .select()
          .song_lyricsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongLyric
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongLyric.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  SongLyricFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongLyricFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  SongLyricFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongLyricFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    transposition = transposition ?? 0;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion songlyric

// region SongLyricField
class SongLyricField extends SearchCriteria {
  SongLyricField(this.songlyricFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  SongLyricFilterBuilder songlyricFB;

  SongLyricField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  SongLyricFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    songlyricFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricFB.parameters, param, SqlSyntax.EQuals,
            songlyricFB._addedBlocks)
        : setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.NotEQuals, songlyricFB._addedBlocks);
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }

  SongLyricFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    songlyricFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.EQualsOrNull, songlyricFB._addedBlocks)
        : setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, songlyricFB._addedBlocks);
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }

  SongLyricFilterBuilder isNull() {
    songlyricFB._addedBlocks = setCriteria(
        0,
        songlyricFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songlyricFB._addedBlocks);
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }

  SongLyricFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      songlyricFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          songlyricFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songlyricFB._addedBlocks);
      _waitingNot = '';
      songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
          songlyricFB._addedBlocks.retVal;
    }
    return songlyricFB;
  }

  SongLyricFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      songlyricFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          songlyricFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songlyricFB._addedBlocks);
      _waitingNot = '';
      songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
          songlyricFB._addedBlocks.retVal;
      songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
          songlyricFB._addedBlocks.retVal;
    }
    return songlyricFB;
  }

  SongLyricFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      songlyricFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          songlyricFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songlyricFB._addedBlocks);
      _waitingNot = '';
      songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
          songlyricFB._addedBlocks.retVal;
    }
    return songlyricFB;
  }

  SongLyricFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      songlyricFB._addedBlocks = setCriteria(
          pFirst,
          songlyricFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songlyricFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        songlyricFB._addedBlocks = setCriteria(pFirst, songlyricFB.parameters,
            param, SqlSyntax.LessThan, songlyricFB._addedBlocks);
      } else {
        songlyricFB._addedBlocks = setCriteria(pFirst, songlyricFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, songlyricFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        songlyricFB._addedBlocks = setCriteria(pLast, songlyricFB.parameters,
            param, SqlSyntax.GreaterThan, songlyricFB._addedBlocks);
      } else {
        songlyricFB._addedBlocks = setCriteria(pLast, songlyricFB.parameters,
            param, SqlSyntax.LessThanOrEquals, songlyricFB._addedBlocks);
      }
    }
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }

  SongLyricFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    songlyricFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.GreaterThan, songlyricFB._addedBlocks)
        : setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songlyricFB._addedBlocks);
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }

  SongLyricFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    songlyricFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricFB.parameters, param, SqlSyntax.LessThan,
            songlyricFB._addedBlocks)
        : setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songlyricFB._addedBlocks);
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }

  SongLyricFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    songlyricFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songlyricFB._addedBlocks)
        : setCriteria(pValue, songlyricFB.parameters, param, SqlSyntax.LessThan,
            songlyricFB._addedBlocks);
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }

  SongLyricFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    songlyricFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songlyricFB._addedBlocks)
        : setCriteria(pValue, songlyricFB.parameters, param,
            SqlSyntax.GreaterThan, songlyricFB._addedBlocks);
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }

  SongLyricFilterBuilder inValues(dynamic pValue) {
    songlyricFB._addedBlocks = setCriteria(
        pValue,
        songlyricFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songlyricFB._addedBlocks);
    _waitingNot = '';
    songlyricFB._addedBlocks.needEndBlock![songlyricFB._blockIndex] =
        songlyricFB._addedBlocks.retVal;
    return songlyricFB;
  }
}
// endregion SongLyricField

// region SongLyricFilterBuilder
class SongLyricFilterBuilder extends SearchCriteria {
  SongLyricFilterBuilder(SongLyric obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  SongLyric? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  SongLyricFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  SongLyricFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  SongLyricFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  SongLyricFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  SongLyricFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  SongLyricFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  SongLyricFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongLyricFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongLyricFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongLyricFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongLyricFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  SongLyricField setField(
      SongLyricField? field, String colName, DbType dbtype) {
    return SongLyricField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  SongLyricField? _id;
  SongLyricField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  SongLyricField? _name;
  SongLyricField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  SongLyricField? _secondary_name_1;
  SongLyricField get secondary_name_1 {
    return _secondary_name_1 =
        setField(_secondary_name_1, 'secondary_name_1', DbType.text);
  }

  SongLyricField? _secondary_name_2;
  SongLyricField get secondary_name_2 {
    return _secondary_name_2 =
        setField(_secondary_name_2, 'secondary_name_2', DbType.text);
  }

  SongLyricField? _lyrics;
  SongLyricField get lyrics {
    return _lyrics = setField(_lyrics, 'lyrics', DbType.text);
  }

  SongLyricField? _lang_string;
  SongLyricField get lang_string {
    return _lang_string = setField(_lang_string, 'lang_string', DbType.text);
  }

  SongLyricField? _type_enum;
  SongLyricField get type_enum {
    return _type_enum = setField(_type_enum, 'type_enum', DbType.text);
  }

  SongLyricField? _lilypond_svg;
  SongLyricField get lilypond_svg {
    return _lilypond_svg = setField(_lilypond_svg, 'lilypond_svg', DbType.text);
  }

  SongLyricField? _favorite_rank;
  SongLyricField get favorite_rank {
    return _favorite_rank =
        setField(_favorite_rank, 'favorite_rank', DbType.integer);
  }

  SongLyricField? _transposition;
  SongLyricField get transposition {
    return _transposition =
        setField(_transposition, 'transposition', DbType.integer);
  }

  SongLyricField? _show_chords;
  SongLyricField get show_chords {
    return _show_chords = setField(_show_chords, 'show_chords', DbType.bool);
  }

  SongLyricField? _accidentals;
  SongLyricField get accidentals {
    return _accidentals = setField(_accidentals, 'accidentals', DbType.integer);
  }

  SongLyricField? _songsId;
  SongLyricField get songsId {
    return _songsId = setField(_songsId, 'songsId', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (SongLyric._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<SongLyric> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (External) according to DeleteRule.CASCADE
    final idListExternalBYsong_lyricsId = toListPrimaryKeySQL(false);
    final resExternalBYsong_lyricsId = await External()
        .select()
        .where('song_lyricsId IN (${idListExternalBYsong_lyricsId['sql']})',
            parameterValue: idListExternalBYsong_lyricsId['args'])
        .delete(hardDelete);
    if (!resExternalBYsong_lyricsId.success) {
      return resExternalBYsong_lyricsId;
    }
// Delete sub records where in (PlaylistRecord) according to DeleteRule.CASCADE
    final idListPlaylistRecordBYsong_lyricsId = toListPrimaryKeySQL(false);
    final resPlaylistRecordBYsong_lyricsId = await PlaylistRecord()
        .select()
        .where(
            'song_lyricsId IN (${idListPlaylistRecordBYsong_lyricsId['sql']})',
            parameterValue: idListPlaylistRecordBYsong_lyricsId['args'])
        .delete(hardDelete);
    if (!resPlaylistRecordBYsong_lyricsId.success) {
      return resPlaylistRecordBYsong_lyricsId;
    }
// Delete sub records where in (SongbookRecord) according to DeleteRule.CASCADE
    final idListSongbookRecordBYsong_lyricsId = toListPrimaryKeySQL(false);
    final resSongbookRecordBYsong_lyricsId = await SongbookRecord()
        .select()
        .where(
            'song_lyricsId IN (${idListSongbookRecordBYsong_lyricsId['sql']})',
            parameterValue: idListSongbookRecordBYsong_lyricsId['args'])
        .delete(hardDelete);
    if (!resSongbookRecordBYsong_lyricsId.success) {
      return resSongbookRecordBYsong_lyricsId;
    }

    if (SongLyric._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnSongLyric.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnSongLyric.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from song_lyrics ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnSongLyric.updateBatch(qparams, values);
  }

  /// This method always returns SongLyric Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongLyric>
  Future<SongLyric?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnSongLyric.toList(qparams);
    final data = await objFuture;
    SongLyric? obj;
    if (data.isNotEmpty) {
      obj = SongLyric.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('song_lyrics.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('song_lyrics.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('song_lyrics.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('song_lyrics.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTags'))) {
          /*_loadedfields!.add('song_lyrics.plTags'); */ obj.plTags =
              obj.plTags ??
                  await obj.getTags()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSong') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSong'))) {
          /*_loadedfields!.add('songs.plSong');*/ obj.plSong = obj.plSong ??
              await obj.getSong(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [SongLyric]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? songlyricCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songlyricsFuture = await _obj!._mnSongLyric.toList(qparams);
    final int count = songlyricsFuture[0]['CNT'] as int;
    if (songlyricCount != null) {
      songlyricCount(count);
    }
    return count;
  }

  /// This method returns List<SongLyric> [SongLyric]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongLyric>
  Future<List<SongLyric>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SongLyric> songlyricsData = await SongLyric.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return songlyricsData;
  }

  /// This method returns Json String [SongLyric]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SongLyric]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SongLyric]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnSongLyric.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SongLyric]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM song_lyrics WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnSongLyric.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SongLyric]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnSongLyric.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await SongLyric.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnSongLyric.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongLyricFilterBuilder

// region SongLyricFields
class SongLyricFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fSecondary_name_1;
  static TableField get secondary_name_1 {
    return _fSecondary_name_1 = _fSecondary_name_1 ??
        SqlSyntax.setField(_fSecondary_name_1, 'secondary_name_1', DbType.text);
  }

  static TableField? _fSecondary_name_2;
  static TableField get secondary_name_2 {
    return _fSecondary_name_2 = _fSecondary_name_2 ??
        SqlSyntax.setField(_fSecondary_name_2, 'secondary_name_2', DbType.text);
  }

  static TableField? _fLyrics;
  static TableField get lyrics {
    return _fLyrics =
        _fLyrics ?? SqlSyntax.setField(_fLyrics, 'lyrics', DbType.text);
  }

  static TableField? _fLang_string;
  static TableField get lang_string {
    return _fLang_string = _fLang_string ??
        SqlSyntax.setField(_fLang_string, 'lang_string', DbType.text);
  }

  static TableField? _fType_enum;
  static TableField get type_enum {
    return _fType_enum = _fType_enum ??
        SqlSyntax.setField(_fType_enum, 'type_enum', DbType.text);
  }

  static TableField? _fLilypond_svg;
  static TableField get lilypond_svg {
    return _fLilypond_svg = _fLilypond_svg ??
        SqlSyntax.setField(_fLilypond_svg, 'lilypond_svg', DbType.text);
  }

  static TableField? _fFavorite_rank;
  static TableField get favorite_rank {
    return _fFavorite_rank = _fFavorite_rank ??
        SqlSyntax.setField(_fFavorite_rank, 'favorite_rank', DbType.integer);
  }

  static TableField? _fTransposition;
  static TableField get transposition {
    return _fTransposition = _fTransposition ??
        SqlSyntax.setField(_fTransposition, 'transposition', DbType.integer);
  }

  static TableField? _fShow_chords;
  static TableField get show_chords {
    return _fShow_chords = _fShow_chords ??
        SqlSyntax.setField(_fShow_chords, 'show_chords', DbType.bool);
  }

  static TableField? _fAccidentals;
  static TableField get accidentals {
    return _fAccidentals = _fAccidentals ??
        SqlSyntax.setField(_fAccidentals, 'accidentals', DbType.integer);
  }

  static TableField? _fSongsId;
  static TableField get songsId {
    return _fSongsId =
        _fSongsId ?? SqlSyntax.setField(_fSongsId, 'songsId', DbType.integer);
  }
}
// endregion SongLyricFields

//region SongLyricManager
class SongLyricManager extends SqfEntityProvider {
  SongLyricManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'song_lyrics';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SongLyricManager
// region Tag
class Tag extends TableBase {
  Tag({this.id, this.name, this.type_enum}) {
    _setDefaultValues();
  }
  Tag.withFields(this.id, this.name, this.type_enum) {
    _setDefaultValues();
  }
  Tag.withId(this.id, this.name, this.type_enum) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Tag.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['type_enum'] != null) {
      type_enum = o['type_enum'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Tag)
  int? id;
  String? name;
  String? type_enum;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Tag)

// COLLECTIONS & VIRTUALS (Tag)
  ///(RelationType.MANY_TO_MANY) (song_lyricsTags) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyrics', 'plField2'..]) or so on..
  List<SongLyric>? plSongLyrics;

  /// get SongLyric(s) filtered by song_lyricsId IN song_lyricsTags
  SongLyricFilterBuilder? getSongLyrics(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongLyric()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT song_lyricsId FROM song_lyricsTags WHERE tagsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Tag)

  static const bool _softDeleteActivated = false;
  TagManager? __mnTag;

  TagManager get _mnTag {
    return __mnTag = __mnTag ?? TagManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (type_enum != null) {
      map['type_enum'] = type_enum;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (type_enum != null) {
      map['type_enum'] = type_enum;
    }

// COLLECTIONS (Tag)
    if (!forQuery) {
      map['SongLyrics'] = await getSongLyrics()!.toMapList();
    }
// END COLLECTIONS (Tag)

    return map;
  }

  /// This method returns Json String [Tag]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Tag]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name, type_enum];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, type_enum];
  }

  static Future<List<Tag>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Tag.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Tag>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Tag>[];
    try {
      objList =
          list.map((tag) => Tag.fromMap(tag as Map<String, dynamic>)).toList();
    } catch (e) {
      debugPrint('SQFENTITY ERROR Tag.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Tag>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Tag> objList = <Tag>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Tag.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tags.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('tags.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Tag by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Tag if exist, otherwise returns null
  Future<Tag?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Tag? obj;
    final data = await _mnTag.getById([id]);
    if (data.length != 0) {
      obj = Tag.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tags.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('tags.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Tag) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnTag.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTag.update(this);
    }

    return id;
  }

  /// Saves the (Tag) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnTag.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTag.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Tag> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Tag> tags) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in tags) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnTag.rawInsert(
          'INSERT OR REPLACE INTO tags (id, name, type_enum)  VALUES (?,?,?)',
          [id, name, type_enum]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Tag id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Tag id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Tag Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Tag>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Tag> tags) async {
    final results = await _mnTag.rawInsertAll(
        'INSERT OR REPLACE INTO tags (id, name, type_enum)  VALUES (?,?,?)',
        tags);
    return results;
  }

  /// Deletes Tag

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Tag invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTag
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnTag.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  TagFilterBuilder select({List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TagFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  TagFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TagFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tag

// region TagField
class TagField extends SearchCriteria {
  TagField(this.tagFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  TagFilterBuilder tagFB;

  TagField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  TagFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    tagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagFB.parameters, param, SqlSyntax.EQuals,
            tagFB._addedBlocks)
        : setCriteria(pValue, tagFB.parameters, param, SqlSyntax.NotEQuals,
            tagFB._addedBlocks);
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }

  TagFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    tagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagFB.parameters, param, SqlSyntax.EQualsOrNull,
            tagFB._addedBlocks)
        : setCriteria(pValue, tagFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, tagFB._addedBlocks);
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }

  TagFilterBuilder isNull() {
    tagFB._addedBlocks = setCriteria(
        0,
        tagFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        tagFB._addedBlocks);
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }

  TagFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      tagFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          tagFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          tagFB._addedBlocks);
      _waitingNot = '';
      tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
          tagFB._addedBlocks.retVal;
    }
    return tagFB;
  }

  TagFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      tagFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          tagFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          tagFB._addedBlocks);
      _waitingNot = '';
      tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
          tagFB._addedBlocks.retVal;
      tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
          tagFB._addedBlocks.retVal;
    }
    return tagFB;
  }

  TagFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      tagFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          tagFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          tagFB._addedBlocks);
      _waitingNot = '';
      tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
          tagFB._addedBlocks.retVal;
    }
    return tagFB;
  }

  TagFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      tagFB._addedBlocks = setCriteria(
          pFirst,
          tagFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          tagFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        tagFB._addedBlocks = setCriteria(pFirst, tagFB.parameters, param,
            SqlSyntax.LessThan, tagFB._addedBlocks);
      } else {
        tagFB._addedBlocks = setCriteria(pFirst, tagFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, tagFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        tagFB._addedBlocks = setCriteria(pLast, tagFB.parameters, param,
            SqlSyntax.GreaterThan, tagFB._addedBlocks);
      } else {
        tagFB._addedBlocks = setCriteria(pLast, tagFB.parameters, param,
            SqlSyntax.LessThanOrEquals, tagFB._addedBlocks);
      }
    }
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }

  TagFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    tagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagFB.parameters, param, SqlSyntax.GreaterThan,
            tagFB._addedBlocks)
        : setCriteria(pValue, tagFB.parameters, param,
            SqlSyntax.LessThanOrEquals, tagFB._addedBlocks);
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }

  TagFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    tagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagFB.parameters, param, SqlSyntax.LessThan,
            tagFB._addedBlocks)
        : setCriteria(pValue, tagFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, tagFB._addedBlocks);
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }

  TagFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    tagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, tagFB._addedBlocks)
        : setCriteria(pValue, tagFB.parameters, param, SqlSyntax.LessThan,
            tagFB._addedBlocks);
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }

  TagFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    tagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagFB.parameters, param,
            SqlSyntax.LessThanOrEquals, tagFB._addedBlocks)
        : setCriteria(pValue, tagFB.parameters, param, SqlSyntax.GreaterThan,
            tagFB._addedBlocks);
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }

  TagFilterBuilder inValues(dynamic pValue) {
    tagFB._addedBlocks = setCriteria(
        pValue,
        tagFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        tagFB._addedBlocks);
    _waitingNot = '';
    tagFB._addedBlocks.needEndBlock![tagFB._blockIndex] =
        tagFB._addedBlocks.retVal;
    return tagFB;
  }
}
// endregion TagField

// region TagFilterBuilder
class TagFilterBuilder extends SearchCriteria {
  TagFilterBuilder(Tag obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Tag? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  TagFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  TagFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  TagFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  TagFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  TagFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  TagFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  TagFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  TagFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  TagFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  TagFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  TagFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  TagField setField(TagField? field, String colName, DbType dbtype) {
    return TagField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  TagField? _id;
  TagField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  TagField? _name;
  TagField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  TagField? _type_enum;
  TagField get type_enum {
    return _type_enum = setField(_type_enum, 'type_enum', DbType.text);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Tag._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Tag> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Tag._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnTag.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnTag.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from tags ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnTag.updateBatch(qparams, values);
  }

  /// This method always returns Tag Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Tag>
  Future<Tag?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnTag.toList(qparams);
    final data = await objFuture;
    Tag? obj;
    if (data.isNotEmpty) {
      obj = Tag.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tags.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('tags.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Tag]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? tagCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tagsFuture = await _obj!._mnTag.toList(qparams);
    final int count = tagsFuture[0]['CNT'] as int;
    if (tagCount != null) {
      tagCount(count);
    }
    return count;
  }

  /// This method returns List<Tag> [Tag]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Tag>
  Future<List<Tag>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Tag> tagsData = await Tag.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tagsData;
  }

  /// This method returns Json String [Tag]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Tag]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Tag]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnTag.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Tag]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM tags WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnTag.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Tag]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnTag.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Tag.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnTag.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TagFilterBuilder

// region TagFields
class TagFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fType_enum;
  static TableField get type_enum {
    return _fType_enum = _fType_enum ??
        SqlSyntax.setField(_fType_enum, 'type_enum', DbType.text);
  }
}
// endregion TagFields

//region TagManager
class TagManager extends SqfEntityProvider {
  TagManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'tags';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion TagManager
// region ExternalsAuthors
class ExternalsAuthors extends TableBase {
  ExternalsAuthors({this.externalsId, this.authorsId}) {
    _setDefaultValues();
  }
  ExternalsAuthors.withFields(this.externalsId, this.authorsId) {
    _setDefaultValues();
  }
  ExternalsAuthors.withId(this.externalsId, this.authorsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ExternalsAuthors.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    externalsId = int.tryParse(o['externalsId'].toString());

    authorsId = int.tryParse(o['authorsId'].toString());

    // RELATIONSHIPS FromMAP
    plExternal = o['external'] != null
        ? External.fromMap(o['external'] as Map<String, dynamic>)
        : null;
    plAuthor = o['author'] != null
        ? Author.fromMap(o['author'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (ExternalsAuthors)
  int? externalsId;
  int? authorsId;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (ExternalsAuthors)

// RELATIONSHIPS (ExternalsAuthors)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plExternal', 'plField2'..]) or so on..
  External? plExternal;

  /// get External By ExternalsId
  Future<External?> getExternal(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await External().getById(externalsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAuthor', 'plField2'..]) or so on..
  Author? plAuthor;

  /// get Author By AuthorsId
  Future<Author?> getAuthor(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Author().getById(authorsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (ExternalsAuthors)

  static const bool _softDeleteActivated = false;
  ExternalsAuthorsManager? __mnExternalsAuthors;

  ExternalsAuthorsManager get _mnExternalsAuthors {
    return __mnExternalsAuthors =
        __mnExternalsAuthors ?? ExternalsAuthorsManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (externalsId != null) {
      map['externalsId'] = forView
          ? plExternal == null
              ? externalsId
              : plExternal!.public_name
          : externalsId;
    }

    if (authorsId != null) {
      map['authorsId'] = forView
          ? plAuthor == null
              ? authorsId
              : plAuthor!.name
          : authorsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (externalsId != null) {
      map['externalsId'] = forView
          ? plExternal == null
              ? externalsId
              : plExternal!.public_name
          : externalsId;
    }

    if (authorsId != null) {
      map['authorsId'] = forView
          ? plAuthor == null
              ? authorsId
              : plAuthor!.name
          : authorsId;
    }

    return map;
  }

  /// This method returns Json String [ExternalsAuthors]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ExternalsAuthors]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [externalsId, authorsId];
  }

  List<dynamic> toArgsWithIds() {
    return [externalsId, authorsId];
  }

  static Future<List<ExternalsAuthors>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ExternalsAuthors.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ExternalsAuthors>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ExternalsAuthors>[];
    try {
      objList = list
          .map((externalsauthors) => ExternalsAuthors.fromMap(
              externalsauthors as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ExternalsAuthors.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ExternalsAuthors>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ExternalsAuthors> objList = <ExternalsAuthors>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ExternalsAuthors.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plExternal') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExternal'))) {
          /*_loadedfields!.add('externals.plExternal');*/ obj.plExternal = obj
                  .plExternal ??
              await obj.getExternal(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plAuthor') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          /*_loadedfields!.add('authors.plAuthor');*/ obj.plAuthor = obj
                  .plAuthor ??
              await obj.getAuthor(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns ExternalsAuthors by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? externalsId, int? authorsId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns ExternalsAuthors if exist, otherwise returns null
  Future<ExternalsAuthors?> getById(int? externalsId, int? authorsId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (externalsId == null) {
      return null;
    }
    ExternalsAuthors? obj;
    final data = await _mnExternalsAuthors.getById([externalsId, authorsId]);
    if (data.length != 0) {
      obj = ExternalsAuthors.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plExternal') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExternal'))) {
          /*_loadedfields!.add('externals.plExternal');*/ obj.plExternal = obj
                  .plExternal ??
              await obj.getExternal(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plAuthor') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          /*_loadedfields!.add('authors.plAuthor');*/ obj.plAuthor = obj
                  .plAuthor ??
              await obj.getAuthor(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ExternalsAuthors) object. If the Primary Key (externalsId) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same externalsId
  ///
  /// <returns>Returns BoolResult
  Future<BoolResult> save() async {
    final result = BoolResult(success: false);
    try {
      await _mnExternalsAuthors.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO externalsAuthors ( externalsId, authorsId)  VALUES (?,?)',
          toArgsWithIds());
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  void rollbackId() {
    if (isInsert == true) {
      externalsId = null;
    }
  }

  /// saveAll method saves the sent List<ExternalsAuthors> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ExternalsAuthors> externalsauthorses) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in externalsauthorses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns 1

  Future<int?> upsert() async {
    try {
      final result = await _mnExternalsAuthors.rawInsert(
          'INSERT OR REPLACE INTO externalsAuthors ( externalsId, authorsId)  VALUES (?,?)',
          [externalsId, authorsId]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ExternalsAuthors externalsId=$externalsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ExternalsAuthors externalsId=$externalsId did not update');
      }
      return externalsId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ExternalsAuthors Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ExternalsAuthors>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<ExternalsAuthors> externalsauthorses) async {
    final results = await _mnExternalsAuthors.rawInsertAll(
        'INSERT OR REPLACE INTO externalsAuthors ( externalsId, authorsId)  VALUES (?,?)',
        externalsauthorses);
    return results;
  }

  /// Deletes ExternalsAuthors

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete ExternalsAuthors invoked (externalsId=$externalsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExternalsAuthors.delete(QueryParams(
          whereString: 'externalsId=? AND authorsId=?',
          whereArguments: [externalsId, authorsId]));
    } else {
      return _mnExternalsAuthors.updateBatch(
          QueryParams(
              whereString: 'externalsId=? AND authorsId=?',
              whereArguments: [externalsId, authorsId]),
          {'isDeleted': 1});
    }
  }

  ExternalsAuthorsFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExternalsAuthorsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ExternalsAuthorsFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExternalsAuthorsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion externalsauthors

// region ExternalsAuthorsField
class ExternalsAuthorsField extends SearchCriteria {
  ExternalsAuthorsField(this.externalsauthorsFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  ExternalsAuthorsFilterBuilder externalsauthorsFB;

  ExternalsAuthorsField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ExternalsAuthorsFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.EQuals, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.NotEQuals, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.EQualsOrNull, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder isNull() {
    externalsauthorsFB._addedBlocks = setCriteria(
        0,
        externalsauthorsFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      externalsauthorsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          externalsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalsauthorsFB._addedBlocks);
      _waitingNot = '';
      externalsauthorsFB
              ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
          externalsauthorsFB._addedBlocks.retVal;
    }
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      externalsauthorsFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          externalsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalsauthorsFB._addedBlocks);
      _waitingNot = '';
      externalsauthorsFB
              ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
          externalsauthorsFB._addedBlocks.retVal;
      externalsauthorsFB
              ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
          externalsauthorsFB._addedBlocks.retVal;
    }
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      externalsauthorsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          externalsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalsauthorsFB._addedBlocks);
      _waitingNot = '';
      externalsauthorsFB
              ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
          externalsauthorsFB._addedBlocks.retVal;
    }
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      externalsauthorsFB._addedBlocks = setCriteria(
          pFirst,
          externalsauthorsFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalsauthorsFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        externalsauthorsFB._addedBlocks = setCriteria(
            pFirst,
            externalsauthorsFB.parameters,
            param,
            SqlSyntax.LessThan,
            externalsauthorsFB._addedBlocks);
      } else {
        externalsauthorsFB._addedBlocks = setCriteria(
            pFirst,
            externalsauthorsFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            externalsauthorsFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        externalsauthorsFB._addedBlocks = setCriteria(
            pLast,
            externalsauthorsFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            externalsauthorsFB._addedBlocks);
      } else {
        externalsauthorsFB._addedBlocks = setCriteria(
            pLast,
            externalsauthorsFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            externalsauthorsFB._addedBlocks);
      }
    }
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.GreaterThan, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.LessThan, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.LessThan, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.GreaterThan, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder inValues(dynamic pValue) {
    externalsauthorsFB._addedBlocks = setCriteria(
        pValue,
        externalsauthorsFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock![externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }
}
// endregion ExternalsAuthorsField

// region ExternalsAuthorsFilterBuilder
class ExternalsAuthorsFilterBuilder extends SearchCriteria {
  ExternalsAuthorsFilterBuilder(ExternalsAuthors obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  ExternalsAuthors? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  ExternalsAuthorsFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ExternalsAuthorsFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ExternalsAuthorsFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ExternalsAuthorsFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ExternalsAuthorsFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ExternalsAuthorsFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ExternalsAuthorsFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExternalsAuthorsFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExternalsAuthorsFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExternalsAuthorsFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExternalsAuthorsFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ExternalsAuthorsField setField(
      ExternalsAuthorsField? field, String colName, DbType dbtype) {
    return ExternalsAuthorsField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  ExternalsAuthorsField? _externalsId;
  ExternalsAuthorsField get externalsId {
    return _externalsId = setField(_externalsId, 'externalsId', DbType.integer);
  }

  ExternalsAuthorsField? _authorsId;
  ExternalsAuthorsField get authorsId {
    return _authorsId = setField(_authorsId, 'authorsId', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (ExternalsAuthors._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<ExternalsAuthors> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (ExternalsAuthors._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnExternalsAuthors
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnExternalsAuthors.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'externalsId IN (SELECT externalsId from externalsAuthors ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnExternalsAuthors.updateBatch(qparams, values);
  }

  /// This method always returns ExternalsAuthors Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ExternalsAuthors>
  Future<ExternalsAuthors?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnExternalsAuthors.toList(qparams);
    final data = await objFuture;
    ExternalsAuthors? obj;
    if (data.isNotEmpty) {
      obj = ExternalsAuthors.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plExternal') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExternal'))) {
          /*_loadedfields!.add('externals.plExternal');*/ obj.plExternal = obj
                  .plExternal ??
              await obj.getExternal(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plAuthor') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          /*_loadedfields!.add('authors.plAuthor');*/ obj.plAuthor = obj
                  .plAuthor ??
              await obj.getAuthor(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [ExternalsAuthors]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? externalsauthorsCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final externalsauthorsesFuture =
        await _obj!._mnExternalsAuthors.toList(qparams);
    final int count = externalsauthorsesFuture[0]['CNT'] as int;
    if (externalsauthorsCount != null) {
      externalsauthorsCount(count);
    }
    return count;
  }

  /// This method returns List<ExternalsAuthors> [ExternalsAuthors]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ExternalsAuthors>
  Future<List<ExternalsAuthors>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ExternalsAuthors> externalsauthorsesData =
        await ExternalsAuthors.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return externalsauthorsesData;
  }

  /// This method returns Json String [ExternalsAuthors]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ExternalsAuthors]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ExternalsAuthors]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnExternalsAuthors.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ExternalsAuthors]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `externalsId`authorsId` FROM externalsAuthors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<externalsId,authorsId> [ExternalsAuthors]
  /// <returns>List<externalsId,authorsId>
  Future<List<ExternalsAuthors>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['externalsId', 'authorsId'];
    final externalsauthorsFuture =
        await _obj!._mnExternalsAuthors.toList(qparams);
    return await ExternalsAuthors.fromMapList(externalsauthorsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ExternalsAuthors]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnExternalsAuthors.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await ExternalsAuthors.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnExternalsAuthors.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExternalsAuthorsFilterBuilder

// region ExternalsAuthorsFields
class ExternalsAuthorsFields {
  static TableField? _fExternalsId;
  static TableField get externalsId {
    return _fExternalsId = _fExternalsId ??
        SqlSyntax.setField(_fExternalsId, 'externalsId', DbType.integer);
  }

  static TableField? _fAuthorsId;
  static TableField get authorsId {
    return _fAuthorsId = _fAuthorsId ??
        SqlSyntax.setField(_fAuthorsId, 'authorsId', DbType.integer);
  }
}
// endregion ExternalsAuthorsFields

//region ExternalsAuthorsManager
class ExternalsAuthorsManager extends SqfEntityProvider {
  ExternalsAuthorsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'externalsAuthors';
  static const List<String> _primaryKeyList = ['externalsId', 'authorsId'];
  static const String _whereStr = 'externalsId=? AND authorsId=?';
}

//endregion ExternalsAuthorsManager
// region Song_lyricsAuthors
class Song_lyricsAuthors extends TableBase {
  Song_lyricsAuthors({this.song_lyricsId, this.authorsId}) {
    _setDefaultValues();
  }
  Song_lyricsAuthors.withFields(this.song_lyricsId, this.authorsId) {
    _setDefaultValues();
  }
  Song_lyricsAuthors.withId(this.song_lyricsId, this.authorsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Song_lyricsAuthors.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    authorsId = int.tryParse(o['authorsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    plAuthor = o['author'] != null
        ? Author.fromMap(o['author'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Song_lyricsAuthors)
  int? song_lyricsId;
  int? authorsId;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Song_lyricsAuthors)

// RELATIONSHIPS (Song_lyricsAuthors)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAuthor', 'plField2'..]) or so on..
  Author? plAuthor;

  /// get Author By AuthorsId
  Future<Author?> getAuthor(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Author().getById(authorsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Song_lyricsAuthors)

  static const bool _softDeleteActivated = false;
  Song_lyricsAuthorsManager? __mnSong_lyricsAuthors;

  Song_lyricsAuthorsManager get _mnSong_lyricsAuthors {
    return __mnSong_lyricsAuthors =
        __mnSong_lyricsAuthors ?? Song_lyricsAuthorsManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    if (authorsId != null) {
      map['authorsId'] = forView
          ? plAuthor == null
              ? authorsId
              : plAuthor!.name
          : authorsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    if (authorsId != null) {
      map['authorsId'] = forView
          ? plAuthor == null
              ? authorsId
              : plAuthor!.name
          : authorsId;
    }

    return map;
  }

  /// This method returns Json String [Song_lyricsAuthors]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song_lyricsAuthors]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [song_lyricsId, authorsId];
  }

  List<dynamic> toArgsWithIds() {
    return [song_lyricsId, authorsId];
  }

  static Future<List<Song_lyricsAuthors>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song_lyricsAuthors.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Song_lyricsAuthors>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song_lyricsAuthors>[];
    try {
      objList = list
          .map((song_lyricsauthors) => Song_lyricsAuthors.fromMap(
              song_lyricsauthors as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song_lyricsAuthors.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song_lyricsAuthors>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song_lyricsAuthors> objList = <Song_lyricsAuthors>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song_lyricsAuthors.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plAuthor') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          /*_loadedfields!.add('authors.plAuthor');*/ obj.plAuthor = obj
                  .plAuthor ??
              await obj.getAuthor(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song_lyricsAuthors by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? song_lyricsId, int? authorsId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Song_lyricsAuthors if exist, otherwise returns null
  Future<Song_lyricsAuthors?> getById(int? song_lyricsId, int? authorsId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (song_lyricsId == null) {
      return null;
    }
    Song_lyricsAuthors? obj;
    final data =
        await _mnSong_lyricsAuthors.getById([song_lyricsId, authorsId]);
    if (data.length != 0) {
      obj = Song_lyricsAuthors.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plAuthor') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          /*_loadedfields!.add('authors.plAuthor');*/ obj.plAuthor = obj
                  .plAuthor ??
              await obj.getAuthor(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song_lyricsAuthors) object. If the Primary Key (song_lyricsId) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same song_lyricsId
  ///
  /// <returns>Returns BoolResult
  Future<BoolResult> save() async {
    final result = BoolResult(success: false);
    try {
      await _mnSong_lyricsAuthors.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO song_lyricsAuthors ( song_lyricsId, authorsId)  VALUES (?,?)',
          toArgsWithIds());
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  void rollbackId() {
    if (isInsert == true) {
      song_lyricsId = null;
    }
  }

  /// saveAll method saves the sent List<Song_lyricsAuthors> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Song_lyricsAuthors> song_lyricsauthorses) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in song_lyricsauthorses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns 1

  Future<int?> upsert() async {
    try {
      final result = await _mnSong_lyricsAuthors.rawInsert(
          'INSERT OR REPLACE INTO song_lyricsAuthors ( song_lyricsId, authorsId)  VALUES (?,?)',
          [song_lyricsId, authorsId]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Song_lyricsAuthors song_lyricsId=$song_lyricsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Song_lyricsAuthors song_lyricsId=$song_lyricsId did not update');
      }
      return song_lyricsId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'Song_lyricsAuthors Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Song_lyricsAuthors>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<Song_lyricsAuthors> song_lyricsauthorses) async {
    final results = await _mnSong_lyricsAuthors.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyricsAuthors ( song_lyricsId, authorsId)  VALUES (?,?)',
        song_lyricsauthorses);
    return results;
  }

  /// Deletes Song_lyricsAuthors

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Song_lyricsAuthors invoked (song_lyricsId=$song_lyricsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong_lyricsAuthors.delete(QueryParams(
          whereString: 'song_lyricsId=? AND authorsId=?',
          whereArguments: [song_lyricsId, authorsId]));
    } else {
      return _mnSong_lyricsAuthors.updateBatch(
          QueryParams(
              whereString: 'song_lyricsId=? AND authorsId=?',
              whereArguments: [song_lyricsId, authorsId]),
          {'isDeleted': 1});
    }
  }

  Song_lyricsAuthorsFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Song_lyricsAuthorsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  Song_lyricsAuthorsFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Song_lyricsAuthorsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion song_lyricsauthors

// region Song_lyricsAuthorsField
class Song_lyricsAuthorsField extends SearchCriteria {
  Song_lyricsAuthorsField(this.song_lyricsauthorsFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  Song_lyricsAuthorsFilterBuilder song_lyricsauthorsFB;

  Song_lyricsAuthorsField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  Song_lyricsAuthorsFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.EQuals, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.NotEQuals, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.EQualsOrNull, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder isNull() {
    song_lyricsauthorsFB._addedBlocks = setCriteria(
        0,
        song_lyricsauthorsFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      song_lyricsauthorsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          song_lyricsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsauthorsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsauthorsFB
              ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
          song_lyricsauthorsFB._addedBlocks.retVal;
    }
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricsauthorsFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          song_lyricsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsauthorsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsauthorsFB
              ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
          song_lyricsauthorsFB._addedBlocks.retVal;
      song_lyricsauthorsFB
              ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
          song_lyricsauthorsFB._addedBlocks.retVal;
    }
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricsauthorsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          song_lyricsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsauthorsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsauthorsFB
              ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
          song_lyricsauthorsFB._addedBlocks.retVal;
    }
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      song_lyricsauthorsFB._addedBlocks = setCriteria(
          pFirst,
          song_lyricsauthorsFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsauthorsFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        song_lyricsauthorsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricsauthorsFB.parameters,
            param,
            SqlSyntax.LessThan,
            song_lyricsauthorsFB._addedBlocks);
      } else {
        song_lyricsauthorsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricsauthorsFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            song_lyricsauthorsFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        song_lyricsauthorsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricsauthorsFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            song_lyricsauthorsFB._addedBlocks);
      } else {
        song_lyricsauthorsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricsauthorsFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            song_lyricsauthorsFB._addedBlocks);
      }
    }
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder inValues(dynamic pValue) {
    song_lyricsauthorsFB._addedBlocks = setCriteria(
        pValue,
        song_lyricsauthorsFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock![song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }
}
// endregion Song_lyricsAuthorsField

// region Song_lyricsAuthorsFilterBuilder
class Song_lyricsAuthorsFilterBuilder extends SearchCriteria {
  Song_lyricsAuthorsFilterBuilder(Song_lyricsAuthors obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Song_lyricsAuthors? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  Song_lyricsAuthorsFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  Song_lyricsAuthorsFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  Song_lyricsAuthorsFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  Song_lyricsAuthorsFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  Song_lyricsAuthorsFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  Song_lyricsAuthorsFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  Song_lyricsAuthorsFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsAuthorsFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsAuthorsFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsAuthorsFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsAuthorsFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  Song_lyricsAuthorsField setField(
      Song_lyricsAuthorsField? field, String colName, DbType dbtype) {
    return Song_lyricsAuthorsField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  Song_lyricsAuthorsField? _song_lyricsId;
  Song_lyricsAuthorsField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  Song_lyricsAuthorsField? _authorsId;
  Song_lyricsAuthorsField get authorsId {
    return _authorsId = setField(_authorsId, 'authorsId', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Song_lyricsAuthors._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Song_lyricsAuthors> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Song_lyricsAuthors._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnSong_lyricsAuthors
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnSong_lyricsAuthors.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'song_lyricsId IN (SELECT song_lyricsId from song_lyricsAuthors ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnSong_lyricsAuthors.updateBatch(qparams, values);
  }

  /// This method always returns Song_lyricsAuthors Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsAuthors>
  Future<Song_lyricsAuthors?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnSong_lyricsAuthors.toList(qparams);
    final data = await objFuture;
    Song_lyricsAuthors? obj;
    if (data.isNotEmpty) {
      obj = Song_lyricsAuthors.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plAuthor') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          /*_loadedfields!.add('authors.plAuthor');*/ obj.plAuthor = obj
                  .plAuthor ??
              await obj.getAuthor(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Song_lyricsAuthors]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? song_lyricsauthorsCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final song_lyricsauthorsesFuture =
        await _obj!._mnSong_lyricsAuthors.toList(qparams);
    final int count = song_lyricsauthorsesFuture[0]['CNT'] as int;
    if (song_lyricsauthorsCount != null) {
      song_lyricsauthorsCount(count);
    }
    return count;
  }

  /// This method returns List<Song_lyricsAuthors> [Song_lyricsAuthors]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsAuthors>
  Future<List<Song_lyricsAuthors>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Song_lyricsAuthors> song_lyricsauthorsesData =
        await Song_lyricsAuthors.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return song_lyricsauthorsesData;
  }

  /// This method returns Json String [Song_lyricsAuthors]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song_lyricsAuthors]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song_lyricsAuthors]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnSong_lyricsAuthors.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song_lyricsAuthors]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `song_lyricsId`authorsId` FROM song_lyricsAuthors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<song_lyricsId,authorsId> [Song_lyricsAuthors]
  /// <returns>List<song_lyricsId,authorsId>
  Future<List<Song_lyricsAuthors>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['song_lyricsId', 'authorsId'];
    final song_lyricsauthorsFuture =
        await _obj!._mnSong_lyricsAuthors.toList(qparams);
    return await Song_lyricsAuthors.fromMapList(song_lyricsauthorsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song_lyricsAuthors]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnSong_lyricsAuthors.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Song_lyricsAuthors.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnSong_lyricsAuthors.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Song_lyricsAuthorsFilterBuilder

// region Song_lyricsAuthorsFields
class Song_lyricsAuthorsFields {
  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }

  static TableField? _fAuthorsId;
  static TableField get authorsId {
    return _fAuthorsId = _fAuthorsId ??
        SqlSyntax.setField(_fAuthorsId, 'authorsId', DbType.integer);
  }
}
// endregion Song_lyricsAuthorsFields

//region Song_lyricsAuthorsManager
class Song_lyricsAuthorsManager extends SqfEntityProvider {
  Song_lyricsAuthorsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'song_lyricsAuthors';
  static const List<String> _primaryKeyList = ['song_lyricsId', 'authorsId'];
  static const String _whereStr = 'song_lyricsId=? AND authorsId=?';
}

//endregion Song_lyricsAuthorsManager
// region Song_lyricsTags
class Song_lyricsTags extends TableBase {
  Song_lyricsTags({this.song_lyricsId, this.tagsId}) {
    _setDefaultValues();
  }
  Song_lyricsTags.withFields(this.song_lyricsId, this.tagsId) {
    _setDefaultValues();
  }
  Song_lyricsTags.withId(this.song_lyricsId, this.tagsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Song_lyricsTags.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    tagsId = int.tryParse(o['tagsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    plTag =
        o['tag'] != null ? Tag.fromMap(o['tag'] as Map<String, dynamic>) : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Song_lyricsTags)
  int? song_lyricsId;
  int? tagsId;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Song_lyricsTags)

// RELATIONSHIPS (Song_lyricsTags)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTag', 'plField2'..]) or so on..
  Tag? plTag;

  /// get Tag By TagsId
  Future<Tag?> getTag(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Tag()
        .getById(tagsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Song_lyricsTags)

  static const bool _softDeleteActivated = false;
  Song_lyricsTagsManager? __mnSong_lyricsTags;

  Song_lyricsTagsManager get _mnSong_lyricsTags {
    return __mnSong_lyricsTags =
        __mnSong_lyricsTags ?? Song_lyricsTagsManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    if (tagsId != null) {
      map['tagsId'] = forView
          ? plTag == null
              ? tagsId
              : plTag!.name
          : tagsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    }

    if (tagsId != null) {
      map['tagsId'] = forView
          ? plTag == null
              ? tagsId
              : plTag!.name
          : tagsId;
    }

    return map;
  }

  /// This method returns Json String [Song_lyricsTags]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song_lyricsTags]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [song_lyricsId, tagsId];
  }

  List<dynamic> toArgsWithIds() {
    return [song_lyricsId, tagsId];
  }

  static Future<List<Song_lyricsTags>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song_lyricsTags.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Song_lyricsTags>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song_lyricsTags>[];
    try {
      objList = list
          .map((song_lyricstags) =>
              Song_lyricsTags.fromMap(song_lyricstags as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song_lyricsTags.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song_lyricsTags>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song_lyricsTags> objList = <Song_lyricsTags>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song_lyricsTags.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('tags.plTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTag'))) {
          /*_loadedfields!.add('tags.plTag');*/ obj.plTag = obj.plTag ??
              await obj.getTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song_lyricsTags by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? song_lyricsId, int? tagsId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Song_lyricsTags if exist, otherwise returns null
  Future<Song_lyricsTags?> getById(int? song_lyricsId, int? tagsId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (song_lyricsId == null) {
      return null;
    }
    Song_lyricsTags? obj;
    final data = await _mnSong_lyricsTags.getById([song_lyricsId, tagsId]);
    if (data.length != 0) {
      obj = Song_lyricsTags.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('tags.plTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTag'))) {
          /*_loadedfields!.add('tags.plTag');*/ obj.plTag = obj.plTag ??
              await obj.getTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song_lyricsTags) object. If the Primary Key (song_lyricsId) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same song_lyricsId
  ///
  /// <returns>Returns BoolResult
  Future<BoolResult> save() async {
    final result = BoolResult(success: false);
    try {
      await _mnSong_lyricsTags.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO song_lyricsTags ( song_lyricsId, tagsId)  VALUES (?,?)',
          toArgsWithIds());
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  void rollbackId() {
    if (isInsert == true) {
      song_lyricsId = null;
    }
  }

  /// saveAll method saves the sent List<Song_lyricsTags> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Song_lyricsTags> song_lyricstagses) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in song_lyricstagses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns 1

  Future<int?> upsert() async {
    try {
      final result = await _mnSong_lyricsTags.rawInsert(
          'INSERT OR REPLACE INTO song_lyricsTags ( song_lyricsId, tagsId)  VALUES (?,?)',
          [song_lyricsId, tagsId]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Song_lyricsTags song_lyricsId=$song_lyricsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Song_lyricsTags song_lyricsId=$song_lyricsId did not update');
      }
      return song_lyricsId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Song_lyricsTags Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Song_lyricsTags>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<Song_lyricsTags> song_lyricstagses) async {
    final results = await _mnSong_lyricsTags.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyricsTags ( song_lyricsId, tagsId)  VALUES (?,?)',
        song_lyricstagses);
    return results;
  }

  /// Deletes Song_lyricsTags

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Song_lyricsTags invoked (song_lyricsId=$song_lyricsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong_lyricsTags.delete(QueryParams(
          whereString: 'song_lyricsId=? AND tagsId=?',
          whereArguments: [song_lyricsId, tagsId]));
    } else {
      return _mnSong_lyricsTags.updateBatch(
          QueryParams(
              whereString: 'song_lyricsId=? AND tagsId=?',
              whereArguments: [song_lyricsId, tagsId]),
          {'isDeleted': 1});
    }
  }

  Song_lyricsTagsFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Song_lyricsTagsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  Song_lyricsTagsFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Song_lyricsTagsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion song_lyricstags

// region Song_lyricsTagsField
class Song_lyricsTagsField extends SearchCriteria {
  Song_lyricsTagsField(this.song_lyricstagsFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  Song_lyricsTagsFilterBuilder song_lyricstagsFB;

  Song_lyricsTagsField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  Song_lyricsTagsFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.EQuals, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.NotEQuals, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.EQualsOrNull, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder isNull() {
    song_lyricstagsFB._addedBlocks = setCriteria(
        0,
        song_lyricstagsFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      song_lyricstagsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          song_lyricstagsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricstagsFB._addedBlocks);
      _waitingNot = '';
      song_lyricstagsFB
              ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
          song_lyricstagsFB._addedBlocks.retVal;
    }
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricstagsFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          song_lyricstagsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricstagsFB._addedBlocks);
      _waitingNot = '';
      song_lyricstagsFB
              ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
          song_lyricstagsFB._addedBlocks.retVal;
      song_lyricstagsFB
              ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
          song_lyricstagsFB._addedBlocks.retVal;
    }
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricstagsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          song_lyricstagsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricstagsFB._addedBlocks);
      _waitingNot = '';
      song_lyricstagsFB
              ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
          song_lyricstagsFB._addedBlocks.retVal;
    }
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      song_lyricstagsFB._addedBlocks = setCriteria(
          pFirst,
          song_lyricstagsFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricstagsFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        song_lyricstagsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricstagsFB.parameters,
            param,
            SqlSyntax.LessThan,
            song_lyricstagsFB._addedBlocks);
      } else {
        song_lyricstagsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricstagsFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            song_lyricstagsFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        song_lyricstagsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricstagsFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            song_lyricstagsFB._addedBlocks);
      } else {
        song_lyricstagsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricstagsFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            song_lyricstagsFB._addedBlocks);
      }
    }
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder inValues(dynamic pValue) {
    song_lyricstagsFB._addedBlocks = setCriteria(
        pValue,
        song_lyricstagsFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB
            ._addedBlocks.needEndBlock![song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }
}
// endregion Song_lyricsTagsField

// region Song_lyricsTagsFilterBuilder
class Song_lyricsTagsFilterBuilder extends SearchCriteria {
  Song_lyricsTagsFilterBuilder(Song_lyricsTags obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Song_lyricsTags? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  Song_lyricsTagsFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  Song_lyricsTagsFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  Song_lyricsTagsFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  Song_lyricsTagsFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  Song_lyricsTagsFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  Song_lyricsTagsFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  Song_lyricsTagsFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsTagsFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsTagsFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsTagsFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsTagsFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  Song_lyricsTagsField setField(
      Song_lyricsTagsField? field, String colName, DbType dbtype) {
    return Song_lyricsTagsField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  Song_lyricsTagsField? _song_lyricsId;
  Song_lyricsTagsField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  Song_lyricsTagsField? _tagsId;
  Song_lyricsTagsField get tagsId {
    return _tagsId = setField(_tagsId, 'tagsId', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Song_lyricsTags._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Song_lyricsTags> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Song_lyricsTags._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnSong_lyricsTags.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnSong_lyricsTags.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'song_lyricsId IN (SELECT song_lyricsId from song_lyricsTags ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnSong_lyricsTags.updateBatch(qparams, values);
  }

  /// This method always returns Song_lyricsTags Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsTags>
  Future<Song_lyricsTags?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnSong_lyricsTags.toList(qparams);
    final data = await objFuture;
    Song_lyricsTags? obj;
    if (data.isNotEmpty) {
      obj = Song_lyricsTags.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plSongLyric') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          /*_loadedfields!.add('song_lyrics.plSongLyric');*/ obj.plSongLyric =
              obj.plSongLyric ??
                  await obj.getSongLyric(
                      loadParents:
                          loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('tags.plTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTag'))) {
          /*_loadedfields!.add('tags.plTag');*/ obj.plTag = obj.plTag ??
              await obj.getTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Song_lyricsTags]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? song_lyricstagsCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final song_lyricstagsesFuture =
        await _obj!._mnSong_lyricsTags.toList(qparams);
    final int count = song_lyricstagsesFuture[0]['CNT'] as int;
    if (song_lyricstagsCount != null) {
      song_lyricstagsCount(count);
    }
    return count;
  }

  /// This method returns List<Song_lyricsTags> [Song_lyricsTags]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsTags>
  Future<List<Song_lyricsTags>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Song_lyricsTags> song_lyricstagsesData =
        await Song_lyricsTags.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return song_lyricstagsesData;
  }

  /// This method returns Json String [Song_lyricsTags]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song_lyricsTags]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song_lyricsTags]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnSong_lyricsTags.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song_lyricsTags]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `song_lyricsId`tagsId` FROM song_lyricsTags WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<song_lyricsId,tagsId> [Song_lyricsTags]
  /// <returns>List<song_lyricsId,tagsId>
  Future<List<Song_lyricsTags>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['song_lyricsId', 'tagsId'];
    final song_lyricstagsFuture =
        await _obj!._mnSong_lyricsTags.toList(qparams);
    return await Song_lyricsTags.fromMapList(song_lyricstagsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song_lyricsTags]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnSong_lyricsTags.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Song_lyricsTags.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnSong_lyricsTags.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Song_lyricsTagsFilterBuilder

// region Song_lyricsTagsFields
class Song_lyricsTagsFields {
  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }

  static TableField? _fTagsId;
  static TableField get tagsId {
    return _fTagsId =
        _fTagsId ?? SqlSyntax.setField(_fTagsId, 'tagsId', DbType.integer);
  }
}
// endregion Song_lyricsTagsFields

//region Song_lyricsTagsManager
class Song_lyricsTagsManager extends SqfEntityProvider {
  Song_lyricsTagsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'song_lyricsTags';
  static const List<String> _primaryKeyList = ['song_lyricsId', 'tagsId'];
  static const String _whereStr = 'song_lyricsId=? AND tagsId=?';
}

//endregion Song_lyricsTagsManager
class ModelSequenceManager extends SqfEntityProvider {
  ModelSequenceManager() : super(Model());
}
// END OF ENTITIES
