// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:AuthorEntity.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// ignore_for_file:
// BEGIN TABLES
// AuthorEntity TABLE
class TableAuthorEntity extends SqfEntityTableBase {
  TableAuthorEntity() {
    // declare properties of EntityTable
    tableName = 'authors';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAuthorEntity();
  }
}

// ExternalEntity TABLE
class TableExternalEntity extends SqfEntityTableBase {
  TableExternalEntity() {
    // declare properties of EntityTable
    tableName = 'externals';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('mediaId', DbType.text, isNotNull: false),
      SqfEntityFieldBase('mediaType', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableSongLyricEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExternalEntity();
  }
}

// PlaylistEntity TABLE
class TablePlaylistEntity extends SqfEntityTableBase {
  TablePlaylistEntity() {
    // declare properties of EntityTable
    tableName = 'playlists';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('isArchived', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('order', DbType.integer, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylistEntity();
  }
}

// SongEntity TABLE
class TableSongEntity extends SqfEntityTableBase {
  TableSongEntity() {
    // declare properties of EntityTable
    tableName = 'songs';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongEntity();
  }
}

// SongbookEntity TABLE
class TableSongbookEntity extends SqfEntityTableBase {
  TableSongbookEntity() {
    // declare properties of EntityTable
    tableName = 'songbooks';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('shortcut', DbType.text, isNotNull: true),
      SqfEntityFieldBase('color', DbType.text, isNotNull: false),
      SqfEntityFieldBase('colorText', DbType.text, isNotNull: false),
      SqfEntityFieldBase('isPrivate', DbType.bool, isNotNull: true),
      SqfEntityFieldBase('isPinned', DbType.bool,
          defaultValue: false, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongbookEntity();
  }
}

// SongbookRecordEntity TABLE
class TableSongbookRecordEntity extends SqfEntityTableBase {
  TableSongbookRecordEntity() {
    // declare properties of EntityTable
    tableName = 'songbook_records';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('number', DbType.text, isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableSongbookEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'songbooksId',
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableSongLyricEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongbookRecordEntity();
  }
}

// SongLyricEntity TABLE
class TableSongLyricEntity extends SqfEntityTableBase {
  TableSongLyricEntity() {
    // declare properties of EntityTable
    tableName = 'song_lyrics';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('secondaryName1', DbType.text, isNotNull: false),
      SqfEntityFieldBase('secondaryName2', DbType.text, isNotNull: false),
      SqfEntityFieldBase('lyrics', DbType.text, isNotNull: false),
      SqfEntityFieldBase('language', DbType.text, isNotNull: false),
      SqfEntityFieldBase('type', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('lilypond', DbType.text, isNotNull: false),
      SqfEntityFieldBase('favoriteOrder', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('transposition', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('showChords', DbType.bool, isNotNull: false),
      SqfEntityFieldBase('accidentals', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableSongEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'songsId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongLyricEntity();
  }
}

// TagEntity TABLE
class TableTagEntity extends SqfEntityTableBase {
  TableTagEntity() {
    // declare properties of EntityTable
    tableName = 'tags';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('type', DbType.integer, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTagEntity();
  }
}

// ExternalsAuthors TABLE
class TableExternalsAuthors extends SqfEntityTableBase {
  TableExternalsAuthors() {
    // declare properties of EntityTable
    tableName = 'externalsAuthors';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    primaryKeyType = null;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableExternalEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'externalsId',
          isPrimaryKeyField: true,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableAuthorEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'authorsId',
          isPrimaryKeyField: true,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExternalsAuthors();
  }
}

// Song_lyricsAuthors TABLE
class TableSong_lyricsAuthors extends SqfEntityTableBase {
  TableSong_lyricsAuthors() {
    // declare properties of EntityTable
    tableName = 'song_lyricsAuthors';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    primaryKeyType = null;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableSongLyricEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isPrimaryKeyField: true,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableAuthorEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'authorsId',
          isPrimaryKeyField: true,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong_lyricsAuthors();
  }
}

// Song_lyricsPlaylists TABLE
class TableSong_lyricsPlaylists extends SqfEntityTableBase {
  TableSong_lyricsPlaylists() {
    // declare properties of EntityTable
    tableName = 'song_lyricsPlaylists';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    primaryKeyType = null;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableSongLyricEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isPrimaryKeyField: true,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TablePlaylistEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'playlistsId',
          isPrimaryKeyField: true,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong_lyricsPlaylists();
  }
}

// Song_lyricsTags TABLE
class TableSong_lyricsTags extends SqfEntityTableBase {
  TableSong_lyricsTags() {
    // declare properties of EntityTable
    tableName = 'song_lyricsTags';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    primaryKeyType = null;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableSongLyricEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isPrimaryKeyField: true,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableTagEntity.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'tagsId',
          isPrimaryKeyField: true,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong_lyricsTags();
  }
}
// END TABLES

// BEGIN SEQUENCES
// END SEQUENCES

// BEGIN DATABASE MODEL
class Model extends SqfEntityModelProvider {
  Model() {
    databaseName = model.databaseName;
    password = model.password;
    dbVersion = model.dbVersion;
    databaseTables = [
      TableAuthorEntity.getInstance,
      TableExternalEntity.getInstance,
      TablePlaylistEntity.getInstance,
      TableSongEntity.getInstance,
      TableSongbookEntity.getInstance,
      TableSongbookRecordEntity.getInstance,
      TableSongLyricEntity.getInstance,
      TableTagEntity.getInstance,
    ];

    bundledDatabasePath = model
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region AuthorEntity
class AuthorEntity {
  AuthorEntity({this.id, this.name}) {
    _setDefaultValues();
  }
  AuthorEntity.withFields(this.id, this.name) {
    _setDefaultValues();
  }
  AuthorEntity.withId(this.id, this.name) {
    _setDefaultValues();
  }
  AuthorEntity.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }

    isSaved = true;
  }
  // FIELDS (AuthorEntity)
  int id;
  String name;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (AuthorEntity)

// COLLECTIONS & VIRTUALS (AuthorEntity)
  ///(RelationType.MANY_TO_MANY) (externalsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExternalEntities', 'plField2'..]) or so on..
  List<ExternalEntity> plExternalEntities;

  /// get ExternalEntity(s) filtered by externalsId IN externalsAuthors
  ExternalEntityFilterBuilder getExternalEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExternalEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT externalsId FROM externalsAuthors WHERE authorsId=?)',
            parameterValue: id)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (song_lyricsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntities', 'plField2'..]) or so on..
  List<SongLyricEntity> plSongLyricEntities;

  /// get SongLyricEntity(s) filtered by song_lyricsId IN song_lyricsAuthors
  SongLyricEntityFilterBuilder getSongLyricEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongLyricEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT song_lyricsId FROM song_lyricsAuthors WHERE authorsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (AuthorEntity)

  static const bool _softDeleteActivated = false;
  AuthorEntityManager __mnAuthorEntity;

  AuthorEntityManager get _mnAuthorEntity {
    return __mnAuthorEntity = __mnAuthorEntity ?? AuthorEntityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

// COLLECTIONS (AuthorEntity)
    if (!forQuery) {
      map['ExternalEntities'] = await getExternalEntities().toMapList();
    }
    if (!forQuery) {
      map['SongLyricEntities'] = await getSongLyricEntities().toMapList();
    }
// END COLLECTIONS (AuthorEntity)

    return map;
  }

  /// This method returns Json String [AuthorEntity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [AuthorEntity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name];
  }

  static Future<List<AuthorEntity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR AuthorEntity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<AuthorEntity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <AuthorEntity>[];
    try {
      objList = list
          .map((authorentity) =>
              AuthorEntity.fromMap(authorentity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR AuthorEntity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<AuthorEntity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<AuthorEntity> objList = <AuthorEntity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = AuthorEntity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('authors.plExternalEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternalEntities'))) {
          /*_loadedFields.add('authors.plExternalEntities'); */
          obj.plExternalEntities = obj.plExternalEntities ??
              await obj.getExternalEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('authors.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns AuthorEntity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns AuthorEntity if exist, otherwise returns null
  Future<AuthorEntity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    AuthorEntity obj;
    final data = await _mnAuthorEntity.getById([id]);
    if (data.length != 0) {
      obj = AuthorEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('authors.plExternalEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternalEntities'))) {
          /*_loadedFields.add('authors.plExternalEntities'); */
          obj.plExternalEntities = obj.plExternalEntities ??
              await obj.getExternalEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('authors.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (AuthorEntity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0 || !isSaved) {
      await _mnAuthorEntity.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAuthorEntity.update(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<AuthorEntity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<AuthorEntity> authorentities) async {
    // final results = _mnAuthorEntity.saveAll('INSERT OR REPLACE INTO authors (id,name)  VALUES (?,?)',authorentities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in authorentities) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnAuthorEntity.rawInsert(
              'INSERT OR REPLACE INTO authors (id,name)  VALUES (?,?)',
              [id, name]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'AuthorEntity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'AuthorEntity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'AuthorEntity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<AuthorEntity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<AuthorEntity> authorentities) async {
    final results = await _mnAuthorEntity.rawInsertAll(
        'INSERT OR REPLACE INTO authors (id,name)  VALUES (?,?)',
        authorentities);
    return results;
  }

  /// Deletes AuthorEntity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete AuthorEntity invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnAuthorEntity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnAuthorEntity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  AuthorEntityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return AuthorEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  AuthorEntityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return AuthorEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion authorentity

// region AuthorEntityField
class AuthorEntityField extends SearchCriteria {
  AuthorEntityField(this.authorentityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  AuthorEntityFilterBuilder authorentityFB;

  AuthorEntityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  AuthorEntityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    authorentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.EQuals, authorentityFB._addedBlocks)
        : setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.NotEQuals, authorentityFB._addedBlocks);
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }

  AuthorEntityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    authorentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.EQualsOrNull, authorentityFB._addedBlocks)
        : setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, authorentityFB._addedBlocks);
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }

  AuthorEntityFilterBuilder isNull() {
    authorentityFB._addedBlocks = setCriteria(
        0,
        authorentityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        authorentityFB._addedBlocks);
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }

  AuthorEntityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      authorentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          authorentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          authorentityFB._addedBlocks);
      _waitingNot = '';
      authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
          authorentityFB._addedBlocks.retVal;
    }
    return authorentityFB;
  }

  AuthorEntityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      authorentityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          authorentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          authorentityFB._addedBlocks);
      _waitingNot = '';
      authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
          authorentityFB._addedBlocks.retVal;
      authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
          authorentityFB._addedBlocks.retVal;
    }
    return authorentityFB;
  }

  AuthorEntityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      authorentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          authorentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          authorentityFB._addedBlocks);
      _waitingNot = '';
      authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
          authorentityFB._addedBlocks.retVal;
    }
    return authorentityFB;
  }

  AuthorEntityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      authorentityFB._addedBlocks = setCriteria(
          pFirst,
          authorentityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          authorentityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        authorentityFB._addedBlocks = setCriteria(
            pFirst,
            authorentityFB.parameters,
            param,
            SqlSyntax.LessThan,
            authorentityFB._addedBlocks);
      } else {
        authorentityFB._addedBlocks = setCriteria(
            pFirst,
            authorentityFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            authorentityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        authorentityFB._addedBlocks = setCriteria(
            pLast,
            authorentityFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            authorentityFB._addedBlocks);
      } else {
        authorentityFB._addedBlocks = setCriteria(
            pLast,
            authorentityFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            authorentityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }

  AuthorEntityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    authorentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.GreaterThan, authorentityFB._addedBlocks)
        : setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, authorentityFB._addedBlocks);
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }

  AuthorEntityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    authorentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.LessThan, authorentityFB._addedBlocks)
        : setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, authorentityFB._addedBlocks);
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }

  AuthorEntityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    authorentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, authorentityFB._addedBlocks)
        : setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.LessThan, authorentityFB._addedBlocks);
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }

  AuthorEntityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    authorentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, authorentityFB._addedBlocks)
        : setCriteria(pValue, authorentityFB.parameters, param,
            SqlSyntax.GreaterThan, authorentityFB._addedBlocks);
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }

  AuthorEntityFilterBuilder inValues(dynamic pValue) {
    authorentityFB._addedBlocks = setCriteria(
        pValue,
        authorentityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        authorentityFB._addedBlocks);
    _waitingNot = '';
    authorentityFB._addedBlocks.needEndBlock[authorentityFB._blockIndex] =
        authorentityFB._addedBlocks.retVal;
    return authorentityFB;
  }
}
// endregion AuthorEntityField

// region AuthorEntityFilterBuilder
class AuthorEntityFilterBuilder extends SearchCriteria {
  AuthorEntityFilterBuilder(AuthorEntity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  AuthorEntity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  AuthorEntityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  AuthorEntityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  AuthorEntityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  AuthorEntityFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  AuthorEntityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  AuthorEntityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  AuthorEntityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  AuthorEntityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  AuthorEntityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  AuthorEntityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  AuthorEntityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  AuthorEntityField setField(
      AuthorEntityField field, String colName, DbType dbtype) {
    return AuthorEntityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  AuthorEntityField _id;
  AuthorEntityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  AuthorEntityField _name;
  AuthorEntityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (AuthorEntity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<AuthorEntity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (AuthorEntity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnAuthorEntity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnAuthorEntity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from authors ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnAuthorEntity.updateBatch(qparams, values);
  }

  /// This method always returns AuthorEntity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<AuthorEntity>
  Future<AuthorEntity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnAuthorEntity.toList(qparams);
    final data = await objFuture;
    AuthorEntity obj;
    if (data.isNotEmpty) {
      obj = AuthorEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('authors.plExternalEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternalEntities'))) {
          /*_loadedFields.add('authors.plExternalEntities'); */
          obj.plExternalEntities = obj.plExternalEntities ??
              await obj.getExternalEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('authors.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [AuthorEntity]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) authorentityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final authorentitiesFuture = await _obj._mnAuthorEntity.toList(qparams);
    final int count = authorentitiesFuture[0]['CNT'] as int;
    if (authorentityCount != null) {
      authorentityCount(count);
    }
    return count;
  }

  /// This method returns List<AuthorEntity> [AuthorEntity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<AuthorEntity>
  Future<List<AuthorEntity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<AuthorEntity> authorentitiesData =
        await AuthorEntity.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return authorentitiesData;
  }

  /// This method returns Json String [AuthorEntity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [AuthorEntity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [AuthorEntity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnAuthorEntity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [AuthorEntity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM authors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnAuthorEntity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [AuthorEntity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnAuthorEntity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await AuthorEntity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnAuthorEntity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AuthorEntityFilterBuilder

// region AuthorEntityFields
class AuthorEntityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }
}
// endregion AuthorEntityFields

//region AuthorEntityManager
class AuthorEntityManager extends SqfEntityProvider {
  AuthorEntityManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'authors';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion AuthorEntityManager
// region ExternalEntity
class ExternalEntity {
  ExternalEntity(
      {this.id, this.name, this.mediaId, this.mediaType, this.song_lyricsId}) {
    _setDefaultValues();
  }
  ExternalEntity.withFields(
      this.id, this.name, this.mediaId, this.mediaType, this.song_lyricsId) {
    _setDefaultValues();
  }
  ExternalEntity.withId(
      this.id, this.name, this.mediaId, this.mediaType, this.song_lyricsId) {
    _setDefaultValues();
  }
  ExternalEntity.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['mediaId'] != null) {
      mediaId = o['mediaId'] as String;
    }
    if (o['mediaType'] != null) {
      mediaType = o['mediaType'] as String;
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyricEntity = o['songLyricEntity'] != null
        ? SongLyricEntity.fromMap(o['songLyricEntity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (ExternalEntity)
  int id;
  String name;
  String mediaId;
  String mediaType;
  int song_lyricsId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (ExternalEntity)

// RELATIONSHIPS (ExternalEntity)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntity', 'plField2'..]) or so on..
  SongLyricEntity plSongLyricEntity;

  /// get SongLyricEntity By Song_lyricsId
  Future<SongLyricEntity> getSongLyricEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await SongLyricEntity().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (ExternalEntity)

// COLLECTIONS & VIRTUALS (ExternalEntity)
  ///(RelationType.MANY_TO_MANY) (externalsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plAuthorEntities', 'plField2'..]) or so on..
  List<AuthorEntity> plAuthorEntities;

  /// get AuthorEntity(s) filtered by authorsId IN externalsAuthors
  AuthorEntityFilterBuilder getAuthorEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return AuthorEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT authorsId FROM externalsAuthors WHERE externalsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (ExternalEntity)

  static const bool _softDeleteActivated = false;
  ExternalEntityManager __mnExternalEntity;

  ExternalEntityManager get _mnExternalEntity {
    return __mnExternalEntity = __mnExternalEntity ?? ExternalEntityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (mediaId != null) {
      map['mediaId'] = mediaId;
    }

    if (mediaType != null) {
      map['mediaType'] = mediaType;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (mediaId != null) {
      map['mediaId'] = mediaId;
    }

    if (mediaType != null) {
      map['mediaType'] = mediaType;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

// COLLECTIONS (ExternalEntity)
    if (!forQuery) {
      map['AuthorEntities'] = await getAuthorEntities().toMapList();
    }
// END COLLECTIONS (ExternalEntity)

    return map;
  }

  /// This method returns Json String [ExternalEntity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ExternalEntity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name, mediaId, mediaType, song_lyricsId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, mediaId, mediaType, song_lyricsId];
  }

  static Future<List<ExternalEntity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR ExternalEntity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<ExternalEntity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ExternalEntity>[];
    try {
      objList = list
          .map((externalentity) =>
              ExternalEntity.fromMap(externalentity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR ExternalEntity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ExternalEntity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<ExternalEntity> objList = <ExternalEntity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ExternalEntity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('externals.plAuthorEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthorEntities'))) {
          /*_loadedFields.add('externals.plAuthorEntities'); */
          obj.plAuthorEntities = obj.plAuthorEntities ??
              await obj.getAuthorEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns ExternalEntity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns ExternalEntity if exist, otherwise returns null
  Future<ExternalEntity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    ExternalEntity obj;
    final data = await _mnExternalEntity.getById([id]);
    if (data.length != 0) {
      obj = ExternalEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('externals.plAuthorEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthorEntities'))) {
          /*_loadedFields.add('externals.plAuthorEntities'); */
          obj.plAuthorEntities = obj.plAuthorEntities ??
              await obj.getAuthorEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ExternalEntity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0 || !isSaved) {
      await _mnExternalEntity.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExternalEntity.update(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<ExternalEntity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ExternalEntity> externalentities) async {
    // final results = _mnExternalEntity.saveAll('INSERT OR REPLACE INTO externals (id,name, mediaId, mediaType, song_lyricsId)  VALUES (?,?,?,?,?)',externalentities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in externalentities) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnExternalEntity.rawInsert(
              'INSERT OR REPLACE INTO externals (id,name, mediaId, mediaType, song_lyricsId)  VALUES (?,?,?,?,?)',
              [id, name, mediaId, mediaType, song_lyricsId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ExternalEntity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ExternalEntity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ExternalEntity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<ExternalEntity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<ExternalEntity> externalentities) async {
    final results = await _mnExternalEntity.rawInsertAll(
        'INSERT OR REPLACE INTO externals (id,name, mediaId, mediaType, song_lyricsId)  VALUES (?,?,?,?,?)',
        externalentities);
    return results;
  }

  /// Deletes ExternalEntity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete ExternalEntity invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExternalEntity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnExternalEntity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  ExternalEntityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExternalEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ExternalEntityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExternalEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion externalentity

// region ExternalEntityField
class ExternalEntityField extends SearchCriteria {
  ExternalEntityField(this.externalentityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  ExternalEntityFilterBuilder externalentityFB;

  ExternalEntityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ExternalEntityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    externalentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.EQuals, externalentityFB._addedBlocks)
        : setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.NotEQuals, externalentityFB._addedBlocks);
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }

  ExternalEntityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    externalentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.EQualsOrNull, externalentityFB._addedBlocks)
        : setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, externalentityFB._addedBlocks);
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }

  ExternalEntityFilterBuilder isNull() {
    externalentityFB._addedBlocks = setCriteria(
        0,
        externalentityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        externalentityFB._addedBlocks);
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }

  ExternalEntityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      externalentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          externalentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalentityFB._addedBlocks);
      _waitingNot = '';
      externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
          externalentityFB._addedBlocks.retVal;
    }
    return externalentityFB;
  }

  ExternalEntityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      externalentityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          externalentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalentityFB._addedBlocks);
      _waitingNot = '';
      externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
          externalentityFB._addedBlocks.retVal;
      externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
          externalentityFB._addedBlocks.retVal;
    }
    return externalentityFB;
  }

  ExternalEntityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      externalentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          externalentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalentityFB._addedBlocks);
      _waitingNot = '';
      externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
          externalentityFB._addedBlocks.retVal;
    }
    return externalentityFB;
  }

  ExternalEntityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      externalentityFB._addedBlocks = setCriteria(
          pFirst,
          externalentityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalentityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        externalentityFB._addedBlocks = setCriteria(
            pFirst,
            externalentityFB.parameters,
            param,
            SqlSyntax.LessThan,
            externalentityFB._addedBlocks);
      } else {
        externalentityFB._addedBlocks = setCriteria(
            pFirst,
            externalentityFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            externalentityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        externalentityFB._addedBlocks = setCriteria(
            pLast,
            externalentityFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            externalentityFB._addedBlocks);
      } else {
        externalentityFB._addedBlocks = setCriteria(
            pLast,
            externalentityFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            externalentityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }

  ExternalEntityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    externalentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.GreaterThan, externalentityFB._addedBlocks)
        : setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, externalentityFB._addedBlocks);
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }

  ExternalEntityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    externalentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.LessThan, externalentityFB._addedBlocks)
        : setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, externalentityFB._addedBlocks);
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }

  ExternalEntityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    externalentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, externalentityFB._addedBlocks)
        : setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.LessThan, externalentityFB._addedBlocks);
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }

  ExternalEntityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    externalentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, externalentityFB._addedBlocks)
        : setCriteria(pValue, externalentityFB.parameters, param,
            SqlSyntax.GreaterThan, externalentityFB._addedBlocks);
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }

  ExternalEntityFilterBuilder inValues(dynamic pValue) {
    externalentityFB._addedBlocks = setCriteria(
        pValue,
        externalentityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        externalentityFB._addedBlocks);
    _waitingNot = '';
    externalentityFB._addedBlocks.needEndBlock[externalentityFB._blockIndex] =
        externalentityFB._addedBlocks.retVal;
    return externalentityFB;
  }
}
// endregion ExternalEntityField

// region ExternalEntityFilterBuilder
class ExternalEntityFilterBuilder extends SearchCriteria {
  ExternalEntityFilterBuilder(ExternalEntity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  ExternalEntity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  ExternalEntityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ExternalEntityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ExternalEntityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ExternalEntityFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ExternalEntityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ExternalEntityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ExternalEntityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExternalEntityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExternalEntityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExternalEntityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExternalEntityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ExternalEntityField setField(
      ExternalEntityField field, String colName, DbType dbtype) {
    return ExternalEntityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  ExternalEntityField _id;
  ExternalEntityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  ExternalEntityField _name;
  ExternalEntityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  ExternalEntityField _mediaId;
  ExternalEntityField get mediaId {
    return _mediaId = setField(_mediaId, 'mediaId', DbType.text);
  }

  ExternalEntityField _mediaType;
  ExternalEntityField get mediaType {
    return _mediaType = setField(_mediaType, 'mediaType', DbType.text);
  }

  ExternalEntityField _song_lyricsId;
  ExternalEntityField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (ExternalEntity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<ExternalEntity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (ExternalEntity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnExternalEntity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnExternalEntity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from externals ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnExternalEntity.updateBatch(qparams, values);
  }

  /// This method always returns ExternalEntity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ExternalEntity>
  Future<ExternalEntity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnExternalEntity.toList(qparams);
    final data = await objFuture;
    ExternalEntity obj;
    if (data.isNotEmpty) {
      obj = ExternalEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('externals.plAuthorEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthorEntities'))) {
          /*_loadedFields.add('externals.plAuthorEntities'); */
          obj.plAuthorEntities = obj.plAuthorEntities ??
              await obj.getAuthorEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [ExternalEntity]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) externalentityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final externalentitiesFuture = await _obj._mnExternalEntity.toList(qparams);
    final int count = externalentitiesFuture[0]['CNT'] as int;
    if (externalentityCount != null) {
      externalentityCount(count);
    }
    return count;
  }

  /// This method returns List<ExternalEntity> [ExternalEntity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ExternalEntity>
  Future<List<ExternalEntity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<ExternalEntity> externalentitiesData =
        await ExternalEntity.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return externalentitiesData;
  }

  /// This method returns Json String [ExternalEntity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ExternalEntity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ExternalEntity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnExternalEntity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ExternalEntity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM externals WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnExternalEntity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ExternalEntity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnExternalEntity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await ExternalEntity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnExternalEntity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExternalEntityFilterBuilder

// region ExternalEntityFields
class ExternalEntityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fMediaId;
  static TableField get mediaId {
    return _fMediaId =
        _fMediaId ?? SqlSyntax.setField(_fMediaId, 'mediaId', DbType.text);
  }

  static TableField _fMediaType;
  static TableField get mediaType {
    return _fMediaType = _fMediaType ??
        SqlSyntax.setField(_fMediaType, 'mediaType', DbType.text);
  }

  static TableField _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }
}
// endregion ExternalEntityFields

//region ExternalEntityManager
class ExternalEntityManager extends SqfEntityProvider {
  ExternalEntityManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'externals';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion ExternalEntityManager
// region PlaylistEntity
class PlaylistEntity {
  PlaylistEntity({this.id, this.name, this.isArchived, this.order}) {
    _setDefaultValues();
  }
  PlaylistEntity.withFields(this.id, this.name, this.isArchived, this.order) {
    _setDefaultValues();
  }
  PlaylistEntity.withId(this.id, this.name, this.isArchived, this.order) {
    _setDefaultValues();
  }
  PlaylistEntity.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['isArchived'] != null) {
      isArchived = o['isArchived'] == 1 || o['isArchived'] == true;
    }
    if (o['order'] != null) {
      order = int.tryParse(o['order'].toString());
    }

    isSaved = true;
  }
  // FIELDS (PlaylistEntity)
  int id;
  String name;
  bool isArchived;
  int order;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (PlaylistEntity)

// COLLECTIONS & VIRTUALS (PlaylistEntity)
  ///(RelationType.MANY_TO_MANY) (song_lyricsPlaylists) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntities', 'plField2'..]) or so on..
  List<SongLyricEntity> plSongLyricEntities;

  /// get SongLyricEntity(s) filtered by song_lyricsId IN song_lyricsPlaylists
  SongLyricEntityFilterBuilder getSongLyricEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongLyricEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT song_lyricsId FROM song_lyricsPlaylists WHERE playlistsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (PlaylistEntity)

  static const bool _softDeleteActivated = false;
  PlaylistEntityManager __mnPlaylistEntity;

  PlaylistEntityManager get _mnPlaylistEntity {
    return __mnPlaylistEntity = __mnPlaylistEntity ?? PlaylistEntityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (isArchived != null) {
      map['isArchived'] = forQuery ? (isArchived ? 1 : 0) : isArchived;
    }

    if (order != null) {
      map['order'] = order;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (isArchived != null) {
      map['isArchived'] = forQuery ? (isArchived ? 1 : 0) : isArchived;
    }

    if (order != null) {
      map['order'] = order;
    }

// COLLECTIONS (PlaylistEntity)
    if (!forQuery) {
      map['SongLyricEntities'] = await getSongLyricEntities().toMapList();
    }
// END COLLECTIONS (PlaylistEntity)

    return map;
  }

  /// This method returns Json String [PlaylistEntity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PlaylistEntity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name, isArchived, order];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, isArchived, order];
  }

  static Future<List<PlaylistEntity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR PlaylistEntity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<PlaylistEntity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PlaylistEntity>[];
    try {
      objList = list
          .map((playlistentity) =>
              PlaylistEntity.fromMap(playlistentity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR PlaylistEntity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PlaylistEntity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<PlaylistEntity> objList = <PlaylistEntity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PlaylistEntity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('playlists.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('playlists.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PlaylistEntity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns PlaylistEntity if exist, otherwise returns null
  Future<PlaylistEntity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    PlaylistEntity obj;
    final data = await _mnPlaylistEntity.getById([id]);
    if (data.length != 0) {
      obj = PlaylistEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('playlists.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('playlists.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PlaylistEntity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0 || !isSaved) {
      await _mnPlaylistEntity.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylistEntity.update(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<PlaylistEntity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<PlaylistEntity> playlistentities) async {
    // final results = _mnPlaylistEntity.saveAll('INSERT OR REPLACE INTO playlists (id,name, isArchived, order)  VALUES (?,?,?,?)',playlistentities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in playlistentities) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnPlaylistEntity.rawInsert(
              'INSERT OR REPLACE INTO playlists (id,name, isArchived, order)  VALUES (?,?,?,?)',
              [id, name, isArchived, order]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'PlaylistEntity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PlaylistEntity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PlaylistEntity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<PlaylistEntity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<PlaylistEntity> playlistentities) async {
    final results = await _mnPlaylistEntity.rawInsertAll(
        'INSERT OR REPLACE INTO playlists (id,name, isArchived, order)  VALUES (?,?,?,?)',
        playlistentities);
    return results;
  }

  /// Deletes PlaylistEntity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete PlaylistEntity invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylistEntity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPlaylistEntity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  PlaylistEntityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PlaylistEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  PlaylistEntityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PlaylistEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    isArchived = isArchived ?? false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion playlistentity

// region PlaylistEntityField
class PlaylistEntityField extends SearchCriteria {
  PlaylistEntityField(this.playlistentityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  PlaylistEntityFilterBuilder playlistentityFB;

  PlaylistEntityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  PlaylistEntityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    playlistentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.EQuals, playlistentityFB._addedBlocks)
        : setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.NotEQuals, playlistentityFB._addedBlocks);
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    playlistentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.EQualsOrNull, playlistentityFB._addedBlocks)
        : setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, playlistentityFB._addedBlocks);
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder isNull() {
    playlistentityFB._addedBlocks = setCriteria(
        0,
        playlistentityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlistentityFB._addedBlocks);
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      playlistentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          playlistentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistentityFB._addedBlocks);
      _waitingNot = '';
      playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
          playlistentityFB._addedBlocks.retVal;
    }
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      playlistentityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          playlistentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistentityFB._addedBlocks);
      _waitingNot = '';
      playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
          playlistentityFB._addedBlocks.retVal;
      playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
          playlistentityFB._addedBlocks.retVal;
    }
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      playlistentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          playlistentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistentityFB._addedBlocks);
      _waitingNot = '';
      playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
          playlistentityFB._addedBlocks.retVal;
    }
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      playlistentityFB._addedBlocks = setCriteria(
          pFirst,
          playlistentityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistentityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        playlistentityFB._addedBlocks = setCriteria(
            pFirst,
            playlistentityFB.parameters,
            param,
            SqlSyntax.LessThan,
            playlistentityFB._addedBlocks);
      } else {
        playlistentityFB._addedBlocks = setCriteria(
            pFirst,
            playlistentityFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            playlistentityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        playlistentityFB._addedBlocks = setCriteria(
            pLast,
            playlistentityFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            playlistentityFB._addedBlocks);
      } else {
        playlistentityFB._addedBlocks = setCriteria(
            pLast,
            playlistentityFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            playlistentityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    playlistentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.GreaterThan, playlistentityFB._addedBlocks)
        : setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlistentityFB._addedBlocks);
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    playlistentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.LessThan, playlistentityFB._addedBlocks)
        : setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlistentityFB._addedBlocks);
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    playlistentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlistentityFB._addedBlocks)
        : setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.LessThan, playlistentityFB._addedBlocks);
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    playlistentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlistentityFB._addedBlocks)
        : setCriteria(pValue, playlistentityFB.parameters, param,
            SqlSyntax.GreaterThan, playlistentityFB._addedBlocks);
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }

  PlaylistEntityFilterBuilder inValues(dynamic pValue) {
    playlistentityFB._addedBlocks = setCriteria(
        pValue,
        playlistentityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlistentityFB._addedBlocks);
    _waitingNot = '';
    playlistentityFB._addedBlocks.needEndBlock[playlistentityFB._blockIndex] =
        playlistentityFB._addedBlocks.retVal;
    return playlistentityFB;
  }
}
// endregion PlaylistEntityField

// region PlaylistEntityFilterBuilder
class PlaylistEntityFilterBuilder extends SearchCriteria {
  PlaylistEntityFilterBuilder(PlaylistEntity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  PlaylistEntity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  PlaylistEntityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  PlaylistEntityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  PlaylistEntityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  PlaylistEntityFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  PlaylistEntityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  PlaylistEntityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  PlaylistEntityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistEntityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistEntityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistEntityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistEntityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  PlaylistEntityField setField(
      PlaylistEntityField field, String colName, DbType dbtype) {
    return PlaylistEntityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  PlaylistEntityField _id;
  PlaylistEntityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  PlaylistEntityField _name;
  PlaylistEntityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  PlaylistEntityField _isArchived;
  PlaylistEntityField get isArchived {
    return _isArchived = setField(_isArchived, 'isArchived', DbType.bool);
  }

  PlaylistEntityField _order;
  PlaylistEntityField get order {
    return _order = setField(_order, 'order', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (PlaylistEntity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<PlaylistEntity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (PlaylistEntity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnPlaylistEntity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnPlaylistEntity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from playlists ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnPlaylistEntity.updateBatch(qparams, values);
  }

  /// This method always returns PlaylistEntity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PlaylistEntity>
  Future<PlaylistEntity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnPlaylistEntity.toList(qparams);
    final data = await objFuture;
    PlaylistEntity obj;
    if (data.isNotEmpty) {
      obj = PlaylistEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('playlists.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('playlists.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [PlaylistEntity]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) playlistentityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlistentitiesFuture = await _obj._mnPlaylistEntity.toList(qparams);
    final int count = playlistentitiesFuture[0]['CNT'] as int;
    if (playlistentityCount != null) {
      playlistentityCount(count);
    }
    return count;
  }

  /// This method returns List<PlaylistEntity> [PlaylistEntity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PlaylistEntity>
  Future<List<PlaylistEntity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<PlaylistEntity> playlistentitiesData =
        await PlaylistEntity.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return playlistentitiesData;
  }

  /// This method returns Json String [PlaylistEntity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PlaylistEntity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PlaylistEntity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnPlaylistEntity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PlaylistEntity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM playlists WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnPlaylistEntity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PlaylistEntity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnPlaylistEntity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await PlaylistEntity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnPlaylistEntity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistEntityFilterBuilder

// region PlaylistEntityFields
class PlaylistEntityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fIsArchived;
  static TableField get isArchived {
    return _fIsArchived = _fIsArchived ??
        SqlSyntax.setField(_fIsArchived, 'isArchived', DbType.bool);
  }

  static TableField _fOrder;
  static TableField get order {
    return _fOrder =
        _fOrder ?? SqlSyntax.setField(_fOrder, 'order', DbType.integer);
  }
}
// endregion PlaylistEntityFields

//region PlaylistEntityManager
class PlaylistEntityManager extends SqfEntityProvider {
  PlaylistEntityManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'playlists';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion PlaylistEntityManager
// region SongEntity
class SongEntity {
  SongEntity({this.id, this.name}) {
    _setDefaultValues();
  }
  SongEntity.withFields(this.id, this.name) {
    _setDefaultValues();
  }
  SongEntity.withId(this.id, this.name) {
    _setDefaultValues();
  }
  SongEntity.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }

    isSaved = true;
  }
  // FIELDS (SongEntity)
  int id;
  String name;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (SongEntity)

// COLLECTIONS & VIRTUALS (SongEntity)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntities', 'plField2'..]) or so on..
  List<SongLyricEntity> plSongLyricEntities;

  /// get SongLyricEntity(s) filtered by id=songsId
  SongLyricEntityFilterBuilder getSongLyricEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongLyricEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .songsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (SongEntity)

  static const bool _softDeleteActivated = false;
  SongEntityManager __mnSongEntity;

  SongEntityManager get _mnSongEntity {
    return __mnSongEntity = __mnSongEntity ?? SongEntityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

// COLLECTIONS (SongEntity)
    if (!forQuery) {
      map['SongLyricEntities'] = await getSongLyricEntities().toMapList();
    }
// END COLLECTIONS (SongEntity)

    return map;
  }

  /// This method returns Json String [SongEntity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SongEntity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name];
  }

  static Future<List<SongEntity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR SongEntity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<SongEntity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SongEntity>[];
    try {
      objList = list
          .map((songentity) =>
              SongEntity.fromMap(songentity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR SongEntity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SongEntity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<SongEntity> objList = <SongEntity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SongEntity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songs.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('songs.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SongEntity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns SongEntity if exist, otherwise returns null
  Future<SongEntity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    SongEntity obj;
    final data = await _mnSongEntity.getById([id]);
    if (data.length != 0) {
      obj = SongEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songs.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('songs.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SongEntity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0 || !isSaved) {
      await _mnSongEntity.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongEntity.update(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<SongEntity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<SongEntity> songentities) async {
    // final results = _mnSongEntity.saveAll('INSERT OR REPLACE INTO songs (id,name)  VALUES (?,?)',songentities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in songentities) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnSongEntity.rawInsert(
              'INSERT OR REPLACE INTO songs (id,name)  VALUES (?,?)',
              [id, name]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SongEntity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'SongEntity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SongEntity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<SongEntity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<SongEntity> songentities) async {
    final results = await _mnSongEntity.rawInsertAll(
        'INSERT OR REPLACE INTO songs (id,name)  VALUES (?,?)', songentities);
    return results;
  }

  /// Deletes SongEntity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete SongEntity invoked (id=$id)');
    if (await SongLyricEntity().select().songsId.equals(id).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SongLyricEntity.songsId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongEntity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongEntity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  SongEntityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  SongEntityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion songentity

// region SongEntityField
class SongEntityField extends SearchCriteria {
  SongEntityField(this.songentityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  SongEntityFilterBuilder songentityFB;

  SongEntityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  SongEntityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    songentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songentityFB.parameters, param, SqlSyntax.EQuals,
            songentityFB._addedBlocks)
        : setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.NotEQuals, songentityFB._addedBlocks);
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }

  SongEntityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    songentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.EQualsOrNull, songentityFB._addedBlocks)
        : setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, songentityFB._addedBlocks);
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }

  SongEntityFilterBuilder isNull() {
    songentityFB._addedBlocks = setCriteria(
        0,
        songentityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songentityFB._addedBlocks);
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }

  SongEntityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      songentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          songentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songentityFB._addedBlocks);
      _waitingNot = '';
      songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
          songentityFB._addedBlocks.retVal;
    }
    return songentityFB;
  }

  SongEntityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      songentityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          songentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songentityFB._addedBlocks);
      _waitingNot = '';
      songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
          songentityFB._addedBlocks.retVal;
      songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
          songentityFB._addedBlocks.retVal;
    }
    return songentityFB;
  }

  SongEntityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      songentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          songentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songentityFB._addedBlocks);
      _waitingNot = '';
      songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
          songentityFB._addedBlocks.retVal;
    }
    return songentityFB;
  }

  SongEntityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      songentityFB._addedBlocks = setCriteria(
          pFirst,
          songentityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songentityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        songentityFB._addedBlocks = setCriteria(pFirst, songentityFB.parameters,
            param, SqlSyntax.LessThan, songentityFB._addedBlocks);
      } else {
        songentityFB._addedBlocks = setCriteria(pFirst, songentityFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, songentityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        songentityFB._addedBlocks = setCriteria(pLast, songentityFB.parameters,
            param, SqlSyntax.GreaterThan, songentityFB._addedBlocks);
      } else {
        songentityFB._addedBlocks = setCriteria(pLast, songentityFB.parameters,
            param, SqlSyntax.LessThanOrEquals, songentityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }

  SongEntityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    songentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.GreaterThan, songentityFB._addedBlocks)
        : setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songentityFB._addedBlocks);
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }

  SongEntityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    songentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.LessThan, songentityFB._addedBlocks)
        : setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songentityFB._addedBlocks);
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }

  SongEntityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    songentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songentityFB._addedBlocks)
        : setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.LessThan, songentityFB._addedBlocks);
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }

  SongEntityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    songentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songentityFB._addedBlocks)
        : setCriteria(pValue, songentityFB.parameters, param,
            SqlSyntax.GreaterThan, songentityFB._addedBlocks);
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }

  SongEntityFilterBuilder inValues(dynamic pValue) {
    songentityFB._addedBlocks = setCriteria(
        pValue,
        songentityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songentityFB._addedBlocks);
    _waitingNot = '';
    songentityFB._addedBlocks.needEndBlock[songentityFB._blockIndex] =
        songentityFB._addedBlocks.retVal;
    return songentityFB;
  }
}
// endregion SongEntityField

// region SongEntityFilterBuilder
class SongEntityFilterBuilder extends SearchCriteria {
  SongEntityFilterBuilder(SongEntity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  SongEntity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  SongEntityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  SongEntityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  SongEntityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  SongEntityFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  SongEntityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  SongEntityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  SongEntityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongEntityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongEntityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongEntityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongEntityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  SongEntityField setField(
      SongEntityField field, String colName, DbType dbtype) {
    return SongEntityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  SongEntityField _id;
  SongEntityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  SongEntityField _name;
  SongEntityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (SongEntity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<SongEntity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (SongLyricEntity) according to DeleteRule.NO_ACTION

    final idListSongLyricEntityBYsongsId = toListPrimaryKeySQL(false);
    final resSongLyricEntityBYsongsId = await SongLyricEntity()
        .select()
        .where('songsId IN (${idListSongLyricEntityBYsongsId['sql']})',
            parameterValue: idListSongLyricEntityBYsongsId['args'])
        .toCount();
    if (resSongLyricEntityBYsongsId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SongLyricEntity.songsId)');
    }

    if (SongEntity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnSongEntity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnSongEntity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from songs ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnSongEntity.updateBatch(qparams, values);
  }

  /// This method always returns SongEntity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongEntity>
  Future<SongEntity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnSongEntity.toList(qparams);
    final data = await objFuture;
    SongEntity obj;
    if (data.isNotEmpty) {
      obj = SongEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songs.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('songs.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [SongEntity]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) songentityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songentitiesFuture = await _obj._mnSongEntity.toList(qparams);
    final int count = songentitiesFuture[0]['CNT'] as int;
    if (songentityCount != null) {
      songentityCount(count);
    }
    return count;
  }

  /// This method returns List<SongEntity> [SongEntity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongEntity>
  Future<List<SongEntity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<SongEntity> songentitiesData = await SongEntity.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return songentitiesData;
  }

  /// This method returns Json String [SongEntity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SongEntity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SongEntity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnSongEntity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SongEntity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM songs WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnSongEntity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SongEntity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnSongEntity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await SongEntity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnSongEntity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongEntityFilterBuilder

// region SongEntityFields
class SongEntityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }
}
// endregion SongEntityFields

//region SongEntityManager
class SongEntityManager extends SqfEntityProvider {
  SongEntityManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'songs';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion SongEntityManager
// region SongbookEntity
class SongbookEntity {
  SongbookEntity(
      {this.id,
      this.name,
      this.shortcut,
      this.color,
      this.colorText,
      this.isPrivate,
      this.isPinned}) {
    _setDefaultValues();
  }
  SongbookEntity.withFields(this.id, this.name, this.shortcut, this.color,
      this.colorText, this.isPrivate, this.isPinned) {
    _setDefaultValues();
  }
  SongbookEntity.withId(this.id, this.name, this.shortcut, this.color,
      this.colorText, this.isPrivate, this.isPinned) {
    _setDefaultValues();
  }
  SongbookEntity.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['shortcut'] != null) {
      shortcut = o['shortcut'] as String;
    }
    if (o['color'] != null) {
      color = o['color'] as String;
    }
    if (o['colorText'] != null) {
      colorText = o['colorText'] as String;
    }
    if (o['isPrivate'] != null) {
      isPrivate = o['isPrivate'] == 1 || o['isPrivate'] == true;
    }
    if (o['isPinned'] != null) {
      isPinned = o['isPinned'] == 1 || o['isPinned'] == true;
    }

    isSaved = true;
  }
  // FIELDS (SongbookEntity)
  int id;
  String name;
  String shortcut;
  String color;
  String colorText;
  bool isPrivate;
  bool isPinned;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (SongbookEntity)

// COLLECTIONS & VIRTUALS (SongbookEntity)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongbookRecordEntities', 'plField2'..]) or so on..
  List<SongbookRecordEntity> plSongbookRecordEntities;

  /// get SongbookRecordEntity(s) filtered by id=songbooksId
  SongbookRecordEntityFilterBuilder getSongbookRecordEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongbookRecordEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .songbooksId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (SongbookEntity)

  static const bool _softDeleteActivated = false;
  SongbookEntityManager __mnSongbookEntity;

  SongbookEntityManager get _mnSongbookEntity {
    return __mnSongbookEntity = __mnSongbookEntity ?? SongbookEntityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (shortcut != null) {
      map['shortcut'] = shortcut;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (colorText != null) {
      map['colorText'] = colorText;
    }

    if (isPrivate != null) {
      map['isPrivate'] = forQuery ? (isPrivate ? 1 : 0) : isPrivate;
    }

    if (isPinned != null) {
      map['isPinned'] = forQuery ? (isPinned ? 1 : 0) : isPinned;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (shortcut != null) {
      map['shortcut'] = shortcut;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (colorText != null) {
      map['colorText'] = colorText;
    }

    if (isPrivate != null) {
      map['isPrivate'] = forQuery ? (isPrivate ? 1 : 0) : isPrivate;
    }

    if (isPinned != null) {
      map['isPinned'] = forQuery ? (isPinned ? 1 : 0) : isPinned;
    }

// COLLECTIONS (SongbookEntity)
    if (!forQuery) {
      map['SongbookRecordEntities'] =
          await getSongbookRecordEntities().toMapList();
    }
// END COLLECTIONS (SongbookEntity)

    return map;
  }

  /// This method returns Json String [SongbookEntity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SongbookEntity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name, shortcut, color, colorText, isPrivate, isPinned];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, shortcut, color, colorText, isPrivate, isPinned];
  }

  static Future<List<SongbookEntity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR SongbookEntity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<SongbookEntity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SongbookEntity>[];
    try {
      objList = list
          .map((songbookentity) =>
              SongbookEntity.fromMap(songbookentity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR SongbookEntity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SongbookEntity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<SongbookEntity> objList = <SongbookEntity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SongbookEntity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songbooks.plSongbookRecordEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecordEntities'))) {
          /*_loadedFields.add('songbooks.plSongbookRecordEntities'); */
          obj.plSongbookRecordEntities = obj.plSongbookRecordEntities ??
              await obj.getSongbookRecordEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SongbookEntity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns SongbookEntity if exist, otherwise returns null
  Future<SongbookEntity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    SongbookEntity obj;
    final data = await _mnSongbookEntity.getById([id]);
    if (data.length != 0) {
      obj = SongbookEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songbooks.plSongbookRecordEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecordEntities'))) {
          /*_loadedFields.add('songbooks.plSongbookRecordEntities'); */
          obj.plSongbookRecordEntities = obj.plSongbookRecordEntities ??
              await obj.getSongbookRecordEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SongbookEntity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0 || !isSaved) {
      await _mnSongbookEntity.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongbookEntity.update(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<SongbookEntity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SongbookEntity> songbookentities) async {
    // final results = _mnSongbookEntity.saveAll('INSERT OR REPLACE INTO songbooks (id,name, shortcut, color, colorText, isPrivate, isPinned)  VALUES (?,?,?,?,?,?,?)',songbookentities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in songbookentities) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnSongbookEntity.rawInsert(
              'INSERT OR REPLACE INTO songbooks (id,name, shortcut, color, colorText, isPrivate, isPinned)  VALUES (?,?,?,?,?,?,?)',
              [id, name, shortcut, color, colorText, isPrivate, isPinned]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SongbookEntity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SongbookEntity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SongbookEntity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<SongbookEntity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<SongbookEntity> songbookentities) async {
    final results = await _mnSongbookEntity.rawInsertAll(
        'INSERT OR REPLACE INTO songbooks (id,name, shortcut, color, colorText, isPrivate, isPinned)  VALUES (?,?,?,?,?,?,?)',
        songbookentities);
    return results;
  }

  /// Deletes SongbookEntity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete SongbookEntity invoked (id=$id)');
    if (await SongbookRecordEntity()
            .select()
            .songbooksId
            .equals(id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SongbookRecordEntity.songbooksId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongbookEntity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongbookEntity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  SongbookEntityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongbookEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  SongbookEntityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongbookEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    isPinned = isPinned ?? false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion songbookentity

// region SongbookEntityField
class SongbookEntityField extends SearchCriteria {
  SongbookEntityField(this.songbookentityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  SongbookEntityFilterBuilder songbookentityFB;

  SongbookEntityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  SongbookEntityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    songbookentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.EQuals, songbookentityFB._addedBlocks)
        : setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.NotEQuals, songbookentityFB._addedBlocks);
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    songbookentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.EQualsOrNull, songbookentityFB._addedBlocks)
        : setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, songbookentityFB._addedBlocks);
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder isNull() {
    songbookentityFB._addedBlocks = setCriteria(
        0,
        songbookentityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songbookentityFB._addedBlocks);
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      songbookentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          songbookentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookentityFB._addedBlocks);
      _waitingNot = '';
      songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
          songbookentityFB._addedBlocks.retVal;
    }
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      songbookentityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          songbookentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookentityFB._addedBlocks);
      _waitingNot = '';
      songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
          songbookentityFB._addedBlocks.retVal;
      songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
          songbookentityFB._addedBlocks.retVal;
    }
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      songbookentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          songbookentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookentityFB._addedBlocks);
      _waitingNot = '';
      songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
          songbookentityFB._addedBlocks.retVal;
    }
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      songbookentityFB._addedBlocks = setCriteria(
          pFirst,
          songbookentityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookentityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        songbookentityFB._addedBlocks = setCriteria(
            pFirst,
            songbookentityFB.parameters,
            param,
            SqlSyntax.LessThan,
            songbookentityFB._addedBlocks);
      } else {
        songbookentityFB._addedBlocks = setCriteria(
            pFirst,
            songbookentityFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            songbookentityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        songbookentityFB._addedBlocks = setCriteria(
            pLast,
            songbookentityFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            songbookentityFB._addedBlocks);
      } else {
        songbookentityFB._addedBlocks = setCriteria(
            pLast,
            songbookentityFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            songbookentityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    songbookentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.GreaterThan, songbookentityFB._addedBlocks)
        : setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songbookentityFB._addedBlocks);
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    songbookentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.LessThan, songbookentityFB._addedBlocks)
        : setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songbookentityFB._addedBlocks);
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    songbookentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songbookentityFB._addedBlocks)
        : setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.LessThan, songbookentityFB._addedBlocks);
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    songbookentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songbookentityFB._addedBlocks)
        : setCriteria(pValue, songbookentityFB.parameters, param,
            SqlSyntax.GreaterThan, songbookentityFB._addedBlocks);
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }

  SongbookEntityFilterBuilder inValues(dynamic pValue) {
    songbookentityFB._addedBlocks = setCriteria(
        pValue,
        songbookentityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songbookentityFB._addedBlocks);
    _waitingNot = '';
    songbookentityFB._addedBlocks.needEndBlock[songbookentityFB._blockIndex] =
        songbookentityFB._addedBlocks.retVal;
    return songbookentityFB;
  }
}
// endregion SongbookEntityField

// region SongbookEntityFilterBuilder
class SongbookEntityFilterBuilder extends SearchCriteria {
  SongbookEntityFilterBuilder(SongbookEntity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  SongbookEntity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  SongbookEntityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  SongbookEntityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  SongbookEntityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  SongbookEntityFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  SongbookEntityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  SongbookEntityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  SongbookEntityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongbookEntityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongbookEntityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongbookEntityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongbookEntityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  SongbookEntityField setField(
      SongbookEntityField field, String colName, DbType dbtype) {
    return SongbookEntityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  SongbookEntityField _id;
  SongbookEntityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  SongbookEntityField _name;
  SongbookEntityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  SongbookEntityField _shortcut;
  SongbookEntityField get shortcut {
    return _shortcut = setField(_shortcut, 'shortcut', DbType.text);
  }

  SongbookEntityField _color;
  SongbookEntityField get color {
    return _color = setField(_color, 'color', DbType.text);
  }

  SongbookEntityField _colorText;
  SongbookEntityField get colorText {
    return _colorText = setField(_colorText, 'colorText', DbType.text);
  }

  SongbookEntityField _isPrivate;
  SongbookEntityField get isPrivate {
    return _isPrivate = setField(_isPrivate, 'isPrivate', DbType.bool);
  }

  SongbookEntityField _isPinned;
  SongbookEntityField get isPinned {
    return _isPinned = setField(_isPinned, 'isPinned', DbType.bool);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (SongbookEntity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<SongbookEntity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (SongbookRecordEntity) according to DeleteRule.NO_ACTION

    final idListSongbookRecordEntityBYsongbooksId = toListPrimaryKeySQL(false);
    final resSongbookRecordEntityBYsongbooksId = await SongbookRecordEntity()
        .select()
        .where(
            'songbooksId IN (${idListSongbookRecordEntityBYsongbooksId['sql']})',
            parameterValue: idListSongbookRecordEntityBYsongbooksId['args'])
        .toCount();
    if (resSongbookRecordEntityBYsongbooksId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SongbookRecordEntity.songbooksId)');
    }

    if (SongbookEntity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnSongbookEntity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnSongbookEntity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from songbooks ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnSongbookEntity.updateBatch(qparams, values);
  }

  /// This method always returns SongbookEntity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongbookEntity>
  Future<SongbookEntity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnSongbookEntity.toList(qparams);
    final data = await objFuture;
    SongbookEntity obj;
    if (data.isNotEmpty) {
      obj = SongbookEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songbooks.plSongbookRecordEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecordEntities'))) {
          /*_loadedFields.add('songbooks.plSongbookRecordEntities'); */
          obj.plSongbookRecordEntities = obj.plSongbookRecordEntities ??
              await obj.getSongbookRecordEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [SongbookEntity]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) songbookentityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songbookentitiesFuture = await _obj._mnSongbookEntity.toList(qparams);
    final int count = songbookentitiesFuture[0]['CNT'] as int;
    if (songbookentityCount != null) {
      songbookentityCount(count);
    }
    return count;
  }

  /// This method returns List<SongbookEntity> [SongbookEntity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongbookEntity>
  Future<List<SongbookEntity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<SongbookEntity> songbookentitiesData =
        await SongbookEntity.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return songbookentitiesData;
  }

  /// This method returns Json String [SongbookEntity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SongbookEntity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SongbookEntity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnSongbookEntity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SongbookEntity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM songbooks WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnSongbookEntity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SongbookEntity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnSongbookEntity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await SongbookEntity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnSongbookEntity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongbookEntityFilterBuilder

// region SongbookEntityFields
class SongbookEntityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fShortcut;
  static TableField get shortcut {
    return _fShortcut =
        _fShortcut ?? SqlSyntax.setField(_fShortcut, 'shortcut', DbType.text);
  }

  static TableField _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.text);
  }

  static TableField _fColorText;
  static TableField get colorText {
    return _fColorText = _fColorText ??
        SqlSyntax.setField(_fColorText, 'colorText', DbType.text);
  }

  static TableField _fIsPrivate;
  static TableField get isPrivate {
    return _fIsPrivate = _fIsPrivate ??
        SqlSyntax.setField(_fIsPrivate, 'isPrivate', DbType.bool);
  }

  static TableField _fIsPinned;
  static TableField get isPinned {
    return _fIsPinned =
        _fIsPinned ?? SqlSyntax.setField(_fIsPinned, 'isPinned', DbType.bool);
  }
}
// endregion SongbookEntityFields

//region SongbookEntityManager
class SongbookEntityManager extends SqfEntityProvider {
  SongbookEntityManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'songbooks';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion SongbookEntityManager
// region SongbookRecordEntity
class SongbookRecordEntity {
  SongbookRecordEntity(
      {this.id, this.number, this.songbooksId, this.song_lyricsId}) {
    _setDefaultValues();
  }
  SongbookRecordEntity.withFields(
      this.id, this.number, this.songbooksId, this.song_lyricsId) {
    _setDefaultValues();
  }
  SongbookRecordEntity.withId(
      this.id, this.number, this.songbooksId, this.song_lyricsId) {
    _setDefaultValues();
  }
  SongbookRecordEntity.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['number'] != null) {
      number = o['number'] as String;
    }
    songbooksId = int.tryParse(o['songbooksId'].toString());

    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongbookEntity = o['songbookEntity'] != null
        ? SongbookEntity.fromMap(o['songbookEntity'] as Map<String, dynamic>)
        : null;
    plSongLyricEntity = o['songLyricEntity'] != null
        ? SongLyricEntity.fromMap(o['songLyricEntity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (SongbookRecordEntity)
  int id;
  String number;
  int songbooksId;
  int song_lyricsId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (SongbookRecordEntity)

// RELATIONSHIPS (SongbookRecordEntity)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongbookEntity', 'plField2'..]) or so on..
  SongbookEntity plSongbookEntity;

  /// get SongbookEntity By SongbooksId
  Future<SongbookEntity> getSongbookEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await SongbookEntity().getById(songbooksId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntity', 'plField2'..]) or so on..
  SongLyricEntity plSongLyricEntity;

  /// get SongLyricEntity By Song_lyricsId
  Future<SongLyricEntity> getSongLyricEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await SongLyricEntity().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (SongbookRecordEntity)

  static const bool _softDeleteActivated = false;
  SongbookRecordEntityManager __mnSongbookRecordEntity;

  SongbookRecordEntityManager get _mnSongbookRecordEntity {
    return __mnSongbookRecordEntity =
        __mnSongbookRecordEntity ?? SongbookRecordEntityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (number != null) {
      map['number'] = number;
    }

    if (songbooksId != null) {
      map['songbooksId'] = forView ? plSongbookEntity.name : songbooksId;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (number != null) {
      map['number'] = number;
    }

    if (songbooksId != null) {
      map['songbooksId'] = forView ? plSongbookEntity.name : songbooksId;
    }

    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    return map;
  }

  /// This method returns Json String [SongbookRecordEntity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SongbookRecordEntity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, number, songbooksId, song_lyricsId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, number, songbooksId, song_lyricsId];
  }

  static Future<List<SongbookRecordEntity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR SongbookRecordEntity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<SongbookRecordEntity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SongbookRecordEntity>[];
    try {
      objList = list
          .map((songbookrecordentity) => SongbookRecordEntity.fromMap(
              songbookrecordentity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR SongbookRecordEntity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SongbookRecordEntity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<SongbookRecordEntity> objList = <SongbookRecordEntity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SongbookRecordEntity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songbooks.plSongbookEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongbookEntity'))) {
          /*_loadedFields.add('songbooks.plSongbookEntity');*/
          obj.plSongbookEntity = obj.plSongbookEntity ??
              await obj.getSongbookEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SongbookRecordEntity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns SongbookRecordEntity if exist, otherwise returns null
  Future<SongbookRecordEntity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    SongbookRecordEntity obj;
    final data = await _mnSongbookRecordEntity.getById([id]);
    if (data.length != 0) {
      obj = SongbookRecordEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songbooks.plSongbookEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongbookEntity'))) {
          /*_loadedFields.add('songbooks.plSongbookEntity');*/
          obj.plSongbookEntity = obj.plSongbookEntity ??
              await obj.getSongbookEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SongbookRecordEntity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0 || !isSaved) {
      await _mnSongbookRecordEntity.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongbookRecordEntity.update(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<SongbookRecordEntity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SongbookRecordEntity> songbookrecordentities) async {
    // final results = _mnSongbookRecordEntity.saveAll('INSERT OR REPLACE INTO songbook_records (id,number, songbooksId, song_lyricsId)  VALUES (?,?,?,?)',songbookrecordentities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in songbookrecordentities) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnSongbookRecordEntity.rawInsert(
              'INSERT OR REPLACE INTO songbook_records (id,number, songbooksId, song_lyricsId)  VALUES (?,?,?,?)',
              [id, number, songbooksId, song_lyricsId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SongbookRecordEntity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SongbookRecordEntity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SongbookRecordEntity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<SongbookRecordEntity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<SongbookRecordEntity> songbookrecordentities) async {
    final results = await _mnSongbookRecordEntity.rawInsertAll(
        'INSERT OR REPLACE INTO songbook_records (id,number, songbooksId, song_lyricsId)  VALUES (?,?,?,?)',
        songbookrecordentities);
    return results;
  }

  /// Deletes SongbookRecordEntity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete SongbookRecordEntity invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongbookRecordEntity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongbookRecordEntity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  SongbookRecordEntityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongbookRecordEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  SongbookRecordEntityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongbookRecordEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion songbookrecordentity

// region SongbookRecordEntityField
class SongbookRecordEntityField extends SearchCriteria {
  SongbookRecordEntityField(this.songbookrecordentityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  SongbookRecordEntityFilterBuilder songbookrecordentityFB;

  SongbookRecordEntityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  SongbookRecordEntityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    songbookrecordentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.EQuals, songbookrecordentityFB._addedBlocks)
        : setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.NotEQuals, songbookrecordentityFB._addedBlocks);
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    songbookrecordentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.EQualsOrNull, songbookrecordentityFB._addedBlocks)
        : setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, songbookrecordentityFB._addedBlocks);
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder isNull() {
    songbookrecordentityFB._addedBlocks = setCriteria(
        0,
        songbookrecordentityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songbookrecordentityFB._addedBlocks);
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      songbookrecordentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          songbookrecordentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookrecordentityFB._addedBlocks);
      _waitingNot = '';
      songbookrecordentityFB
              ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
          songbookrecordentityFB._addedBlocks.retVal;
    }
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      songbookrecordentityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          songbookrecordentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookrecordentityFB._addedBlocks);
      _waitingNot = '';
      songbookrecordentityFB
              ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
          songbookrecordentityFB._addedBlocks.retVal;
      songbookrecordentityFB
              ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
          songbookrecordentityFB._addedBlocks.retVal;
    }
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      songbookrecordentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          songbookrecordentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookrecordentityFB._addedBlocks);
      _waitingNot = '';
      songbookrecordentityFB
              ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
          songbookrecordentityFB._addedBlocks.retVal;
    }
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      songbookrecordentityFB._addedBlocks = setCriteria(
          pFirst,
          songbookrecordentityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songbookrecordentityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        songbookrecordentityFB._addedBlocks = setCriteria(
            pFirst,
            songbookrecordentityFB.parameters,
            param,
            SqlSyntax.LessThan,
            songbookrecordentityFB._addedBlocks);
      } else {
        songbookrecordentityFB._addedBlocks = setCriteria(
            pFirst,
            songbookrecordentityFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            songbookrecordentityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        songbookrecordentityFB._addedBlocks = setCriteria(
            pLast,
            songbookrecordentityFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            songbookrecordentityFB._addedBlocks);
      } else {
        songbookrecordentityFB._addedBlocks = setCriteria(
            pLast,
            songbookrecordentityFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            songbookrecordentityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    songbookrecordentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.GreaterThan, songbookrecordentityFB._addedBlocks)
        : setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songbookrecordentityFB._addedBlocks);
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    songbookrecordentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.LessThan, songbookrecordentityFB._addedBlocks)
        : setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songbookrecordentityFB._addedBlocks);
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    songbookrecordentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songbookrecordentityFB._addedBlocks)
        : setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.LessThan, songbookrecordentityFB._addedBlocks);
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    songbookrecordentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songbookrecordentityFB._addedBlocks)
        : setCriteria(pValue, songbookrecordentityFB.parameters, param,
            SqlSyntax.GreaterThan, songbookrecordentityFB._addedBlocks);
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }

  SongbookRecordEntityFilterBuilder inValues(dynamic pValue) {
    songbookrecordentityFB._addedBlocks = setCriteria(
        pValue,
        songbookrecordentityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songbookrecordentityFB._addedBlocks);
    _waitingNot = '';
    songbookrecordentityFB
            ._addedBlocks.needEndBlock[songbookrecordentityFB._blockIndex] =
        songbookrecordentityFB._addedBlocks.retVal;
    return songbookrecordentityFB;
  }
}
// endregion SongbookRecordEntityField

// region SongbookRecordEntityFilterBuilder
class SongbookRecordEntityFilterBuilder extends SearchCriteria {
  SongbookRecordEntityFilterBuilder(SongbookRecordEntity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  SongbookRecordEntity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  SongbookRecordEntityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  SongbookRecordEntityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  SongbookRecordEntityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  SongbookRecordEntityFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  SongbookRecordEntityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  SongbookRecordEntityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  SongbookRecordEntityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongbookRecordEntityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongbookRecordEntityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongbookRecordEntityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongbookRecordEntityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  SongbookRecordEntityField setField(
      SongbookRecordEntityField field, String colName, DbType dbtype) {
    return SongbookRecordEntityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  SongbookRecordEntityField _id;
  SongbookRecordEntityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  SongbookRecordEntityField _number;
  SongbookRecordEntityField get number {
    return _number = setField(_number, 'number', DbType.text);
  }

  SongbookRecordEntityField _songbooksId;
  SongbookRecordEntityField get songbooksId {
    return _songbooksId = setField(_songbooksId, 'songbooksId', DbType.integer);
  }

  SongbookRecordEntityField _song_lyricsId;
  SongbookRecordEntityField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (SongbookRecordEntity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<SongbookRecordEntity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (SongbookRecordEntity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnSongbookRecordEntity
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnSongbookRecordEntity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from songbook_records ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnSongbookRecordEntity.updateBatch(qparams, values);
  }

  /// This method always returns SongbookRecordEntity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongbookRecordEntity>
  Future<SongbookRecordEntity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnSongbookRecordEntity.toList(qparams);
    final data = await objFuture;
    SongbookRecordEntity obj;
    if (data.isNotEmpty) {
      obj = SongbookRecordEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songbooks.plSongbookEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongbookEntity'))) {
          /*_loadedFields.add('songbooks.plSongbookEntity');*/
          obj.plSongbookEntity = obj.plSongbookEntity ??
              await obj.getSongbookEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [SongbookRecordEntity]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) songbookrecordentityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songbookrecordentitiesFuture =
        await _obj._mnSongbookRecordEntity.toList(qparams);
    final int count = songbookrecordentitiesFuture[0]['CNT'] as int;
    if (songbookrecordentityCount != null) {
      songbookrecordentityCount(count);
    }
    return count;
  }

  /// This method returns List<SongbookRecordEntity> [SongbookRecordEntity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongbookRecordEntity>
  Future<List<SongbookRecordEntity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<SongbookRecordEntity> songbookrecordentitiesData =
        await SongbookRecordEntity.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return songbookrecordentitiesData;
  }

  /// This method returns Json String [SongbookRecordEntity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SongbookRecordEntity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SongbookRecordEntity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnSongbookRecordEntity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SongbookRecordEntity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM songbook_records WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnSongbookRecordEntity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SongbookRecordEntity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnSongbookRecordEntity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await SongbookRecordEntity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnSongbookRecordEntity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongbookRecordEntityFilterBuilder

// region SongbookRecordEntityFields
class SongbookRecordEntityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fNumber;
  static TableField get number {
    return _fNumber =
        _fNumber ?? SqlSyntax.setField(_fNumber, 'number', DbType.text);
  }

  static TableField _fSongbooksId;
  static TableField get songbooksId {
    return _fSongbooksId = _fSongbooksId ??
        SqlSyntax.setField(_fSongbooksId, 'songbooksId', DbType.integer);
  }

  static TableField _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }
}
// endregion SongbookRecordEntityFields

//region SongbookRecordEntityManager
class SongbookRecordEntityManager extends SqfEntityProvider {
  SongbookRecordEntityManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'songbook_records';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion SongbookRecordEntityManager
// region SongLyricEntity
class SongLyricEntity {
  SongLyricEntity(
      {this.id,
      this.name,
      this.secondaryName1,
      this.secondaryName2,
      this.lyrics,
      this.language,
      this.type,
      this.lilypond,
      this.favoriteOrder,
      this.transposition,
      this.showChords,
      this.accidentals,
      this.songsId}) {
    _setDefaultValues();
  }
  SongLyricEntity.withFields(
      this.id,
      this.name,
      this.secondaryName1,
      this.secondaryName2,
      this.lyrics,
      this.language,
      this.type,
      this.lilypond,
      this.favoriteOrder,
      this.transposition,
      this.showChords,
      this.accidentals,
      this.songsId) {
    _setDefaultValues();
  }
  SongLyricEntity.withId(
      this.id,
      this.name,
      this.secondaryName1,
      this.secondaryName2,
      this.lyrics,
      this.language,
      this.type,
      this.lilypond,
      this.favoriteOrder,
      this.transposition,
      this.showChords,
      this.accidentals,
      this.songsId) {
    _setDefaultValues();
  }
  SongLyricEntity.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['secondaryName1'] != null) {
      secondaryName1 = o['secondaryName1'] as String;
    }
    if (o['secondaryName2'] != null) {
      secondaryName2 = o['secondaryName2'] as String;
    }
    if (o['lyrics'] != null) {
      lyrics = o['lyrics'] as String;
    }
    if (o['language'] != null) {
      language = o['language'] as String;
    }
    if (o['type'] != null) {
      type = int.tryParse(o['type'].toString());
    }
    if (o['lilypond'] != null) {
      lilypond = o['lilypond'] as String;
    }
    if (o['favoriteOrder'] != null) {
      favoriteOrder = int.tryParse(o['favoriteOrder'].toString());
    }
    if (o['transposition'] != null) {
      transposition = int.tryParse(o['transposition'].toString());
    }
    if (o['showChords'] != null) {
      showChords = o['showChords'] == 1 || o['showChords'] == true;
    }
    if (o['accidentals'] != null) {
      accidentals = int.tryParse(o['accidentals'].toString());
    }
    songsId = int.tryParse(o['songsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongEntity = o['songEntity'] != null
        ? SongEntity.fromMap(o['songEntity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (SongLyricEntity)
  int id;
  String name;
  String secondaryName1;
  String secondaryName2;
  String lyrics;
  String language;
  int type;
  String lilypond;
  int favoriteOrder;
  int transposition;
  bool showChords;
  int accidentals;
  int songsId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (SongLyricEntity)

// RELATIONSHIPS (SongLyricEntity)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongEntity', 'plField2'..]) or so on..
  SongEntity plSongEntity;

  /// get SongEntity By SongsId
  Future<SongEntity> getSongEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await SongEntity()
        .getById(songsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (SongLyricEntity)

// COLLECTIONS & VIRTUALS (SongLyricEntity)
  ///(RelationType.MANY_TO_MANY) (song_lyricsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plAuthorEntities', 'plField2'..]) or so on..
  List<AuthorEntity> plAuthorEntities;

  /// get AuthorEntity(s) filtered by authorsId IN song_lyricsAuthors
  AuthorEntityFilterBuilder getAuthorEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return AuthorEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT authorsId FROM song_lyricsAuthors WHERE song_lyricsId=?)',
            parameterValue: id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExternalEntities', 'plField2'..]) or so on..
  List<ExternalEntity> plExternalEntities;

  /// get ExternalEntity(s) filtered by id=song_lyricsId
  ExternalEntityFilterBuilder getExternalEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return ExternalEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .song_lyricsId
        .equals(id)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (song_lyricsPlaylists) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plPlaylistEntities', 'plField2'..]) or so on..
  List<PlaylistEntity> plPlaylistEntities;

  /// get PlaylistEntity(s) filtered by playlistsId IN song_lyricsPlaylists
  PlaylistEntityFilterBuilder getPlaylistEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PlaylistEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT playlistsId FROM song_lyricsPlaylists WHERE song_lyricsId=?)',
            parameterValue: id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongbookRecordEntities', 'plField2'..]) or so on..
  List<SongbookRecordEntity> plSongbookRecordEntities;

  /// get SongbookRecordEntity(s) filtered by id=song_lyricsId
  SongbookRecordEntityFilterBuilder getSongbookRecordEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongbookRecordEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .song_lyricsId
        .equals(id)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (song_lyricsTags) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTagEntities', 'plField2'..]) or so on..
  List<TagEntity> plTagEntities;

  /// get TagEntity(s) filtered by tagsId IN song_lyricsTags
  TagEntityFilterBuilder getTagEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return TagEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT tagsId FROM song_lyricsTags WHERE song_lyricsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (SongLyricEntity)

  static const bool _softDeleteActivated = false;
  SongLyricEntityManager __mnSongLyricEntity;

  SongLyricEntityManager get _mnSongLyricEntity {
    return __mnSongLyricEntity =
        __mnSongLyricEntity ?? SongLyricEntityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (secondaryName1 != null) {
      map['secondaryName1'] = secondaryName1;
    }

    if (secondaryName2 != null) {
      map['secondaryName2'] = secondaryName2;
    }

    if (lyrics != null) {
      map['lyrics'] = lyrics;
    }

    if (language != null) {
      map['language'] = language;
    }

    if (type != null) {
      map['type'] = type;
    }

    if (lilypond != null) {
      map['lilypond'] = lilypond;
    }

    if (favoriteOrder != null) {
      map['favoriteOrder'] = favoriteOrder;
    }

    if (transposition != null) {
      map['transposition'] = transposition;
    }

    if (showChords != null) {
      map['showChords'] = forQuery ? (showChords ? 1 : 0) : showChords;
    }

    if (accidentals != null) {
      map['accidentals'] = accidentals;
    }

    if (songsId != null) {
      map['songsId'] = forView ? plSongEntity.name : songsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (secondaryName1 != null) {
      map['secondaryName1'] = secondaryName1;
    }

    if (secondaryName2 != null) {
      map['secondaryName2'] = secondaryName2;
    }

    if (lyrics != null) {
      map['lyrics'] = lyrics;
    }

    if (language != null) {
      map['language'] = language;
    }

    if (type != null) {
      map['type'] = type;
    }

    if (lilypond != null) {
      map['lilypond'] = lilypond;
    }

    if (favoriteOrder != null) {
      map['favoriteOrder'] = favoriteOrder;
    }

    if (transposition != null) {
      map['transposition'] = transposition;
    }

    if (showChords != null) {
      map['showChords'] = forQuery ? (showChords ? 1 : 0) : showChords;
    }

    if (accidentals != null) {
      map['accidentals'] = accidentals;
    }

    if (songsId != null) {
      map['songsId'] = forView ? plSongEntity.name : songsId;
    }

// COLLECTIONS (SongLyricEntity)
    if (!forQuery) {
      map['AuthorEntities'] = await getAuthorEntities().toMapList();
    }
    if (!forQuery) {
      map['ExternalEntities'] = await getExternalEntities().toMapList();
    }
    if (!forQuery) {
      map['PlaylistEntities'] = await getPlaylistEntities().toMapList();
    }
    if (!forQuery) {
      map['SongbookRecordEntities'] =
          await getSongbookRecordEntities().toMapList();
    }
    if (!forQuery) {
      map['TagEntities'] = await getTagEntities().toMapList();
    }
// END COLLECTIONS (SongLyricEntity)

    return map;
  }

  /// This method returns Json String [SongLyricEntity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SongLyricEntity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      name,
      secondaryName1,
      secondaryName2,
      lyrics,
      language,
      type,
      lilypond,
      favoriteOrder,
      transposition,
      showChords,
      accidentals,
      songsId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      secondaryName1,
      secondaryName2,
      lyrics,
      language,
      type,
      lilypond,
      favoriteOrder,
      transposition,
      showChords,
      accidentals,
      songsId
    ];
  }

  static Future<List<SongLyricEntity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR SongLyricEntity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<SongLyricEntity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SongLyricEntity>[];
    try {
      objList = list
          .map((songlyricentity) =>
              SongLyricEntity.fromMap(songlyricentity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR SongLyricEntity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SongLyricEntity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<SongLyricEntity> objList = <SongLyricEntity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SongLyricEntity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plAuthorEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthorEntities'))) {
          /*_loadedFields.add('song_lyrics.plAuthorEntities'); */
          obj.plAuthorEntities = obj.plAuthorEntities ??
              await obj.getAuthorEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plExternalEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternalEntities'))) {
          /*_loadedFields.add('song_lyrics.plExternalEntities'); */
          obj.plExternalEntities = obj.plExternalEntities ??
              await obj.getExternalEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plPlaylistEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistEntities'))) {
          /*_loadedFields.add('song_lyrics.plPlaylistEntities'); */
          obj.plPlaylistEntities = obj.plPlaylistEntities ??
              await obj.getPlaylistEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plSongbookRecordEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecordEntities'))) {
          /*_loadedFields.add('song_lyrics.plSongbookRecordEntities'); */
          obj.plSongbookRecordEntities = obj.plSongbookRecordEntities ??
              await obj.getSongbookRecordEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plTagEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTagEntities'))) {
          /*_loadedFields.add('song_lyrics.plTagEntities'); */
          obj.plTagEntities = obj.plTagEntities ??
              await obj.getTagEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songs.plSongEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongEntity'))) {
          /*_loadedFields.add('songs.plSongEntity');*/
          obj.plSongEntity = obj.plSongEntity ??
              await obj.getSongEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SongLyricEntity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns SongLyricEntity if exist, otherwise returns null
  Future<SongLyricEntity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    SongLyricEntity obj;
    final data = await _mnSongLyricEntity.getById([id]);
    if (data.length != 0) {
      obj = SongLyricEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plAuthorEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthorEntities'))) {
          /*_loadedFields.add('song_lyrics.plAuthorEntities'); */
          obj.plAuthorEntities = obj.plAuthorEntities ??
              await obj.getAuthorEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plExternalEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternalEntities'))) {
          /*_loadedFields.add('song_lyrics.plExternalEntities'); */
          obj.plExternalEntities = obj.plExternalEntities ??
              await obj.getExternalEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plPlaylistEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistEntities'))) {
          /*_loadedFields.add('song_lyrics.plPlaylistEntities'); */
          obj.plPlaylistEntities = obj.plPlaylistEntities ??
              await obj.getPlaylistEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plSongbookRecordEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecordEntities'))) {
          /*_loadedFields.add('song_lyrics.plSongbookRecordEntities'); */
          obj.plSongbookRecordEntities = obj.plSongbookRecordEntities ??
              await obj.getSongbookRecordEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plTagEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTagEntities'))) {
          /*_loadedFields.add('song_lyrics.plTagEntities'); */
          obj.plTagEntities = obj.plTagEntities ??
              await obj.getTagEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songs.plSongEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongEntity'))) {
          /*_loadedFields.add('songs.plSongEntity');*/
          obj.plSongEntity = obj.plSongEntity ??
              await obj.getSongEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SongLyricEntity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0 || !isSaved) {
      await _mnSongLyricEntity.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongLyricEntity.update(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<SongLyricEntity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SongLyricEntity> songlyricentities) async {
    // final results = _mnSongLyricEntity.saveAll('INSERT OR REPLACE INTO song_lyrics (id,name, secondaryName1, secondaryName2, lyrics, language, type, lilypond, favoriteOrder, transposition, showChords, accidentals, songsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',songlyricentities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in songlyricentities) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnSongLyricEntity.rawInsert(
              'INSERT OR REPLACE INTO song_lyrics (id,name, secondaryName1, secondaryName2, lyrics, language, type, lilypond, favoriteOrder, transposition, showChords, accidentals, songsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                name,
                secondaryName1,
                secondaryName2,
                lyrics,
                language,
                type,
                lilypond,
                favoriteOrder,
                transposition,
                showChords,
                accidentals,
                songsId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SongLyricEntity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SongLyricEntity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SongLyricEntity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<SongLyricEntity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<SongLyricEntity> songlyricentities) async {
    final results = await _mnSongLyricEntity.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyrics (id,name, secondaryName1, secondaryName2, lyrics, language, type, lilypond, favoriteOrder, transposition, showChords, accidentals, songsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
        songlyricentities);
    return results;
  }

  /// Deletes SongLyricEntity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete SongLyricEntity invoked (id=$id)');
    if (await ExternalEntity().select().song_lyricsId.equals(id).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (ExternalEntity.song_lyricsId)');
    }
    if (await SongbookRecordEntity()
            .select()
            .song_lyricsId
            .equals(id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SongbookRecordEntity.song_lyricsId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongLyricEntity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongLyricEntity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  SongLyricEntityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongLyricEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  SongLyricEntityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongLyricEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion songlyricentity

// region SongLyricEntityField
class SongLyricEntityField extends SearchCriteria {
  SongLyricEntityField(this.songlyricentityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  SongLyricEntityFilterBuilder songlyricentityFB;

  SongLyricEntityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  SongLyricEntityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    songlyricentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.EQuals, songlyricentityFB._addedBlocks)
        : setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.NotEQuals, songlyricentityFB._addedBlocks);
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    songlyricentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.EQualsOrNull, songlyricentityFB._addedBlocks)
        : setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, songlyricentityFB._addedBlocks);
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder isNull() {
    songlyricentityFB._addedBlocks = setCriteria(
        0,
        songlyricentityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songlyricentityFB._addedBlocks);
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      songlyricentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          songlyricentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songlyricentityFB._addedBlocks);
      _waitingNot = '';
      songlyricentityFB
              ._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
          songlyricentityFB._addedBlocks.retVal;
    }
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      songlyricentityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          songlyricentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songlyricentityFB._addedBlocks);
      _waitingNot = '';
      songlyricentityFB
              ._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
          songlyricentityFB._addedBlocks.retVal;
      songlyricentityFB
              ._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
          songlyricentityFB._addedBlocks.retVal;
    }
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      songlyricentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          songlyricentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songlyricentityFB._addedBlocks);
      _waitingNot = '';
      songlyricentityFB
              ._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
          songlyricentityFB._addedBlocks.retVal;
    }
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      songlyricentityFB._addedBlocks = setCriteria(
          pFirst,
          songlyricentityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          songlyricentityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        songlyricentityFB._addedBlocks = setCriteria(
            pFirst,
            songlyricentityFB.parameters,
            param,
            SqlSyntax.LessThan,
            songlyricentityFB._addedBlocks);
      } else {
        songlyricentityFB._addedBlocks = setCriteria(
            pFirst,
            songlyricentityFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            songlyricentityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        songlyricentityFB._addedBlocks = setCriteria(
            pLast,
            songlyricentityFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            songlyricentityFB._addedBlocks);
      } else {
        songlyricentityFB._addedBlocks = setCriteria(
            pLast,
            songlyricentityFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            songlyricentityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    songlyricentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.GreaterThan, songlyricentityFB._addedBlocks)
        : setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songlyricentityFB._addedBlocks);
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    songlyricentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.LessThan, songlyricentityFB._addedBlocks)
        : setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songlyricentityFB._addedBlocks);
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    songlyricentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, songlyricentityFB._addedBlocks)
        : setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.LessThan, songlyricentityFB._addedBlocks);
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    songlyricentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, songlyricentityFB._addedBlocks)
        : setCriteria(pValue, songlyricentityFB.parameters, param,
            SqlSyntax.GreaterThan, songlyricentityFB._addedBlocks);
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }

  SongLyricEntityFilterBuilder inValues(dynamic pValue) {
    songlyricentityFB._addedBlocks = setCriteria(
        pValue,
        songlyricentityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        songlyricentityFB._addedBlocks);
    _waitingNot = '';
    songlyricentityFB._addedBlocks.needEndBlock[songlyricentityFB._blockIndex] =
        songlyricentityFB._addedBlocks.retVal;
    return songlyricentityFB;
  }
}
// endregion SongLyricEntityField

// region SongLyricEntityFilterBuilder
class SongLyricEntityFilterBuilder extends SearchCriteria {
  SongLyricEntityFilterBuilder(SongLyricEntity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  SongLyricEntity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  SongLyricEntityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  SongLyricEntityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  SongLyricEntityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  SongLyricEntityFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  SongLyricEntityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  SongLyricEntityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  SongLyricEntityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongLyricEntityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongLyricEntityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  SongLyricEntityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  SongLyricEntityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  SongLyricEntityField setField(
      SongLyricEntityField field, String colName, DbType dbtype) {
    return SongLyricEntityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  SongLyricEntityField _id;
  SongLyricEntityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  SongLyricEntityField _name;
  SongLyricEntityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  SongLyricEntityField _secondaryName1;
  SongLyricEntityField get secondaryName1 {
    return _secondaryName1 =
        setField(_secondaryName1, 'secondaryName1', DbType.text);
  }

  SongLyricEntityField _secondaryName2;
  SongLyricEntityField get secondaryName2 {
    return _secondaryName2 =
        setField(_secondaryName2, 'secondaryName2', DbType.text);
  }

  SongLyricEntityField _lyrics;
  SongLyricEntityField get lyrics {
    return _lyrics = setField(_lyrics, 'lyrics', DbType.text);
  }

  SongLyricEntityField _language;
  SongLyricEntityField get language {
    return _language = setField(_language, 'language', DbType.text);
  }

  SongLyricEntityField _type;
  SongLyricEntityField get type {
    return _type = setField(_type, 'type', DbType.integer);
  }

  SongLyricEntityField _lilypond;
  SongLyricEntityField get lilypond {
    return _lilypond = setField(_lilypond, 'lilypond', DbType.text);
  }

  SongLyricEntityField _favoriteOrder;
  SongLyricEntityField get favoriteOrder {
    return _favoriteOrder =
        setField(_favoriteOrder, 'favoriteOrder', DbType.integer);
  }

  SongLyricEntityField _transposition;
  SongLyricEntityField get transposition {
    return _transposition =
        setField(_transposition, 'transposition', DbType.integer);
  }

  SongLyricEntityField _showChords;
  SongLyricEntityField get showChords {
    return _showChords = setField(_showChords, 'showChords', DbType.bool);
  }

  SongLyricEntityField _accidentals;
  SongLyricEntityField get accidentals {
    return _accidentals = setField(_accidentals, 'accidentals', DbType.integer);
  }

  SongLyricEntityField _songsId;
  SongLyricEntityField get songsId {
    return _songsId = setField(_songsId, 'songsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (SongLyricEntity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<SongLyricEntity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (ExternalEntity) according to DeleteRule.NO_ACTION

    final idListExternalEntityBYsong_lyricsId = toListPrimaryKeySQL(false);
    final resExternalEntityBYsong_lyricsId = await ExternalEntity()
        .select()
        .where(
            'song_lyricsId IN (${idListExternalEntityBYsong_lyricsId['sql']})',
            parameterValue: idListExternalEntityBYsong_lyricsId['args'])
        .toCount();
    if (resExternalEntityBYsong_lyricsId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (ExternalEntity.song_lyricsId)');
    }
// Check sub records where in (SongbookRecordEntity) according to DeleteRule.NO_ACTION

    final idListSongbookRecordEntityBYsong_lyricsId =
        toListPrimaryKeySQL(false);
    final resSongbookRecordEntityBYsong_lyricsId = await SongbookRecordEntity()
        .select()
        .where(
            'song_lyricsId IN (${idListSongbookRecordEntityBYsong_lyricsId['sql']})',
            parameterValue: idListSongbookRecordEntityBYsong_lyricsId['args'])
        .toCount();
    if (resSongbookRecordEntityBYsong_lyricsId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SongbookRecordEntity.song_lyricsId)');
    }

    if (SongLyricEntity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnSongLyricEntity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnSongLyricEntity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from song_lyrics ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnSongLyricEntity.updateBatch(qparams, values);
  }

  /// This method always returns SongLyricEntity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongLyricEntity>
  Future<SongLyricEntity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnSongLyricEntity.toList(qparams);
    final data = await objFuture;
    SongLyricEntity obj;
    if (data.isNotEmpty) {
      obj = SongLyricEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plAuthorEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthorEntities'))) {
          /*_loadedFields.add('song_lyrics.plAuthorEntities'); */
          obj.plAuthorEntities = obj.plAuthorEntities ??
              await obj.getAuthorEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plExternalEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternalEntities'))) {
          /*_loadedFields.add('song_lyrics.plExternalEntities'); */
          obj.plExternalEntities = obj.plExternalEntities ??
              await obj.getExternalEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plPlaylistEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistEntities'))) {
          /*_loadedFields.add('song_lyrics.plPlaylistEntities'); */
          obj.plPlaylistEntities = obj.plPlaylistEntities ??
              await obj.getPlaylistEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plSongbookRecordEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecordEntities'))) {
          /*_loadedFields.add('song_lyrics.plSongbookRecordEntities'); */
          obj.plSongbookRecordEntities = obj.plSongbookRecordEntities ??
              await obj.getSongbookRecordEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('song_lyrics.plTagEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTagEntities'))) {
          /*_loadedFields.add('song_lyrics.plTagEntities'); */
          obj.plTagEntities = obj.plTagEntities ??
              await obj.getTagEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('songs.plSongEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongEntity'))) {
          /*_loadedFields.add('songs.plSongEntity');*/
          obj.plSongEntity = obj.plSongEntity ??
              await obj.getSongEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [SongLyricEntity]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) songlyricentityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songlyricentitiesFuture =
        await _obj._mnSongLyricEntity.toList(qparams);
    final int count = songlyricentitiesFuture[0]['CNT'] as int;
    if (songlyricentityCount != null) {
      songlyricentityCount(count);
    }
    return count;
  }

  /// This method returns List<SongLyricEntity> [SongLyricEntity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<SongLyricEntity>
  Future<List<SongLyricEntity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<SongLyricEntity> songlyricentitiesData =
        await SongLyricEntity.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return songlyricentitiesData;
  }

  /// This method returns Json String [SongLyricEntity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SongLyricEntity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SongLyricEntity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnSongLyricEntity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SongLyricEntity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM song_lyrics WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnSongLyricEntity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SongLyricEntity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnSongLyricEntity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await SongLyricEntity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnSongLyricEntity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongLyricEntityFilterBuilder

// region SongLyricEntityFields
class SongLyricEntityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fSecondaryName1;
  static TableField get secondaryName1 {
    return _fSecondaryName1 = _fSecondaryName1 ??
        SqlSyntax.setField(_fSecondaryName1, 'secondaryName1', DbType.text);
  }

  static TableField _fSecondaryName2;
  static TableField get secondaryName2 {
    return _fSecondaryName2 = _fSecondaryName2 ??
        SqlSyntax.setField(_fSecondaryName2, 'secondaryName2', DbType.text);
  }

  static TableField _fLyrics;
  static TableField get lyrics {
    return _fLyrics =
        _fLyrics ?? SqlSyntax.setField(_fLyrics, 'lyrics', DbType.text);
  }

  static TableField _fLanguage;
  static TableField get language {
    return _fLanguage =
        _fLanguage ?? SqlSyntax.setField(_fLanguage, 'language', DbType.text);
  }

  static TableField _fType;
  static TableField get type {
    return _fType =
        _fType ?? SqlSyntax.setField(_fType, 'type', DbType.integer);
  }

  static TableField _fLilypond;
  static TableField get lilypond {
    return _fLilypond =
        _fLilypond ?? SqlSyntax.setField(_fLilypond, 'lilypond', DbType.text);
  }

  static TableField _fFavoriteOrder;
  static TableField get favoriteOrder {
    return _fFavoriteOrder = _fFavoriteOrder ??
        SqlSyntax.setField(_fFavoriteOrder, 'favoriteOrder', DbType.integer);
  }

  static TableField _fTransposition;
  static TableField get transposition {
    return _fTransposition = _fTransposition ??
        SqlSyntax.setField(_fTransposition, 'transposition', DbType.integer);
  }

  static TableField _fShowChords;
  static TableField get showChords {
    return _fShowChords = _fShowChords ??
        SqlSyntax.setField(_fShowChords, 'showChords', DbType.bool);
  }

  static TableField _fAccidentals;
  static TableField get accidentals {
    return _fAccidentals = _fAccidentals ??
        SqlSyntax.setField(_fAccidentals, 'accidentals', DbType.integer);
  }

  static TableField _fSongsId;
  static TableField get songsId {
    return _fSongsId =
        _fSongsId ?? SqlSyntax.setField(_fSongsId, 'songsId', DbType.integer);
  }
}
// endregion SongLyricEntityFields

//region SongLyricEntityManager
class SongLyricEntityManager extends SqfEntityProvider {
  SongLyricEntityManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'song_lyrics';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion SongLyricEntityManager
// region TagEntity
class TagEntity {
  TagEntity({this.id, this.name, this.type}) {
    _setDefaultValues();
  }
  TagEntity.withFields(this.id, this.name, this.type) {
    _setDefaultValues();
  }
  TagEntity.withId(this.id, this.name, this.type) {
    _setDefaultValues();
  }
  TagEntity.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['type'] != null) {
      type = int.tryParse(o['type'].toString());
    }

    isSaved = true;
  }
  // FIELDS (TagEntity)
  int id;
  String name;
  int type;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (TagEntity)

// COLLECTIONS & VIRTUALS (TagEntity)
  ///(RelationType.MANY_TO_MANY) (song_lyricsTags) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntities', 'plField2'..]) or so on..
  List<SongLyricEntity> plSongLyricEntities;

  /// get SongLyricEntity(s) filtered by song_lyricsId IN song_lyricsTags
  SongLyricEntityFilterBuilder getSongLyricEntities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return SongLyricEntity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT song_lyricsId FROM song_lyricsTags WHERE tagsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (TagEntity)

  static const bool _softDeleteActivated = false;
  TagEntityManager __mnTagEntity;

  TagEntityManager get _mnTagEntity {
    return __mnTagEntity = __mnTagEntity ?? TagEntityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (type != null) {
      map['type'] = type;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (type != null) {
      map['type'] = type;
    }

// COLLECTIONS (TagEntity)
    if (!forQuery) {
      map['SongLyricEntities'] = await getSongLyricEntities().toMapList();
    }
// END COLLECTIONS (TagEntity)

    return map;
  }

  /// This method returns Json String [TagEntity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TagEntity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [id, name, type];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, type];
  }

  static Future<List<TagEntity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR TagEntity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<TagEntity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TagEntity>[];
    try {
      objList = list
          .map((tagentity) =>
              TagEntity.fromMap(tagentity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR TagEntity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TagEntity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<TagEntity> objList = <TagEntity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TagEntity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('tags.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns TagEntity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns TagEntity if exist, otherwise returns null
  Future<TagEntity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    TagEntity obj;
    final data = await _mnTagEntity.getById([id]);
    if (data.length != 0) {
      obj = TagEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('tags.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TagEntity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0 || !isSaved) {
      await _mnTagEntity.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTagEntity.update(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<TagEntity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<TagEntity> tagentities) async {
    // final results = _mnTagEntity.saveAll('INSERT OR REPLACE INTO tags (id,name, type)  VALUES (?,?,?)',tagentities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in tagentities) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnTagEntity.rawInsert(
              'INSERT OR REPLACE INTO tags (id,name, type)  VALUES (?,?,?)',
              [id, name, type]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TagEntity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'TagEntity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TagEntity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<TagEntity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<TagEntity> tagentities) async {
    final results = await _mnTagEntity.rawInsertAll(
        'INSERT OR REPLACE INTO tags (id,name, type)  VALUES (?,?,?)',
        tagentities);
    return results;
  }

  /// Deletes TagEntity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete TagEntity invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTagEntity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnTagEntity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  TagEntityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return TagEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  TagEntityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return TagEntityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion tagentity

// region TagEntityField
class TagEntityField extends SearchCriteria {
  TagEntityField(this.tagentityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  TagEntityFilterBuilder tagentityFB;

  TagEntityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  TagEntityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    tagentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagentityFB.parameters, param, SqlSyntax.EQuals,
            tagentityFB._addedBlocks)
        : setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.NotEQuals, tagentityFB._addedBlocks);
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }

  TagEntityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    tagentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.EQualsOrNull, tagentityFB._addedBlocks)
        : setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, tagentityFB._addedBlocks);
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }

  TagEntityFilterBuilder isNull() {
    tagentityFB._addedBlocks = setCriteria(
        0,
        tagentityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        tagentityFB._addedBlocks);
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }

  TagEntityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      tagentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          tagentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          tagentityFB._addedBlocks);
      _waitingNot = '';
      tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
          tagentityFB._addedBlocks.retVal;
    }
    return tagentityFB;
  }

  TagEntityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      tagentityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          tagentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          tagentityFB._addedBlocks);
      _waitingNot = '';
      tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
          tagentityFB._addedBlocks.retVal;
      tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
          tagentityFB._addedBlocks.retVal;
    }
    return tagentityFB;
  }

  TagEntityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      tagentityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          tagentityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          tagentityFB._addedBlocks);
      _waitingNot = '';
      tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
          tagentityFB._addedBlocks.retVal;
    }
    return tagentityFB;
  }

  TagEntityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      tagentityFB._addedBlocks = setCriteria(
          pFirst,
          tagentityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          tagentityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        tagentityFB._addedBlocks = setCriteria(pFirst, tagentityFB.parameters,
            param, SqlSyntax.LessThan, tagentityFB._addedBlocks);
      } else {
        tagentityFB._addedBlocks = setCriteria(pFirst, tagentityFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, tagentityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        tagentityFB._addedBlocks = setCriteria(pLast, tagentityFB.parameters,
            param, SqlSyntax.GreaterThan, tagentityFB._addedBlocks);
      } else {
        tagentityFB._addedBlocks = setCriteria(pLast, tagentityFB.parameters,
            param, SqlSyntax.LessThanOrEquals, tagentityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }

  TagEntityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    tagentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.GreaterThan, tagentityFB._addedBlocks)
        : setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, tagentityFB._addedBlocks);
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }

  TagEntityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    tagentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagentityFB.parameters, param, SqlSyntax.LessThan,
            tagentityFB._addedBlocks)
        : setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, tagentityFB._addedBlocks);
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }

  TagEntityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    tagentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, tagentityFB._addedBlocks)
        : setCriteria(pValue, tagentityFB.parameters, param, SqlSyntax.LessThan,
            tagentityFB._addedBlocks);
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }

  TagEntityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    tagentityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, tagentityFB._addedBlocks)
        : setCriteria(pValue, tagentityFB.parameters, param,
            SqlSyntax.GreaterThan, tagentityFB._addedBlocks);
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }

  TagEntityFilterBuilder inValues(dynamic pValue) {
    tagentityFB._addedBlocks = setCriteria(
        pValue,
        tagentityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        tagentityFB._addedBlocks);
    _waitingNot = '';
    tagentityFB._addedBlocks.needEndBlock[tagentityFB._blockIndex] =
        tagentityFB._addedBlocks.retVal;
    return tagentityFB;
  }
}
// endregion TagEntityField

// region TagEntityFilterBuilder
class TagEntityFilterBuilder extends SearchCriteria {
  TagEntityFilterBuilder(TagEntity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  TagEntity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  TagEntityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  TagEntityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  TagEntityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  TagEntityFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  TagEntityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  TagEntityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  TagEntityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  TagEntityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  TagEntityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  TagEntityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  TagEntityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  TagEntityField setField(TagEntityField field, String colName, DbType dbtype) {
    return TagEntityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  TagEntityField _id;
  TagEntityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  TagEntityField _name;
  TagEntityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  TagEntityField _type;
  TagEntityField get type {
    return _type = setField(_type, 'type', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (TagEntity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<TagEntity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (TagEntity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnTagEntity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnTagEntity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from tags ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnTagEntity.updateBatch(qparams, values);
  }

  /// This method always returns TagEntity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<TagEntity>
  Future<TagEntity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnTagEntity.toList(qparams);
    final data = await objFuture;
    TagEntity obj;
    if (data.isNotEmpty) {
      obj = TagEntity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plSongLyricEntities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyricEntities'))) {
          /*_loadedFields.add('tags.plSongLyricEntities'); */
          obj.plSongLyricEntities = obj.plSongLyricEntities ??
              await obj.getSongLyricEntities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [TagEntity]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) tagentityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tagentitiesFuture = await _obj._mnTagEntity.toList(qparams);
    final int count = tagentitiesFuture[0]['CNT'] as int;
    if (tagentityCount != null) {
      tagentityCount(count);
    }
    return count;
  }

  /// This method returns List<TagEntity> [TagEntity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<TagEntity>
  Future<List<TagEntity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<TagEntity> tagentitiesData = await TagEntity.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tagentitiesData;
  }

  /// This method returns Json String [TagEntity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TagEntity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TagEntity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnTagEntity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TagEntity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM tags WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnTagEntity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TagEntity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnTagEntity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await TagEntity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnTagEntity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TagEntityFilterBuilder

// region TagEntityFields
class TagEntityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fType;
  static TableField get type {
    return _fType =
        _fType ?? SqlSyntax.setField(_fType, 'type', DbType.integer);
  }
}
// endregion TagEntityFields

//region TagEntityManager
class TagEntityManager extends SqfEntityProvider {
  TagEntityManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'tags';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion TagEntityManager
// region ExternalsAuthors
class ExternalsAuthors {
  ExternalsAuthors({this.externalsId, this.authorsId}) {
    _setDefaultValues();
  }
  ExternalsAuthors.withFields(this.externalsId, this.authorsId) {
    _setDefaultValues();
  }
  ExternalsAuthors.withId(this.externalsId, this.authorsId) {
    _setDefaultValues();
  }
  ExternalsAuthors.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    externalsId = int.tryParse(o['externalsId'].toString());

    authorsId = int.tryParse(o['authorsId'].toString());

    // RELATIONSHIPS FromMAP
    plExternalEntity = o['externalEntity'] != null
        ? ExternalEntity.fromMap(o['externalEntity'] as Map<String, dynamic>)
        : null;
    plAuthorEntity = o['authorEntity'] != null
        ? AuthorEntity.fromMap(o['authorEntity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (ExternalsAuthors)
  int externalsId;
  int authorsId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (ExternalsAuthors)

// RELATIONSHIPS (ExternalsAuthors)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExternalEntity', 'plField2'..]) or so on..
  ExternalEntity plExternalEntity;

  /// get ExternalEntity By ExternalsId
  Future<ExternalEntity> getExternalEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await ExternalEntity().getById(externalsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plAuthorEntity', 'plField2'..]) or so on..
  AuthorEntity plAuthorEntity;

  /// get AuthorEntity By AuthorsId
  Future<AuthorEntity> getAuthorEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await AuthorEntity().getById(authorsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (ExternalsAuthors)

  static const bool _softDeleteActivated = false;
  ExternalsAuthorsManager __mnExternalsAuthors;

  ExternalsAuthorsManager get _mnExternalsAuthors {
    return __mnExternalsAuthors =
        __mnExternalsAuthors ?? ExternalsAuthorsManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (externalsId != null) {
      map['externalsId'] = forView ? plExternalEntity.name : externalsId;
    }

    if (authorsId != null) {
      map['authorsId'] = forView ? plAuthorEntity.name : authorsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (externalsId != null) {
      map['externalsId'] = forView ? plExternalEntity.name : externalsId;
    }

    if (authorsId != null) {
      map['authorsId'] = forView ? plAuthorEntity.name : authorsId;
    }

    return map;
  }

  /// This method returns Json String [ExternalsAuthors]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ExternalsAuthors]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [externalsId, authorsId];
  }

  List<dynamic> toArgsWithIds() {
    return [externalsId, authorsId];
  }

  static Future<List<ExternalsAuthors>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR ExternalsAuthors.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<ExternalsAuthors>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ExternalsAuthors>[];
    try {
      objList = list
          .map((externalsauthors) => ExternalsAuthors.fromMap(
              externalsauthors as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR ExternalsAuthors.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ExternalsAuthors>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<ExternalsAuthors> objList = <ExternalsAuthors>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ExternalsAuthors.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('externals.plExternalEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExternalEntity'))) {
          /*_loadedFields.add('externals.plExternalEntity');*/
          obj.plExternalEntity = obj.plExternalEntity ??
              await obj.getExternalEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plAuthorEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthorEntity'))) {
          /*_loadedFields.add('authors.plAuthorEntity');*/
          obj.plAuthorEntity = obj.plAuthorEntity ??
              await obj.getAuthorEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns ExternalsAuthors by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int externalsId, int authorsId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns ExternalsAuthors if exist, otherwise returns null
  Future<ExternalsAuthors> getById(int externalsId, int authorsId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (externalsId == null) {
      return null;
    }
    ExternalsAuthors obj;
    final data = await _mnExternalsAuthors.getById([externalsId, authorsId]);
    if (data.length != 0) {
      obj = ExternalsAuthors.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('externals.plExternalEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExternalEntity'))) {
          /*_loadedFields.add('externals.plExternalEntity');*/
          obj.plExternalEntity = obj.plExternalEntity ??
              await obj.getExternalEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plAuthorEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthorEntity'))) {
          /*_loadedFields.add('authors.plAuthorEntity');*/
          obj.plAuthorEntity = obj.plAuthorEntity ??
              await obj.getAuthorEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ExternalsAuthors) object. If the Primary Key (externalsId) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same externalsId

  /// <returns>Returns BoolResult
  Future<BoolResult> save() async {
    final result = BoolResult(success: false);
    try {
      await _mnExternalsAuthors.rawInsert(
          'INSERT ${isSaved ? 'OR REPLACE' : ''} INTO externalsAuthors (externalsId, authorsId)  VALUES (?,?)',
          toArgsWithIds());
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ExternalsAuthors> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ExternalsAuthors> externalsauthorses) async {
    // final results = _mnExternalsAuthors.saveAll('INSERT OR REPLACE INTO externalsAuthors (externalsId, authorsId)  VALUES (?,?)',externalsauthorses);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in externalsauthorses) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns 1
  Future<int> upsert() async {
    try {
      if (await _mnExternalsAuthors.rawInsert(
              'INSERT OR REPLACE INTO externalsAuthors (externalsId, authorsId)  VALUES (?,?)',
              [externalsId, authorsId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ExternalsAuthors externalsId=$externalsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ExternalsAuthors externalsId=$externalsId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ExternalsAuthors Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<ExternalsAuthors>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<ExternalsAuthors> externalsauthorses) async {
    final results = await _mnExternalsAuthors.rawInsertAll(
        'INSERT OR REPLACE INTO externalsAuthors (externalsId, authorsId)  VALUES (?,?)',
        externalsauthorses);
    return results;
  }

  /// Deletes ExternalsAuthors

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete ExternalsAuthors invoked (externalsId=$externalsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExternalsAuthors.delete(QueryParams(
          whereString: 'externalsId=? AND authorsId=?',
          whereArguments: [externalsId, authorsId]));
    } else {
      return _mnExternalsAuthors.updateBatch(
          QueryParams(
              whereString: 'externalsId=? AND authorsId=?',
              whereArguments: [externalsId, authorsId]),
          {'isDeleted': 1});
    }
  }

  ExternalsAuthorsFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExternalsAuthorsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ExternalsAuthorsFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExternalsAuthorsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion externalsauthors

// region ExternalsAuthorsField
class ExternalsAuthorsField extends SearchCriteria {
  ExternalsAuthorsField(this.externalsauthorsFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  ExternalsAuthorsFilterBuilder externalsauthorsFB;

  ExternalsAuthorsField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ExternalsAuthorsFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.EQuals, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.NotEQuals, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.EQualsOrNull, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder isNull() {
    externalsauthorsFB._addedBlocks = setCriteria(
        0,
        externalsauthorsFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      externalsauthorsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          externalsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalsauthorsFB._addedBlocks);
      _waitingNot = '';
      externalsauthorsFB
              ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
          externalsauthorsFB._addedBlocks.retVal;
    }
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      externalsauthorsFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          externalsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalsauthorsFB._addedBlocks);
      _waitingNot = '';
      externalsauthorsFB
              ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
          externalsauthorsFB._addedBlocks.retVal;
      externalsauthorsFB
              ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
          externalsauthorsFB._addedBlocks.retVal;
    }
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      externalsauthorsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          externalsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalsauthorsFB._addedBlocks);
      _waitingNot = '';
      externalsauthorsFB
              ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
          externalsauthorsFB._addedBlocks.retVal;
    }
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      externalsauthorsFB._addedBlocks = setCriteria(
          pFirst,
          externalsauthorsFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          externalsauthorsFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        externalsauthorsFB._addedBlocks = setCriteria(
            pFirst,
            externalsauthorsFB.parameters,
            param,
            SqlSyntax.LessThan,
            externalsauthorsFB._addedBlocks);
      } else {
        externalsauthorsFB._addedBlocks = setCriteria(
            pFirst,
            externalsauthorsFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            externalsauthorsFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        externalsauthorsFB._addedBlocks = setCriteria(
            pLast,
            externalsauthorsFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            externalsauthorsFB._addedBlocks);
      } else {
        externalsauthorsFB._addedBlocks = setCriteria(
            pLast,
            externalsauthorsFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            externalsauthorsFB._addedBlocks);
      }
    }
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.GreaterThan, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.LessThan, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.LessThan, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    externalsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, externalsauthorsFB._addedBlocks)
        : setCriteria(pValue, externalsauthorsFB.parameters, param,
            SqlSyntax.GreaterThan, externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }

  ExternalsAuthorsFilterBuilder inValues(dynamic pValue) {
    externalsauthorsFB._addedBlocks = setCriteria(
        pValue,
        externalsauthorsFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        externalsauthorsFB._addedBlocks);
    _waitingNot = '';
    externalsauthorsFB
            ._addedBlocks.needEndBlock[externalsauthorsFB._blockIndex] =
        externalsauthorsFB._addedBlocks.retVal;
    return externalsauthorsFB;
  }
}
// endregion ExternalsAuthorsField

// region ExternalsAuthorsFilterBuilder
class ExternalsAuthorsFilterBuilder extends SearchCriteria {
  ExternalsAuthorsFilterBuilder(ExternalsAuthors obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  ExternalsAuthors _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  ExternalsAuthorsFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ExternalsAuthorsFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ExternalsAuthorsFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ExternalsAuthorsFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ExternalsAuthorsFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ExternalsAuthorsFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ExternalsAuthorsFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExternalsAuthorsFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExternalsAuthorsFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExternalsAuthorsFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExternalsAuthorsFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ExternalsAuthorsField setField(
      ExternalsAuthorsField field, String colName, DbType dbtype) {
    return ExternalsAuthorsField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  ExternalsAuthorsField _externalsId;
  ExternalsAuthorsField get externalsId {
    return _externalsId = setField(_externalsId, 'externalsId', DbType.integer);
  }

  ExternalsAuthorsField _authorsId;
  ExternalsAuthorsField get authorsId {
    return _authorsId = setField(_authorsId, 'authorsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (ExternalsAuthors._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<ExternalsAuthors> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (ExternalsAuthors._softDeleteActivated && !hardDelete) {
      r = await _obj._mnExternalsAuthors.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnExternalsAuthors.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'externalsId IN (SELECT externalsId from externalsAuthors ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnExternalsAuthors.updateBatch(qparams, values);
  }

  /// This method always returns ExternalsAuthors Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ExternalsAuthors>
  Future<ExternalsAuthors> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnExternalsAuthors.toList(qparams);
    final data = await objFuture;
    ExternalsAuthors obj;
    if (data.isNotEmpty) {
      obj = ExternalsAuthors.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('externals.plExternalEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExternalEntity'))) {
          /*_loadedFields.add('externals.plExternalEntity');*/
          obj.plExternalEntity = obj.plExternalEntity ??
              await obj.getExternalEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plAuthorEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthorEntity'))) {
          /*_loadedFields.add('authors.plAuthorEntity');*/
          obj.plAuthorEntity = obj.plAuthorEntity ??
              await obj.getAuthorEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [ExternalsAuthors]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) externalsauthorsCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final externalsauthorsesFuture =
        await _obj._mnExternalsAuthors.toList(qparams);
    final int count = externalsauthorsesFuture[0]['CNT'] as int;
    if (externalsauthorsCount != null) {
      externalsauthorsCount(count);
    }
    return count;
  }

  /// This method returns List<ExternalsAuthors> [ExternalsAuthors]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ExternalsAuthors>
  Future<List<ExternalsAuthors>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<ExternalsAuthors> externalsauthorsesData =
        await ExternalsAuthors.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return externalsauthorsesData;
  }

  /// This method returns Json String [ExternalsAuthors]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ExternalsAuthors]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ExternalsAuthors]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnExternalsAuthors.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ExternalsAuthors]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `externalsId`authorsId` FROM externalsAuthors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<externalsId,authorsId> [ExternalsAuthors]
  /// <returns>List<externalsId,authorsId>
  Future<List<ExternalsAuthors>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['externalsId', 'authorsId'];
    final externalsauthorsFuture =
        await _obj._mnExternalsAuthors.toList(qparams);
    return await ExternalsAuthors.fromMapList(externalsauthorsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ExternalsAuthors]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnExternalsAuthors.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await ExternalsAuthors.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnExternalsAuthors.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExternalsAuthorsFilterBuilder

// region ExternalsAuthorsFields
class ExternalsAuthorsFields {
  static TableField _fExternalsId;
  static TableField get externalsId {
    return _fExternalsId = _fExternalsId ??
        SqlSyntax.setField(_fExternalsId, 'externalsId', DbType.integer);
  }

  static TableField _fAuthorsId;
  static TableField get authorsId {
    return _fAuthorsId = _fAuthorsId ??
        SqlSyntax.setField(_fAuthorsId, 'authorsId', DbType.integer);
  }
}
// endregion ExternalsAuthorsFields

//region ExternalsAuthorsManager
class ExternalsAuthorsManager extends SqfEntityProvider {
  ExternalsAuthorsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'externalsAuthors';
  static final List<String> _primaryKeyList = ['externalsId', 'authorsId'];
  static final String _whereStr = 'externalsId=? AND authorsId=?';
}

//endregion ExternalsAuthorsManager
// region Song_lyricsAuthors
class Song_lyricsAuthors {
  Song_lyricsAuthors({this.song_lyricsId, this.authorsId}) {
    _setDefaultValues();
  }
  Song_lyricsAuthors.withFields(this.song_lyricsId, this.authorsId) {
    _setDefaultValues();
  }
  Song_lyricsAuthors.withId(this.song_lyricsId, this.authorsId) {
    _setDefaultValues();
  }
  Song_lyricsAuthors.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    authorsId = int.tryParse(o['authorsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyricEntity = o['songLyricEntity'] != null
        ? SongLyricEntity.fromMap(o['songLyricEntity'] as Map<String, dynamic>)
        : null;
    plAuthorEntity = o['authorEntity'] != null
        ? AuthorEntity.fromMap(o['authorEntity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Song_lyricsAuthors)
  int song_lyricsId;
  int authorsId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Song_lyricsAuthors)

// RELATIONSHIPS (Song_lyricsAuthors)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntity', 'plField2'..]) or so on..
  SongLyricEntity plSongLyricEntity;

  /// get SongLyricEntity By Song_lyricsId
  Future<SongLyricEntity> getSongLyricEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await SongLyricEntity().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plAuthorEntity', 'plField2'..]) or so on..
  AuthorEntity plAuthorEntity;

  /// get AuthorEntity By AuthorsId
  Future<AuthorEntity> getAuthorEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await AuthorEntity().getById(authorsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Song_lyricsAuthors)

  static const bool _softDeleteActivated = false;
  Song_lyricsAuthorsManager __mnSong_lyricsAuthors;

  Song_lyricsAuthorsManager get _mnSong_lyricsAuthors {
    return __mnSong_lyricsAuthors =
        __mnSong_lyricsAuthors ?? Song_lyricsAuthorsManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    if (authorsId != null) {
      map['authorsId'] = forView ? plAuthorEntity.name : authorsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    if (authorsId != null) {
      map['authorsId'] = forView ? plAuthorEntity.name : authorsId;
    }

    return map;
  }

  /// This method returns Json String [Song_lyricsAuthors]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song_lyricsAuthors]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [song_lyricsId, authorsId];
  }

  List<dynamic> toArgsWithIds() {
    return [song_lyricsId, authorsId];
  }

  static Future<List<Song_lyricsAuthors>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Song_lyricsAuthors.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Song_lyricsAuthors>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song_lyricsAuthors>[];
    try {
      objList = list
          .map((song_lyricsauthors) => Song_lyricsAuthors.fromMap(
              song_lyricsauthors as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR Song_lyricsAuthors.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song_lyricsAuthors>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song_lyricsAuthors> objList = <Song_lyricsAuthors>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song_lyricsAuthors.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plAuthorEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthorEntity'))) {
          /*_loadedFields.add('authors.plAuthorEntity');*/
          obj.plAuthorEntity = obj.plAuthorEntity ??
              await obj.getAuthorEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song_lyricsAuthors by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int song_lyricsId, int authorsId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Song_lyricsAuthors if exist, otherwise returns null
  Future<Song_lyricsAuthors> getById(int song_lyricsId, int authorsId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (song_lyricsId == null) {
      return null;
    }
    Song_lyricsAuthors obj;
    final data =
        await _mnSong_lyricsAuthors.getById([song_lyricsId, authorsId]);
    if (data.length != 0) {
      obj = Song_lyricsAuthors.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plAuthorEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthorEntity'))) {
          /*_loadedFields.add('authors.plAuthorEntity');*/
          obj.plAuthorEntity = obj.plAuthorEntity ??
              await obj.getAuthorEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song_lyricsAuthors) object. If the Primary Key (song_lyricsId) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same song_lyricsId

  /// <returns>Returns BoolResult
  Future<BoolResult> save() async {
    final result = BoolResult(success: false);
    try {
      await _mnSong_lyricsAuthors.rawInsert(
          'INSERT ${isSaved ? 'OR REPLACE' : ''} INTO song_lyricsAuthors (song_lyricsId, authorsId)  VALUES (?,?)',
          toArgsWithIds());
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Song_lyricsAuthors> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Song_lyricsAuthors> song_lyricsauthorses) async {
    // final results = _mnSong_lyricsAuthors.saveAll('INSERT OR REPLACE INTO song_lyricsAuthors (song_lyricsId, authorsId)  VALUES (?,?)',song_lyricsauthorses);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in song_lyricsauthorses) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns 1
  Future<int> upsert() async {
    try {
      if (await _mnSong_lyricsAuthors.rawInsert(
              'INSERT OR REPLACE INTO song_lyricsAuthors (song_lyricsId, authorsId)  VALUES (?,?)',
              [song_lyricsId, authorsId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Song_lyricsAuthors song_lyricsId=$song_lyricsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Song_lyricsAuthors song_lyricsId=$song_lyricsId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'Song_lyricsAuthors Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Song_lyricsAuthors>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<Song_lyricsAuthors> song_lyricsauthorses) async {
    final results = await _mnSong_lyricsAuthors.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyricsAuthors (song_lyricsId, authorsId)  VALUES (?,?)',
        song_lyricsauthorses);
    return results;
  }

  /// Deletes Song_lyricsAuthors

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete Song_lyricsAuthors invoked (song_lyricsId=$song_lyricsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong_lyricsAuthors.delete(QueryParams(
          whereString: 'song_lyricsId=? AND authorsId=?',
          whereArguments: [song_lyricsId, authorsId]));
    } else {
      return _mnSong_lyricsAuthors.updateBatch(
          QueryParams(
              whereString: 'song_lyricsId=? AND authorsId=?',
              whereArguments: [song_lyricsId, authorsId]),
          {'isDeleted': 1});
    }
  }

  Song_lyricsAuthorsFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return Song_lyricsAuthorsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  Song_lyricsAuthorsFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return Song_lyricsAuthorsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion song_lyricsauthors

// region Song_lyricsAuthorsField
class Song_lyricsAuthorsField extends SearchCriteria {
  Song_lyricsAuthorsField(this.song_lyricsauthorsFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  Song_lyricsAuthorsFilterBuilder song_lyricsauthorsFB;

  Song_lyricsAuthorsField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  Song_lyricsAuthorsFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.EQuals, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.NotEQuals, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.EQualsOrNull, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder isNull() {
    song_lyricsauthorsFB._addedBlocks = setCriteria(
        0,
        song_lyricsauthorsFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      song_lyricsauthorsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          song_lyricsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsauthorsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsauthorsFB
              ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
          song_lyricsauthorsFB._addedBlocks.retVal;
    }
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricsauthorsFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          song_lyricsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsauthorsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsauthorsFB
              ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
          song_lyricsauthorsFB._addedBlocks.retVal;
      song_lyricsauthorsFB
              ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
          song_lyricsauthorsFB._addedBlocks.retVal;
    }
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricsauthorsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          song_lyricsauthorsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsauthorsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsauthorsFB
              ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
          song_lyricsauthorsFB._addedBlocks.retVal;
    }
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      song_lyricsauthorsFB._addedBlocks = setCriteria(
          pFirst,
          song_lyricsauthorsFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsauthorsFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        song_lyricsauthorsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricsauthorsFB.parameters,
            param,
            SqlSyntax.LessThan,
            song_lyricsauthorsFB._addedBlocks);
      } else {
        song_lyricsauthorsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricsauthorsFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            song_lyricsauthorsFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        song_lyricsauthorsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricsauthorsFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            song_lyricsauthorsFB._addedBlocks);
      } else {
        song_lyricsauthorsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricsauthorsFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            song_lyricsauthorsFB._addedBlocks);
      }
    }
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    song_lyricsauthorsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricsauthorsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsauthorsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }

  Song_lyricsAuthorsFilterBuilder inValues(dynamic pValue) {
    song_lyricsauthorsFB._addedBlocks = setCriteria(
        pValue,
        song_lyricsauthorsFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricsauthorsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsauthorsFB
            ._addedBlocks.needEndBlock[song_lyricsauthorsFB._blockIndex] =
        song_lyricsauthorsFB._addedBlocks.retVal;
    return song_lyricsauthorsFB;
  }
}
// endregion Song_lyricsAuthorsField

// region Song_lyricsAuthorsFilterBuilder
class Song_lyricsAuthorsFilterBuilder extends SearchCriteria {
  Song_lyricsAuthorsFilterBuilder(Song_lyricsAuthors obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Song_lyricsAuthors _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  Song_lyricsAuthorsFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  Song_lyricsAuthorsFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  Song_lyricsAuthorsFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  Song_lyricsAuthorsFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  Song_lyricsAuthorsFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  Song_lyricsAuthorsFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  Song_lyricsAuthorsFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsAuthorsFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsAuthorsFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsAuthorsFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsAuthorsFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  Song_lyricsAuthorsField setField(
      Song_lyricsAuthorsField field, String colName, DbType dbtype) {
    return Song_lyricsAuthorsField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  Song_lyricsAuthorsField _song_lyricsId;
  Song_lyricsAuthorsField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  Song_lyricsAuthorsField _authorsId;
  Song_lyricsAuthorsField get authorsId {
    return _authorsId = setField(_authorsId, 'authorsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Song_lyricsAuthors._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Song_lyricsAuthors> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Song_lyricsAuthors._softDeleteActivated && !hardDelete) {
      r = await _obj._mnSong_lyricsAuthors
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnSong_lyricsAuthors.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'song_lyricsId IN (SELECT song_lyricsId from song_lyricsAuthors ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnSong_lyricsAuthors.updateBatch(qparams, values);
  }

  /// This method always returns Song_lyricsAuthors Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsAuthors>
  Future<Song_lyricsAuthors> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnSong_lyricsAuthors.toList(qparams);
    final data = await objFuture;
    Song_lyricsAuthors obj;
    if (data.isNotEmpty) {
      obj = Song_lyricsAuthors.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('authors.plAuthorEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAuthorEntity'))) {
          /*_loadedFields.add('authors.plAuthorEntity');*/
          obj.plAuthorEntity = obj.plAuthorEntity ??
              await obj.getAuthorEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Song_lyricsAuthors]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) song_lyricsauthorsCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final song_lyricsauthorsesFuture =
        await _obj._mnSong_lyricsAuthors.toList(qparams);
    final int count = song_lyricsauthorsesFuture[0]['CNT'] as int;
    if (song_lyricsauthorsCount != null) {
      song_lyricsauthorsCount(count);
    }
    return count;
  }

  /// This method returns List<Song_lyricsAuthors> [Song_lyricsAuthors]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsAuthors>
  Future<List<Song_lyricsAuthors>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Song_lyricsAuthors> song_lyricsauthorsesData =
        await Song_lyricsAuthors.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return song_lyricsauthorsesData;
  }

  /// This method returns Json String [Song_lyricsAuthors]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song_lyricsAuthors]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song_lyricsAuthors]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnSong_lyricsAuthors.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song_lyricsAuthors]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `song_lyricsId`authorsId` FROM song_lyricsAuthors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<song_lyricsId,authorsId> [Song_lyricsAuthors]
  /// <returns>List<song_lyricsId,authorsId>
  Future<List<Song_lyricsAuthors>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['song_lyricsId', 'authorsId'];
    final song_lyricsauthorsFuture =
        await _obj._mnSong_lyricsAuthors.toList(qparams);
    return await Song_lyricsAuthors.fromMapList(song_lyricsauthorsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song_lyricsAuthors]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnSong_lyricsAuthors.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Song_lyricsAuthors.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnSong_lyricsAuthors.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Song_lyricsAuthorsFilterBuilder

// region Song_lyricsAuthorsFields
class Song_lyricsAuthorsFields {
  static TableField _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }

  static TableField _fAuthorsId;
  static TableField get authorsId {
    return _fAuthorsId = _fAuthorsId ??
        SqlSyntax.setField(_fAuthorsId, 'authorsId', DbType.integer);
  }
}
// endregion Song_lyricsAuthorsFields

//region Song_lyricsAuthorsManager
class Song_lyricsAuthorsManager extends SqfEntityProvider {
  Song_lyricsAuthorsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'song_lyricsAuthors';
  static final List<String> _primaryKeyList = ['song_lyricsId', 'authorsId'];
  static final String _whereStr = 'song_lyricsId=? AND authorsId=?';
}

//endregion Song_lyricsAuthorsManager
// region Song_lyricsPlaylists
class Song_lyricsPlaylists {
  Song_lyricsPlaylists({this.song_lyricsId, this.playlistsId}) {
    _setDefaultValues();
  }
  Song_lyricsPlaylists.withFields(this.song_lyricsId, this.playlistsId) {
    _setDefaultValues();
  }
  Song_lyricsPlaylists.withId(this.song_lyricsId, this.playlistsId) {
    _setDefaultValues();
  }
  Song_lyricsPlaylists.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    playlistsId = int.tryParse(o['playlistsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyricEntity = o['songLyricEntity'] != null
        ? SongLyricEntity.fromMap(o['songLyricEntity'] as Map<String, dynamic>)
        : null;
    plPlaylistEntity = o['playlistEntity'] != null
        ? PlaylistEntity.fromMap(o['playlistEntity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Song_lyricsPlaylists)
  int song_lyricsId;
  int playlistsId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Song_lyricsPlaylists)

// RELATIONSHIPS (Song_lyricsPlaylists)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntity', 'plField2'..]) or so on..
  SongLyricEntity plSongLyricEntity;

  /// get SongLyricEntity By Song_lyricsId
  Future<SongLyricEntity> getSongLyricEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await SongLyricEntity().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plPlaylistEntity', 'plField2'..]) or so on..
  PlaylistEntity plPlaylistEntity;

  /// get PlaylistEntity By PlaylistsId
  Future<PlaylistEntity> getPlaylistEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await PlaylistEntity().getById(playlistsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Song_lyricsPlaylists)

  static const bool _softDeleteActivated = false;
  Song_lyricsPlaylistsManager __mnSong_lyricsPlaylists;

  Song_lyricsPlaylistsManager get _mnSong_lyricsPlaylists {
    return __mnSong_lyricsPlaylists =
        __mnSong_lyricsPlaylists ?? Song_lyricsPlaylistsManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    if (playlistsId != null) {
      map['playlistsId'] = forView ? plPlaylistEntity.name : playlistsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    if (playlistsId != null) {
      map['playlistsId'] = forView ? plPlaylistEntity.name : playlistsId;
    }

    return map;
  }

  /// This method returns Json String [Song_lyricsPlaylists]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song_lyricsPlaylists]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [song_lyricsId, playlistsId];
  }

  List<dynamic> toArgsWithIds() {
    return [song_lyricsId, playlistsId];
  }

  static Future<List<Song_lyricsPlaylists>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Song_lyricsPlaylists.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Song_lyricsPlaylists>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song_lyricsPlaylists>[];
    try {
      objList = list
          .map((song_lyricsplaylists) => Song_lyricsPlaylists.fromMap(
              song_lyricsplaylists as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR Song_lyricsPlaylists.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song_lyricsPlaylists>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song_lyricsPlaylists> objList = <Song_lyricsPlaylists>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song_lyricsPlaylists.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('playlists.plPlaylistEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylistEntity'))) {
          /*_loadedFields.add('playlists.plPlaylistEntity');*/
          obj.plPlaylistEntity = obj.plPlaylistEntity ??
              await obj.getPlaylistEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song_lyricsPlaylists by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int song_lyricsId, int playlistsId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Song_lyricsPlaylists if exist, otherwise returns null
  Future<Song_lyricsPlaylists> getById(int song_lyricsId, int playlistsId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (song_lyricsId == null) {
      return null;
    }
    Song_lyricsPlaylists obj;
    final data =
        await _mnSong_lyricsPlaylists.getById([song_lyricsId, playlistsId]);
    if (data.length != 0) {
      obj = Song_lyricsPlaylists.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('playlists.plPlaylistEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylistEntity'))) {
          /*_loadedFields.add('playlists.plPlaylistEntity');*/
          obj.plPlaylistEntity = obj.plPlaylistEntity ??
              await obj.getPlaylistEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song_lyricsPlaylists) object. If the Primary Key (song_lyricsId) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same song_lyricsId

  /// <returns>Returns BoolResult
  Future<BoolResult> save() async {
    final result = BoolResult(success: false);
    try {
      await _mnSong_lyricsPlaylists.rawInsert(
          'INSERT ${isSaved ? 'OR REPLACE' : ''} INTO song_lyricsPlaylists (song_lyricsId, playlistsId)  VALUES (?,?)',
          toArgsWithIds());
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Song_lyricsPlaylists> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Song_lyricsPlaylists> song_lyricsplaylistses) async {
    // final results = _mnSong_lyricsPlaylists.saveAll('INSERT OR REPLACE INTO song_lyricsPlaylists (song_lyricsId, playlistsId)  VALUES (?,?)',song_lyricsplaylistses);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in song_lyricsplaylistses) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns 1
  Future<int> upsert() async {
    try {
      if (await _mnSong_lyricsPlaylists.rawInsert(
              'INSERT OR REPLACE INTO song_lyricsPlaylists (song_lyricsId, playlistsId)  VALUES (?,?)',
              [song_lyricsId, playlistsId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Song_lyricsPlaylists song_lyricsId=$song_lyricsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Song_lyricsPlaylists song_lyricsId=$song_lyricsId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'Song_lyricsPlaylists Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Song_lyricsPlaylists>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<Song_lyricsPlaylists> song_lyricsplaylistses) async {
    final results = await _mnSong_lyricsPlaylists.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyricsPlaylists (song_lyricsId, playlistsId)  VALUES (?,?)',
        song_lyricsplaylistses);
    return results;
  }

  /// Deletes Song_lyricsPlaylists

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete Song_lyricsPlaylists invoked (song_lyricsId=$song_lyricsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong_lyricsPlaylists.delete(QueryParams(
          whereString: 'song_lyricsId=? AND playlistsId=?',
          whereArguments: [song_lyricsId, playlistsId]));
    } else {
      return _mnSong_lyricsPlaylists.updateBatch(
          QueryParams(
              whereString: 'song_lyricsId=? AND playlistsId=?',
              whereArguments: [song_lyricsId, playlistsId]),
          {'isDeleted': 1});
    }
  }

  Song_lyricsPlaylistsFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return Song_lyricsPlaylistsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  Song_lyricsPlaylistsFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return Song_lyricsPlaylistsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion song_lyricsplaylists

// region Song_lyricsPlaylistsField
class Song_lyricsPlaylistsField extends SearchCriteria {
  Song_lyricsPlaylistsField(this.song_lyricsplaylistsFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  Song_lyricsPlaylistsFilterBuilder song_lyricsplaylistsFB;

  Song_lyricsPlaylistsField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  Song_lyricsPlaylistsFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    song_lyricsplaylistsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.EQuals, song_lyricsplaylistsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.NotEQuals, song_lyricsplaylistsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    song_lyricsplaylistsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.EQualsOrNull, song_lyricsplaylistsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, song_lyricsplaylistsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder isNull() {
    song_lyricsplaylistsFB._addedBlocks = setCriteria(
        0,
        song_lyricsplaylistsFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricsplaylistsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      song_lyricsplaylistsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          song_lyricsplaylistsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsplaylistsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsplaylistsFB
              ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
          song_lyricsplaylistsFB._addedBlocks.retVal;
    }
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricsplaylistsFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          song_lyricsplaylistsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsplaylistsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsplaylistsFB
              ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
          song_lyricsplaylistsFB._addedBlocks.retVal;
      song_lyricsplaylistsFB
              ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
          song_lyricsplaylistsFB._addedBlocks.retVal;
    }
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricsplaylistsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          song_lyricsplaylistsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsplaylistsFB._addedBlocks);
      _waitingNot = '';
      song_lyricsplaylistsFB
              ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
          song_lyricsplaylistsFB._addedBlocks.retVal;
    }
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      song_lyricsplaylistsFB._addedBlocks = setCriteria(
          pFirst,
          song_lyricsplaylistsFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricsplaylistsFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        song_lyricsplaylistsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricsplaylistsFB.parameters,
            param,
            SqlSyntax.LessThan,
            song_lyricsplaylistsFB._addedBlocks);
      } else {
        song_lyricsplaylistsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricsplaylistsFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            song_lyricsplaylistsFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        song_lyricsplaylistsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricsplaylistsFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            song_lyricsplaylistsFB._addedBlocks);
      } else {
        song_lyricsplaylistsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricsplaylistsFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            song_lyricsplaylistsFB._addedBlocks);
      }
    }
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    song_lyricsplaylistsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricsplaylistsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricsplaylistsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    song_lyricsplaylistsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricsplaylistsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricsplaylistsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    song_lyricsplaylistsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricsplaylistsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricsplaylistsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    song_lyricsplaylistsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricsplaylistsFB._addedBlocks)
        : setCriteria(pValue, song_lyricsplaylistsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricsplaylistsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }

  Song_lyricsPlaylistsFilterBuilder inValues(dynamic pValue) {
    song_lyricsplaylistsFB._addedBlocks = setCriteria(
        pValue,
        song_lyricsplaylistsFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricsplaylistsFB._addedBlocks);
    _waitingNot = '';
    song_lyricsplaylistsFB
            ._addedBlocks.needEndBlock[song_lyricsplaylistsFB._blockIndex] =
        song_lyricsplaylistsFB._addedBlocks.retVal;
    return song_lyricsplaylistsFB;
  }
}
// endregion Song_lyricsPlaylistsField

// region Song_lyricsPlaylistsFilterBuilder
class Song_lyricsPlaylistsFilterBuilder extends SearchCriteria {
  Song_lyricsPlaylistsFilterBuilder(Song_lyricsPlaylists obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Song_lyricsPlaylists _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  Song_lyricsPlaylistsFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  Song_lyricsPlaylistsFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  Song_lyricsPlaylistsFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  Song_lyricsPlaylistsFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  Song_lyricsPlaylistsFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  Song_lyricsPlaylistsFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  Song_lyricsPlaylistsFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsPlaylistsFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsPlaylistsFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsPlaylistsFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsPlaylistsFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  Song_lyricsPlaylistsField setField(
      Song_lyricsPlaylistsField field, String colName, DbType dbtype) {
    return Song_lyricsPlaylistsField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  Song_lyricsPlaylistsField _song_lyricsId;
  Song_lyricsPlaylistsField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  Song_lyricsPlaylistsField _playlistsId;
  Song_lyricsPlaylistsField get playlistsId {
    return _playlistsId = setField(_playlistsId, 'playlistsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Song_lyricsPlaylists._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Song_lyricsPlaylists> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Song_lyricsPlaylists._softDeleteActivated && !hardDelete) {
      r = await _obj._mnSong_lyricsPlaylists
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnSong_lyricsPlaylists.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'song_lyricsId IN (SELECT song_lyricsId from song_lyricsPlaylists ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnSong_lyricsPlaylists.updateBatch(qparams, values);
  }

  /// This method always returns Song_lyricsPlaylists Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsPlaylists>
  Future<Song_lyricsPlaylists> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnSong_lyricsPlaylists.toList(qparams);
    final data = await objFuture;
    Song_lyricsPlaylists obj;
    if (data.isNotEmpty) {
      obj = Song_lyricsPlaylists.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('playlists.plPlaylistEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylistEntity'))) {
          /*_loadedFields.add('playlists.plPlaylistEntity');*/
          obj.plPlaylistEntity = obj.plPlaylistEntity ??
              await obj.getPlaylistEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Song_lyricsPlaylists]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) song_lyricsplaylistsCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final song_lyricsplaylistsesFuture =
        await _obj._mnSong_lyricsPlaylists.toList(qparams);
    final int count = song_lyricsplaylistsesFuture[0]['CNT'] as int;
    if (song_lyricsplaylistsCount != null) {
      song_lyricsplaylistsCount(count);
    }
    return count;
  }

  /// This method returns List<Song_lyricsPlaylists> [Song_lyricsPlaylists]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsPlaylists>
  Future<List<Song_lyricsPlaylists>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Song_lyricsPlaylists> song_lyricsplaylistsesData =
        await Song_lyricsPlaylists.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return song_lyricsplaylistsesData;
  }

  /// This method returns Json String [Song_lyricsPlaylists]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song_lyricsPlaylists]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song_lyricsPlaylists]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnSong_lyricsPlaylists.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song_lyricsPlaylists]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `song_lyricsId`playlistsId` FROM song_lyricsPlaylists WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<song_lyricsId,playlistsId> [Song_lyricsPlaylists]
  /// <returns>List<song_lyricsId,playlistsId>
  Future<List<Song_lyricsPlaylists>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['song_lyricsId', 'playlistsId'];
    final song_lyricsplaylistsFuture =
        await _obj._mnSong_lyricsPlaylists.toList(qparams);
    return await Song_lyricsPlaylists.fromMapList(song_lyricsplaylistsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song_lyricsPlaylists]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnSong_lyricsPlaylists.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Song_lyricsPlaylists.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnSong_lyricsPlaylists.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Song_lyricsPlaylistsFilterBuilder

// region Song_lyricsPlaylistsFields
class Song_lyricsPlaylistsFields {
  static TableField _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }

  static TableField _fPlaylistsId;
  static TableField get playlistsId {
    return _fPlaylistsId = _fPlaylistsId ??
        SqlSyntax.setField(_fPlaylistsId, 'playlistsId', DbType.integer);
  }
}
// endregion Song_lyricsPlaylistsFields

//region Song_lyricsPlaylistsManager
class Song_lyricsPlaylistsManager extends SqfEntityProvider {
  Song_lyricsPlaylistsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'song_lyricsPlaylists';
  static final List<String> _primaryKeyList = ['song_lyricsId', 'playlistsId'];
  static final String _whereStr = 'song_lyricsId=? AND playlistsId=?';
}

//endregion Song_lyricsPlaylistsManager
// region Song_lyricsTags
class Song_lyricsTags {
  Song_lyricsTags({this.song_lyricsId, this.tagsId}) {
    _setDefaultValues();
  }
  Song_lyricsTags.withFields(this.song_lyricsId, this.tagsId) {
    _setDefaultValues();
  }
  Song_lyricsTags.withId(this.song_lyricsId, this.tagsId) {
    _setDefaultValues();
  }
  Song_lyricsTags.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    tagsId = int.tryParse(o['tagsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyricEntity = o['songLyricEntity'] != null
        ? SongLyricEntity.fromMap(o['songLyricEntity'] as Map<String, dynamic>)
        : null;
    plTagEntity = o['tagEntity'] != null
        ? TagEntity.fromMap(o['tagEntity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Song_lyricsTags)
  int song_lyricsId;
  int tagsId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Song_lyricsTags)

// RELATIONSHIPS (Song_lyricsTags)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plSongLyricEntity', 'plField2'..]) or so on..
  SongLyricEntity plSongLyricEntity;

  /// get SongLyricEntity By Song_lyricsId
  Future<SongLyricEntity> getSongLyricEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await SongLyricEntity().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTagEntity', 'plField2'..]) or so on..
  TagEntity plTagEntity;

  /// get TagEntity By TagsId
  Future<TagEntity> getTagEntity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await TagEntity()
        .getById(tagsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Song_lyricsTags)

  static const bool _softDeleteActivated = false;
  Song_lyricsTagsManager __mnSong_lyricsTags;

  Song_lyricsTagsManager get _mnSong_lyricsTags {
    return __mnSong_lyricsTags =
        __mnSong_lyricsTags ?? Song_lyricsTagsManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    if (tagsId != null) {
      map['tagsId'] = forView ? plTagEntity.name : tagsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView ? plSongLyricEntity.name : song_lyricsId;
    }

    if (tagsId != null) {
      map['tagsId'] = forView ? plTagEntity.name : tagsId;
    }

    return map;
  }

  /// This method returns Json String [Song_lyricsTags]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song_lyricsTags]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [song_lyricsId, tagsId];
  }

  List<dynamic> toArgsWithIds() {
    return [song_lyricsId, tagsId];
  }

  static Future<List<Song_lyricsTags>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Song_lyricsTags.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Song_lyricsTags>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song_lyricsTags>[];
    try {
      objList = list
          .map((song_lyricstags) =>
              Song_lyricsTags.fromMap(song_lyricstags as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR Song_lyricsTags.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song_lyricsTags>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song_lyricsTags> objList = <Song_lyricsTags>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song_lyricsTags.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plTagEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTagEntity'))) {
          /*_loadedFields.add('tags.plTagEntity');*/
          obj.plTagEntity = obj.plTagEntity ??
              await obj.getTagEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song_lyricsTags by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int song_lyricsId, int tagsId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Song_lyricsTags if exist, otherwise returns null
  Future<Song_lyricsTags> getById(int song_lyricsId, int tagsId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (song_lyricsId == null) {
      return null;
    }
    Song_lyricsTags obj;
    final data = await _mnSong_lyricsTags.getById([song_lyricsId, tagsId]);
    if (data.length != 0) {
      obj = Song_lyricsTags.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plTagEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTagEntity'))) {
          /*_loadedFields.add('tags.plTagEntity');*/
          obj.plTagEntity = obj.plTagEntity ??
              await obj.getTagEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song_lyricsTags) object. If the Primary Key (song_lyricsId) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same song_lyricsId

  /// <returns>Returns BoolResult
  Future<BoolResult> save() async {
    final result = BoolResult(success: false);
    try {
      await _mnSong_lyricsTags.rawInsert(
          'INSERT ${isSaved ? 'OR REPLACE' : ''} INTO song_lyricsTags (song_lyricsId, tagsId)  VALUES (?,?)',
          toArgsWithIds());
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Song_lyricsTags> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Song_lyricsTags> song_lyricstagses) async {
    // final results = _mnSong_lyricsTags.saveAll('INSERT OR REPLACE INTO song_lyricsTags (song_lyricsId, tagsId)  VALUES (?,?)',song_lyricstagses);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Model().batchStart();
    for (final obj in song_lyricstagses) {
      await obj.save();
    }
    //    return Model().batchCommit();
    final result = await Model().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns 1
  Future<int> upsert() async {
    try {
      if (await _mnSong_lyricsTags.rawInsert(
              'INSERT OR REPLACE INTO song_lyricsTags (song_lyricsId, tagsId)  VALUES (?,?)',
              [song_lyricsId, tagsId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Song_lyricsTags song_lyricsId=$song_lyricsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Song_lyricsTags song_lyricsId=$song_lyricsId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Song_lyricsTags Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Song_lyricsTags>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<Song_lyricsTags> song_lyricstagses) async {
    final results = await _mnSong_lyricsTags.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyricsTags (song_lyricsId, tagsId)  VALUES (?,?)',
        song_lyricstagses);
    return results;
  }

  /// Deletes Song_lyricsTags

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete Song_lyricsTags invoked (song_lyricsId=$song_lyricsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong_lyricsTags.delete(QueryParams(
          whereString: 'song_lyricsId=? AND tagsId=?',
          whereArguments: [song_lyricsId, tagsId]));
    } else {
      return _mnSong_lyricsTags.updateBatch(
          QueryParams(
              whereString: 'song_lyricsId=? AND tagsId=?',
              whereArguments: [song_lyricsId, tagsId]),
          {'isDeleted': 1});
    }
  }

  Song_lyricsTagsFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return Song_lyricsTagsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  Song_lyricsTagsFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return Song_lyricsTagsFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion song_lyricstags

// region Song_lyricsTagsField
class Song_lyricsTagsField extends SearchCriteria {
  Song_lyricsTagsField(this.song_lyricstagsFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  Song_lyricsTagsFilterBuilder song_lyricstagsFB;

  Song_lyricsTagsField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  Song_lyricsTagsFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.EQuals, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.NotEQuals, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.EQualsOrNull, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder isNull() {
    song_lyricstagsFB._addedBlocks = setCriteria(
        0,
        song_lyricstagsFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      song_lyricstagsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          song_lyricstagsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricstagsFB._addedBlocks);
      _waitingNot = '';
      song_lyricstagsFB
              ._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
          song_lyricstagsFB._addedBlocks.retVal;
    }
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricstagsFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          song_lyricstagsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricstagsFB._addedBlocks);
      _waitingNot = '';
      song_lyricstagsFB
              ._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
          song_lyricstagsFB._addedBlocks.retVal;
      song_lyricstagsFB
              ._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
          song_lyricstagsFB._addedBlocks.retVal;
    }
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      song_lyricstagsFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          song_lyricstagsFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricstagsFB._addedBlocks);
      _waitingNot = '';
      song_lyricstagsFB
              ._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
          song_lyricstagsFB._addedBlocks.retVal;
    }
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      song_lyricstagsFB._addedBlocks = setCriteria(
          pFirst,
          song_lyricstagsFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          song_lyricstagsFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        song_lyricstagsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricstagsFB.parameters,
            param,
            SqlSyntax.LessThan,
            song_lyricstagsFB._addedBlocks);
      } else {
        song_lyricstagsFB._addedBlocks = setCriteria(
            pFirst,
            song_lyricstagsFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            song_lyricstagsFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        song_lyricstagsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricstagsFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            song_lyricstagsFB._addedBlocks);
      } else {
        song_lyricstagsFB._addedBlocks = setCriteria(
            pLast,
            song_lyricstagsFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            song_lyricstagsFB._addedBlocks);
      }
    }
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.LessThan, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    song_lyricstagsFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.LessThanOrEquals, song_lyricstagsFB._addedBlocks)
        : setCriteria(pValue, song_lyricstagsFB.parameters, param,
            SqlSyntax.GreaterThan, song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }

  Song_lyricsTagsFilterBuilder inValues(dynamic pValue) {
    song_lyricstagsFB._addedBlocks = setCriteria(
        pValue,
        song_lyricstagsFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        song_lyricstagsFB._addedBlocks);
    _waitingNot = '';
    song_lyricstagsFB._addedBlocks.needEndBlock[song_lyricstagsFB._blockIndex] =
        song_lyricstagsFB._addedBlocks.retVal;
    return song_lyricstagsFB;
  }
}
// endregion Song_lyricsTagsField

// region Song_lyricsTagsFilterBuilder
class Song_lyricsTagsFilterBuilder extends SearchCriteria {
  Song_lyricsTagsFilterBuilder(Song_lyricsTags obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Song_lyricsTags _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  Song_lyricsTagsFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  Song_lyricsTagsFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  Song_lyricsTagsFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  Song_lyricsTagsFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  Song_lyricsTagsFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  Song_lyricsTagsFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  Song_lyricsTagsFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsTagsFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsTagsFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Song_lyricsTagsFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Song_lyricsTagsFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  Song_lyricsTagsField setField(
      Song_lyricsTagsField field, String colName, DbType dbtype) {
    return Song_lyricsTagsField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  Song_lyricsTagsField _song_lyricsId;
  Song_lyricsTagsField get song_lyricsId {
    return _song_lyricsId =
        setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  Song_lyricsTagsField _tagsId;
  Song_lyricsTagsField get tagsId {
    return _tagsId = setField(_tagsId, 'tagsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Song_lyricsTags._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Song_lyricsTags> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Song_lyricsTags._softDeleteActivated && !hardDelete) {
      r = await _obj._mnSong_lyricsTags.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnSong_lyricsTags.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'song_lyricsId IN (SELECT song_lyricsId from song_lyricsTags ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnSong_lyricsTags.updateBatch(qparams, values);
  }

  /// This method always returns Song_lyricsTags Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsTags>
  Future<Song_lyricsTags> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnSong_lyricsTags.toList(qparams);
    final data = await objFuture;
    Song_lyricsTags obj;
    if (data.isNotEmpty) {
      obj = Song_lyricsTags.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('song_lyrics.plSongLyricEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plSongLyricEntity'))) {
          /*_loadedFields.add('song_lyrics.plSongLyricEntity');*/
          obj.plSongLyricEntity = obj.plSongLyricEntity ??
              await obj.getSongLyricEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plTagEntity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTagEntity'))) {
          /*_loadedFields.add('tags.plTagEntity');*/
          obj.plTagEntity = obj.plTagEntity ??
              await obj.getTagEntity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Song_lyricsTags]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) song_lyricstagsCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final song_lyricstagsesFuture =
        await _obj._mnSong_lyricsTags.toList(qparams);
    final int count = song_lyricstagsesFuture[0]['CNT'] as int;
    if (song_lyricstagsCount != null) {
      song_lyricstagsCount(count);
    }
    return count;
  }

  /// This method returns List<Song_lyricsTags> [Song_lyricsTags]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Song_lyricsTags>
  Future<List<Song_lyricsTags>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Song_lyricsTags> song_lyricstagsesData =
        await Song_lyricsTags.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return song_lyricstagsesData;
  }

  /// This method returns Json String [Song_lyricsTags]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song_lyricsTags]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song_lyricsTags]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnSong_lyricsTags.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song_lyricsTags]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `song_lyricsId`tagsId` FROM song_lyricsTags WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<song_lyricsId,tagsId> [Song_lyricsTags]
  /// <returns>List<song_lyricsId,tagsId>
  Future<List<Song_lyricsTags>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['song_lyricsId', 'tagsId'];
    final song_lyricstagsFuture = await _obj._mnSong_lyricsTags.toList(qparams);
    return await Song_lyricsTags.fromMapList(song_lyricstagsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song_lyricsTags]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnSong_lyricsTags.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Song_lyricsTags.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnSong_lyricsTags.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Song_lyricsTagsFilterBuilder

// region Song_lyricsTagsFields
class Song_lyricsTagsFields {
  static TableField _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }

  static TableField _fTagsId;
  static TableField get tagsId {
    return _fTagsId =
        _fTagsId ?? SqlSyntax.setField(_fTagsId, 'tagsId', DbType.integer);
  }
}
// endregion Song_lyricsTagsFields

//region Song_lyricsTagsManager
class Song_lyricsTagsManager extends SqfEntityProvider {
  Song_lyricsTagsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'song_lyricsTags';
  static final List<String> _primaryKeyList = ['song_lyricsId', 'tagsId'];
  static final String _whereStr = 'song_lyricsId=? AND tagsId=?';
}

//endregion Song_lyricsTagsManager
class ModelSequenceManager extends SqfEntityProvider {
  ModelSequenceManager() : super(Model());
}
// END OF ENTITIES
