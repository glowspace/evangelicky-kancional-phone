// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Author.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Author TABLE
class TableAuthor extends SqfEntityTableBase {
  TableAuthor() {
    // declare properties of EntityTable
    tableName = 'authors';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAuthor();
  }
}

// External TABLE
class TableExternal extends SqfEntityTableBase {
  TableExternal() {
    // declare properties of EntityTable
    tableName = 'externals';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('public_name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('media_id', DbType.text),
      SqfEntityFieldBase('media_type', DbType.text),
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'song_lyricsId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExternal();
  }
}

// Playlist TABLE
class TablePlaylist extends SqfEntityTableBase {
  TablePlaylist() {
    // declare properties of EntityTable
    tableName = 'playlists';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('is_archived', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('rank', DbType.integer, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylist();
  }
}

// PlaylistRecord TABLE
class TablePlaylistRecord extends SqfEntityTableBase {
  TablePlaylistRecord() {
    // declare properties of EntityTable
    tableName = 'playlist_records';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('rank', DbType.integer, isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TablePlaylist.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'playlistsId'),
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'song_lyricsId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylistRecord();
  }
}

// Song TABLE
class TableSong extends SqfEntityTableBase {
  TableSong() {
    // declare properties of EntityTable
    tableName = 'songs';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong();
  }
}

// Songbook TABLE
class TableSongbook extends SqfEntityTableBase {
  TableSongbook() {
    // declare properties of EntityTable
    tableName = 'songbooks';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('shortcut', DbType.text),
      SqfEntityFieldBase('color', DbType.text),
      SqfEntityFieldBase('color_text', DbType.text),
      SqfEntityFieldBase('is_private', DbType.bool, isNotNull: true),
      SqfEntityFieldBase('is_pinned', DbType.bool,
          defaultValue: false, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongbook();
  }
}

// SongbookRecord TABLE
class TableSongbookRecord extends SqfEntityTableBase {
  TableSongbookRecord() {
    // declare properties of EntityTable
    tableName = 'songbook_records';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('number', DbType.text, isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableSongbook.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'songbooksId'),
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'song_lyricsId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongbookRecord();
  }
}

// SongLyric TABLE
class TableSongLyric extends SqfEntityTableBase {
  TableSongLyric() {
    // declare properties of EntityTable
    tableName = 'song_lyrics';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('secondary_name_1', DbType.text),
      SqfEntityFieldBase('secondary_name_2', DbType.text),
      SqfEntityFieldBase('lyrics', DbType.text),
      SqfEntityFieldBase('lang_string', DbType.text),
      SqfEntityFieldBase('type_enum', DbType.text),
      SqfEntityFieldBase('lilypond_svg', DbType.text),
      SqfEntityFieldBase('favorite_rank', DbType.integer),
      SqfEntityFieldBase('transposition', DbType.integer, defaultValue: 0),
      SqfEntityFieldBase('show_chords', DbType.bool),
      SqfEntityFieldBase('accidentals', DbType.integer),
      SqfEntityFieldRelationshipBase(TableSong.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'songsId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSongLyric();
  }
}

// Tag TABLE
class TableTag extends SqfEntityTableBase {
  TableTag() {
    // declare properties of EntityTable
    tableName = 'tags';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('type_enum', DbType.text, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTag();
  }
}

// ExternalsAuthors TABLE
class TableExternalsAuthors extends SqfEntityTableBase {
  TableExternalsAuthors() {
    // declare properties of EntityTable
    tableName = 'externalsAuthors';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableExternal.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'externalsId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(
          TableAuthor.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'authorsId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExternalsAuthors();
  }
}

// Song_lyricsAuthors TABLE
class TableSong_lyricsAuthors extends SqfEntityTableBase {
  TableSong_lyricsAuthors() {
    // declare properties of EntityTable
    tableName = 'song_lyricsAuthors';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(
          TableAuthor.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'authorsId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong_lyricsAuthors();
  }
}

// Song_lyricsTags TABLE
class TableSong_lyricsTags extends SqfEntityTableBase {
  TableSong_lyricsTags() {
    // declare properties of EntityTable
    tableName = 'song_lyricsTags';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableSongLyric.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'song_lyricsId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(TableTag.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'tagsId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSong_lyricsTags();
  }
}
// END TABLES

// BEGIN SEQUENCES
// END SEQUENCES

// BEGIN DATABASE MODEL
class Model extends SqfEntityModelProvider {
  Model() {
    databaseName = model.databaseName;
    password = model.password;
    dbVersion = model.dbVersion;
    preSaveAction = model.preSaveAction;
    logFunction = model.logFunction;
    databaseTables = [
      TableAuthor.getInstance,
      TableExternal.getInstance,
      TablePlaylist.getInstance,
      TablePlaylistRecord.getInstance,
      TableSong.getInstance,
      TableSongbook.getInstance,
      TableSongbookRecord.getInstance,
      TableSongLyric.getInstance,
      TableTag.getInstance,
      TableExternalsAuthors.getInstance,
      TableSong_lyricsAuthors.getInstance,
      TableSong_lyricsTags.getInstance,
    ];

    bundledDatabasePath = model
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = model.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Author
class Author extends TableBase {
  Author({this.id, this.name}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Author.withFields(this.id, this.name) {
    _setDefaultValues();
  }
  Author.withId(this.id, this.name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Author.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Author)
  int? id;
  String? name;
  bool? isSaved;
  // end FIELDS (Author)

// COLLECTIONS & VIRTUALS (Author)
  ///(RelationType.MANY_TO_MANY) (externalsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plExternals', 'plField2'..]) or so on..
  List<External>? plExternals;

  /// get External(s) filtered by externalsId IN externalsAuthors
  ExternalFilterBuilder? getExternals(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return External()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT externalsId FROM externalsAuthors WHERE authorsId=?)',
            parameterValue: id)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (song_lyricsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyrics', 'plField2'..]) or so on..
  List<SongLyric>? plSongLyrics;

  /// get SongLyric(s) filtered by song_lyricsId IN song_lyricsAuthors
  SongLyricFilterBuilder? getSongLyrics(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongLyric()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT song_lyricsId FROM song_lyricsAuthors WHERE authorsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Author)

  static const bool _softDeleteActivated = false;
  AuthorManager? __mnAuthor;

  AuthorManager get _mnAuthor {
    return __mnAuthor = __mnAuthor ?? AuthorManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }

// COLLECTIONS (Author)
    if (!forQuery) {
      map['Externals'] = await getExternals()!.toMapList();
    }
    if (!forQuery) {
      map['SongLyrics'] = await getSongLyrics()!.toMapList();
    }
// END COLLECTIONS (Author)

    return map;
  }

  /// This method returns Json String [Author]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Author]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, name];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name];
  }

  static Future<List<Author>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Author.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Author>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Author>[];
    try {
      objList = list
          .map((author) => Author.fromMap(author as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Author.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Author>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Author> objList = <Author>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Author.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('authors.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('authors.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('authors.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Author by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Author] if exist, otherwise returns null
  Future<Author?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Author? obj;
    final data = await _mnAuthor.getById([id]);
    if (data.length != 0) {
      obj = Author.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('authors.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('authors.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('authors.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Author) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnAuthor.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnAuthor.update(this);
    }

    return id;
  }

  /// Saves the (Author) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnAuthor.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAuthor.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Author> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Author> authors) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in authors) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnAuthor.rawInsert(
          'INSERT OR REPLACE INTO authors (id, name)  VALUES (?,?)',
          [id, name],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Author id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Author id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Author Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Author>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Author> authors) async {
    final results = await _mnAuthor.rawInsertAll(
        'INSERT OR REPLACE INTO authors (id, name)  VALUES (?,?)', authors);
    return results;
  }

  /// Deletes Author

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Author invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnAuthor
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnAuthor.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Author] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  AuthorFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AuthorFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  AuthorFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AuthorFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion author

// region AuthorField
class AuthorField extends FilterBase {
  AuthorField(AuthorFilterBuilder authorFB) : super(authorFB);

  @override
  AuthorFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder isNull() {
    return super.isNull() as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as AuthorFilterBuilder;
  }

  @override
  AuthorField get not {
    return super.not as AuthorField;
  }
}
// endregion AuthorField

// region AuthorFilterBuilder
class AuthorFilterBuilder extends ConjunctionBase {
  AuthorFilterBuilder(Author obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnAuthor = obj._mnAuthor;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  AuthorManager? _mnAuthor;

  /// put the sql keyword 'AND'
  @override
  AuthorFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  AuthorFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  AuthorFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  AuthorFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  AuthorFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  AuthorFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  AuthorFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AuthorFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AuthorFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AuthorFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AuthorFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  AuthorField _setField(AuthorField? field, String colName, DbType dbtype) {
    return AuthorField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  AuthorField? _id;
  AuthorField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  AuthorField? _name;
  AuthorField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  /// Deletes List<Author> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnAuthor!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnAuthor!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from authors ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnAuthor!.updateBatch(qparams, values);
  }

  /// This method always returns [Author] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Author?
  @override
  Future<Author?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnAuthor!.toList(qparams);
    final data = await objFuture;
    Author? obj;
    if (data.isNotEmpty) {
      obj = Author.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('authors.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('authors.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('authors.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('authors.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Author]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Author?
  @override
  Future<Author> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Author();
  }

  /// This method returns int. [Author]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? authorCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final authorsFuture = await _mnAuthor!.toList(qparams);
    final int count = authorsFuture[0]['CNT'] as int;
    if (authorCount != null) {
      authorCount(count);
    }
    return count;
  }

  /// This method returns List<Author> [Author]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Author>
  @override
  Future<List<Author>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Author> authorsData = await Author.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return authorsData;
  }

  /// This method returns Json String [Author]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Author]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Author]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnAuthor!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Author]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM authors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnAuthor!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Author]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnAuthor!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Author.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnAuthor!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AuthorFilterBuilder

// region AuthorFields
class AuthorFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }
}
// endregion AuthorFields

//region AuthorManager
class AuthorManager extends SqfEntityProvider {
  AuthorManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'authors';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion AuthorManager
// region External
class External extends TableBase {
  External(
      {this.id,
      this.public_name,
      this.media_id,
      this.media_type,
      this.song_lyricsId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  External.withFields(this.id, this.public_name, this.media_id, this.media_type,
      this.song_lyricsId) {
    _setDefaultValues();
  }
  External.withId(this.id, this.public_name, this.media_id, this.media_type,
      this.song_lyricsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  External.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['public_name'] != null) {
      public_name = o['public_name'].toString();
    }
    if (o['media_id'] != null) {
      media_id = o['media_id'].toString();
    }
    if (o['media_type'] != null) {
      media_type = o['media_type'].toString();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (External)
  int? id;
  String? public_name;
  String? media_id;
  String? media_type;
  int? song_lyricsId;
  bool? isSaved;
  // end FIELDS (External)

// RELATIONSHIPS (External)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (External)

// COLLECTIONS & VIRTUALS (External)
  ///(RelationType.MANY_TO_MANY) (externalsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAuthors', 'plField2'..]) or so on..
  List<Author>? plAuthors;

  /// get Author(s) filtered by authorsId IN externalsAuthors
  AuthorFilterBuilder? getAuthors(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Author()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT authorsId FROM externalsAuthors WHERE externalsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (External)

  static const bool _softDeleteActivated = false;
  ExternalManager? __mnExternal;

  ExternalManager get _mnExternal {
    return __mnExternal = __mnExternal ?? ExternalManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (public_name != null || !forView) {
      map['public_name'] = public_name;
    }
    if (media_id != null || !forView) {
      map['media_id'] = media_id;
    }
    if (media_type != null || !forView) {
      map['media_type'] = media_type;
    }
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (public_name != null || !forView) {
      map['public_name'] = public_name;
    }
    if (media_id != null || !forView) {
      map['media_id'] = media_id;
    }
    if (media_type != null || !forView) {
      map['media_type'] = media_type;
    }
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }

// COLLECTIONS (External)
    if (!forQuery) {
      map['Authors'] = await getAuthors()!.toMapList();
    }
// END COLLECTIONS (External)

    return map;
  }

  /// This method returns Json String [External]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [External]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, public_name, media_id, media_type, song_lyricsId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, public_name, media_id, media_type, song_lyricsId];
  }

  static Future<List<External>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR External.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<External>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <External>[];
    try {
      objList = list
          .map((external) => External.fromMap(external as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR External.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<External>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<External> objList = <External>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = External.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('externals.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns External by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [External] if exist, otherwise returns null
  Future<External?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    External? obj;
    final data = await _mnExternal.getById([id]);
    if (data.length != 0) {
      obj = External.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('externals.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (External) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnExternal.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnExternal.update(this);
    }

    return id;
  }

  /// Saves the (External) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnExternal.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExternal.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<External> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<External> externals) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in externals) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnExternal.rawInsert(
          'INSERT OR REPLACE INTO externals (id, public_name, media_id, media_type, song_lyricsId)  VALUES (?,?,?,?,?)',
          [id, public_name, media_id, media_type, song_lyricsId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'External id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'External id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'External Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<External>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<External> externals) async {
    final results = await _mnExternal.rawInsertAll(
        'INSERT OR REPLACE INTO externals (id, public_name, media_id, media_type, song_lyricsId)  VALUES (?,?,?,?,?)',
        externals);
    return results;
  }

  /// Deletes External

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete External invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExternal
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnExternal.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [External] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ExternalFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExternalFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ExternalFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExternalFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion external

// region ExternalField
class ExternalField extends FilterBase {
  ExternalField(ExternalFilterBuilder externalFB) : super(externalFB);

  @override
  ExternalFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder isNull() {
    return super.isNull() as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ExternalFilterBuilder;
  }

  @override
  ExternalField get not {
    return super.not as ExternalField;
  }
}
// endregion ExternalField

// region ExternalFilterBuilder
class ExternalFilterBuilder extends ConjunctionBase {
  ExternalFilterBuilder(External obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnExternal = obj._mnExternal;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ExternalManager? _mnExternal;

  /// put the sql keyword 'AND'
  @override
  ExternalFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ExternalFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ExternalFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ExternalFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ExternalFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ExternalFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ExternalFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExternalFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExternalFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExternalFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExternalFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ExternalField _setField(ExternalField? field, String colName, DbType dbtype) {
    return ExternalField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ExternalField? _id;
  ExternalField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ExternalField? _public_name;
  ExternalField get public_name {
    return _public_name = _setField(_public_name, 'public_name', DbType.text);
  }

  ExternalField? _media_id;
  ExternalField get media_id {
    return _media_id = _setField(_media_id, 'media_id', DbType.text);
  }

  ExternalField? _media_type;
  ExternalField get media_type {
    return _media_type = _setField(_media_type, 'media_type', DbType.text);
  }

  ExternalField? _song_lyricsId;
  ExternalField get song_lyricsId {
    return _song_lyricsId =
        _setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  /// Deletes List<External> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnExternal!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnExternal!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from externals ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnExternal!.updateBatch(qparams, values);
  }

  /// This method always returns [External] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> External?
  @override
  Future<External?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnExternal!.toList(qparams);
    final data = await objFuture;
    External? obj;
    if (data.isNotEmpty) {
      obj = External.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('externals.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('externals.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [External]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> External?
  @override
  Future<External> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        External();
  }

  /// This method returns int. [External]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? externalCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final externalsFuture = await _mnExternal!.toList(qparams);
    final int count = externalsFuture[0]['CNT'] as int;
    if (externalCount != null) {
      externalCount(count);
    }
    return count;
  }

  /// This method returns List<External> [External]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<External>
  @override
  Future<List<External>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<External> externalsData = await External.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return externalsData;
  }

  /// This method returns Json String [External]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [External]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [External]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnExternal!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [External]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM externals WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnExternal!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [External]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnExternal!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await External.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnExternal!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExternalFilterBuilder

// region ExternalFields
class ExternalFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fPublic_name;
  static TableField get public_name {
    return _fPublic_name = _fPublic_name ??
        SqlSyntax.setField(_fPublic_name, 'public_name', DbType.text);
  }

  static TableField? _fMedia_id;
  static TableField get media_id {
    return _fMedia_id =
        _fMedia_id ?? SqlSyntax.setField(_fMedia_id, 'media_id', DbType.text);
  }

  static TableField? _fMedia_type;
  static TableField get media_type {
    return _fMedia_type = _fMedia_type ??
        SqlSyntax.setField(_fMedia_type, 'media_type', DbType.text);
  }

  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }
}
// endregion ExternalFields

//region ExternalManager
class ExternalManager extends SqfEntityProvider {
  ExternalManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'externals';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ExternalManager
// region Playlist
class Playlist extends TableBase {
  Playlist({this.id, this.name, this.is_archived, this.rank}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Playlist.withFields(this.name, this.is_archived, this.rank) {
    _setDefaultValues();
  }
  Playlist.withId(this.id, this.name, this.is_archived, this.rank) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Playlist.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['is_archived'] != null) {
      is_archived = o['is_archived'].toString() == '1' ||
          o['is_archived'].toString() == 'true';
    }
    if (o['rank'] != null) {
      rank = int.tryParse(o['rank'].toString());
    }
  }
  // FIELDS (Playlist)
  int? id;
  String? name;
  bool? is_archived;
  int? rank;

  // end FIELDS (Playlist)

// COLLECTIONS & VIRTUALS (Playlist)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPlaylistRecords', 'plField2'..]) or so on..
  List<PlaylistRecord>? plPlaylistRecords;

  /// get PlaylistRecord(s) filtered by id=playlistsId
  PlaylistRecordFilterBuilder? getPlaylistRecords(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return PlaylistRecord()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .playlistsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Playlist)

  static const bool _softDeleteActivated = false;
  PlaylistManager? __mnPlaylist;

  PlaylistManager get _mnPlaylist {
    return __mnPlaylist = __mnPlaylist ?? PlaylistManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (is_archived != null) {
      map['is_archived'] = forQuery ? (is_archived! ? 1 : 0) : is_archived;
    } else if (is_archived != null || !forView) {
      map['is_archived'] = null;
    }
    if (rank != null || !forView) {
      map['rank'] = rank;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (is_archived != null) {
      map['is_archived'] = forQuery ? (is_archived! ? 1 : 0) : is_archived;
    } else if (is_archived != null || !forView) {
      map['is_archived'] = null;
    }
    if (rank != null || !forView) {
      map['rank'] = rank;
    }

// COLLECTIONS (Playlist)
    if (!forQuery) {
      map['PlaylistRecords'] = await getPlaylistRecords()!.toMapList();
    }
// END COLLECTIONS (Playlist)

    return map;
  }

  /// This method returns Json String [Playlist]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Playlist]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [name, is_archived, rank];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name, is_archived, rank];
  }

  static Future<List<Playlist>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Playlist.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Playlist>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Playlist>[];
    try {
      objList = list
          .map((playlist) => Playlist.fromMap(playlist as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Playlist.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Playlist>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Playlist> objList = <Playlist>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Playlist.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('playlists.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Playlist by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Playlist] if exist, otherwise returns null
  Future<Playlist?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Playlist? obj;
    final data = await _mnPlaylist.getById([id]);
    if (data.length != 0) {
      obj = Playlist.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('playlists.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Playlist) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPlaylist.insert(this, ignoreBatch);
    } else {
      await _mnPlaylist.update(this);
    }

    return id;
  }

  /// Saves the (Playlist) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPlaylist.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylist.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Playlist. Returns a new Primary Key value of Playlist

  /// <returns>Returns a new Primary Key value of Playlist
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Playlist> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Playlist> playlists) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in playlists) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
      for (int i = 0; i < playlists.length; i++) {
        if (playlists[i].id == null) {
          playlists[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPlaylist.rawInsert(
          'INSERT OR REPLACE INTO playlists (id, name, is_archived, rank)  VALUES (?,?,?,?)',
          [id, name, is_archived, rank],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Playlist id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Playlist id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Playlist Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Playlist>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Playlist> playlists) async {
    final results = await _mnPlaylist.rawInsertAll(
        'INSERT OR REPLACE INTO playlists (id, name, is_archived, rank)  VALUES (?,?,?,?)',
        playlists);
    return results;
  }

  /// Deletes Playlist

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Playlist invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await PlaylistRecord()
          .select()
          .playlistsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylist
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPlaylist.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Playlist] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PlaylistFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PlaylistFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    is_archived = is_archived ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion playlist

// region PlaylistField
class PlaylistField extends FilterBase {
  PlaylistField(PlaylistFilterBuilder playlistFB) : super(playlistFB);

  @override
  PlaylistFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder isNull() {
    return super.isNull() as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistField get not {
    return super.not as PlaylistField;
  }
}
// endregion PlaylistField

// region PlaylistFilterBuilder
class PlaylistFilterBuilder extends ConjunctionBase {
  PlaylistFilterBuilder(Playlist obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPlaylist = obj._mnPlaylist;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PlaylistManager? _mnPlaylist;

  /// put the sql keyword 'AND'
  @override
  PlaylistFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PlaylistFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PlaylistFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PlaylistFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PlaylistFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PlaylistFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PlaylistFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PlaylistFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PlaylistFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PlaylistFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PlaylistFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PlaylistField _setField(PlaylistField? field, String colName, DbType dbtype) {
    return PlaylistField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PlaylistField? _id;
  PlaylistField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  PlaylistField? _name;
  PlaylistField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  PlaylistField? _is_archived;
  PlaylistField get is_archived {
    return _is_archived = _setField(_is_archived, 'is_archived', DbType.bool);
  }

  PlaylistField? _rank;
  PlaylistField get rank {
    return _rank = _setField(_rank, 'rank', DbType.integer);
  }

  /// Deletes List<Playlist> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (PlaylistRecord) according to DeleteRule.CASCADE
    final idListPlaylistRecordBYplaylistsId = toListPrimaryKeySQL(false);
    final resPlaylistRecordBYplaylistsId = await PlaylistRecord()
        .select()
        .where('playlistsId IN (${idListPlaylistRecordBYplaylistsId['sql']})',
            parameterValue: idListPlaylistRecordBYplaylistsId['args'])
        .delete(hardDelete);
    if (!resPlaylistRecordBYplaylistsId.success) {
      return resPlaylistRecordBYplaylistsId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPlaylist!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPlaylist!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from playlists ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPlaylist!.updateBatch(qparams, values);
  }

  /// This method always returns [Playlist] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Playlist?
  @override
  Future<Playlist?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPlaylist!.toList(qparams);
    final data = await objFuture;
    Playlist? obj;
    if (data.isNotEmpty) {
      obj = Playlist.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('playlists.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('playlists.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Playlist]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Playlist?
  @override
  Future<Playlist> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Playlist();
  }

  /// This method returns int. [Playlist]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? playlistCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlistsFuture = await _mnPlaylist!.toList(qparams);
    final int count = playlistsFuture[0]['CNT'] as int;
    if (playlistCount != null) {
      playlistCount(count);
    }
    return count;
  }

  /// This method returns List<Playlist> [Playlist]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Playlist>
  @override
  Future<List<Playlist>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Playlist> playlistsData = await Playlist.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return playlistsData;
  }

  /// This method returns Json String [Playlist]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Playlist]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Playlist]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPlaylist!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Playlist]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM playlists WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnPlaylist!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Playlist]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPlaylist!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Playlist.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPlaylist!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistFilterBuilder

// region PlaylistFields
class PlaylistFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fIs_archived;
  static TableField get is_archived {
    return _fIs_archived = _fIs_archived ??
        SqlSyntax.setField(_fIs_archived, 'is_archived', DbType.bool);
  }

  static TableField? _fRank;
  static TableField get rank {
    return _fRank =
        _fRank ?? SqlSyntax.setField(_fRank, 'rank', DbType.integer);
  }
}
// endregion PlaylistFields

//region PlaylistManager
class PlaylistManager extends SqfEntityProvider {
  PlaylistManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'playlists';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PlaylistManager
// region PlaylistRecord
class PlaylistRecord extends TableBase {
  PlaylistRecord({this.id, this.rank, this.playlistsId, this.song_lyricsId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  PlaylistRecord.withFields(this.rank, this.playlistsId, this.song_lyricsId) {
    _setDefaultValues();
  }
  PlaylistRecord.withId(
      this.id, this.rank, this.playlistsId, this.song_lyricsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PlaylistRecord.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['rank'] != null) {
      rank = int.tryParse(o['rank'].toString());
    }
    playlistsId = int.tryParse(o['playlistsId'].toString());

    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    // RELATIONSHIPS FromMAP
    plPlaylist = o['playlist'] != null
        ? Playlist.fromMap(o['playlist'] as Map<String, dynamic>)
        : null;
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (PlaylistRecord)
  int? id;
  int? rank;
  int? playlistsId;
  int? song_lyricsId;

  // end FIELDS (PlaylistRecord)

// RELATIONSHIPS (PlaylistRecord)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPlaylist', 'plField2'..]) or so on..
  Playlist? plPlaylist;

  /// get Playlist By PlaylistsId
  Future<Playlist?> getPlaylist(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Playlist().getById(playlistsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (PlaylistRecord)

  static const bool _softDeleteActivated = false;
  PlaylistRecordManager? __mnPlaylistRecord;

  PlaylistRecordManager get _mnPlaylistRecord {
    return __mnPlaylistRecord = __mnPlaylistRecord ?? PlaylistRecordManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (rank != null || !forView) {
      map['rank'] = rank;
    }
    if (playlistsId != null) {
      map['playlistsId'] = forView
          ? plPlaylist == null
              ? playlistsId
              : plPlaylist!.name
          : playlistsId;
    } else if (playlistsId != null || !forView) {
      map['playlistsId'] = null;
    }
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (rank != null || !forView) {
      map['rank'] = rank;
    }
    if (playlistsId != null) {
      map['playlistsId'] = forView
          ? plPlaylist == null
              ? playlistsId
              : plPlaylist!.name
          : playlistsId;
    } else if (playlistsId != null || !forView) {
      map['playlistsId'] = null;
    }
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }

    return map;
  }

  /// This method returns Json String [PlaylistRecord]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PlaylistRecord]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [rank, playlistsId, song_lyricsId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, rank, playlistsId, song_lyricsId];
  }

  static Future<List<PlaylistRecord>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PlaylistRecord.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PlaylistRecord>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PlaylistRecord>[];
    try {
      objList = list
          .map((playlistrecord) =>
              PlaylistRecord.fromMap(playlistrecord as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PlaylistRecord.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PlaylistRecord>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PlaylistRecord> objList = <PlaylistRecord>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PlaylistRecord.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          obj.plPlaylist =
              obj.plPlaylist ?? await obj.getPlaylist(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PlaylistRecord by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [PlaylistRecord] if exist, otherwise returns null
  Future<PlaylistRecord?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    PlaylistRecord? obj;
    final data = await _mnPlaylistRecord.getById([id]);
    if (data.length != 0) {
      obj = PlaylistRecord.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          obj.plPlaylist =
              obj.plPlaylist ?? await obj.getPlaylist(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PlaylistRecord) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPlaylistRecord.insert(this, ignoreBatch);
    } else {
      await _mnPlaylistRecord.update(this);
    }

    return id;
  }

  /// Saves the (PlaylistRecord) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnPlaylistRecord.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylistRecord.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs PlaylistRecord. Returns a new Primary Key value of PlaylistRecord

  /// <returns>Returns a new Primary Key value of PlaylistRecord
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<PlaylistRecord> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<PlaylistRecord> playlistrecords) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in playlistrecords) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
      for (int i = 0; i < playlistrecords.length; i++) {
        if (playlistrecords[i].id == null) {
          playlistrecords[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPlaylistRecord.rawInsert(
          'INSERT OR REPLACE INTO playlist_records (id, rank, playlistsId, song_lyricsId)  VALUES (?,?,?,?)',
          [id, rank, playlistsId, song_lyricsId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'PlaylistRecord id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PlaylistRecord id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PlaylistRecord Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<PlaylistRecord>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<PlaylistRecord> playlistrecords) async {
    final results = await _mnPlaylistRecord.rawInsertAll(
        'INSERT OR REPLACE INTO playlist_records (id, rank, playlistsId, song_lyricsId)  VALUES (?,?,?,?)',
        playlistrecords);
    return results;
  }

  /// Deletes PlaylistRecord

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete PlaylistRecord invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylistRecord
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPlaylistRecord.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [PlaylistRecord] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PlaylistRecordFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistRecordFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PlaylistRecordFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistRecordFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion playlistrecord

// region PlaylistRecordField
class PlaylistRecordField extends FilterBase {
  PlaylistRecordField(PlaylistRecordFilterBuilder playlistrecordFB)
      : super(playlistrecordFB);

  @override
  PlaylistRecordFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder isNull() {
    return super.isNull() as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PlaylistRecordFilterBuilder;
  }

  @override
  PlaylistRecordField get not {
    return super.not as PlaylistRecordField;
  }
}
// endregion PlaylistRecordField

// region PlaylistRecordFilterBuilder
class PlaylistRecordFilterBuilder extends ConjunctionBase {
  PlaylistRecordFilterBuilder(PlaylistRecord obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPlaylistRecord = obj._mnPlaylistRecord;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PlaylistRecordManager? _mnPlaylistRecord;

  /// put the sql keyword 'AND'
  @override
  PlaylistRecordFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PlaylistRecordFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PlaylistRecordFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PlaylistRecordFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PlaylistRecordFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PlaylistRecordFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PlaylistRecordFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PlaylistRecordFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PlaylistRecordFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PlaylistRecordFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PlaylistRecordFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PlaylistRecordField _setField(
      PlaylistRecordField? field, String colName, DbType dbtype) {
    return PlaylistRecordField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PlaylistRecordField? _id;
  PlaylistRecordField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  PlaylistRecordField? _rank;
  PlaylistRecordField get rank {
    return _rank = _setField(_rank, 'rank', DbType.integer);
  }

  PlaylistRecordField? _playlistsId;
  PlaylistRecordField get playlistsId {
    return _playlistsId =
        _setField(_playlistsId, 'playlistsId', DbType.integer);
  }

  PlaylistRecordField? _song_lyricsId;
  PlaylistRecordField get song_lyricsId {
    return _song_lyricsId =
        _setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  /// Deletes List<PlaylistRecord> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPlaylistRecord!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPlaylistRecord!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from playlist_records ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPlaylistRecord!.updateBatch(qparams, values);
  }

  /// This method always returns [PlaylistRecord] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PlaylistRecord?
  @override
  Future<PlaylistRecord?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPlaylistRecord!.toList(qparams);
    final data = await objFuture;
    PlaylistRecord? obj;
    if (data.isNotEmpty) {
      obj = PlaylistRecord.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          obj.plPlaylist =
              obj.plPlaylist ?? await obj.getPlaylist(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [PlaylistRecord]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PlaylistRecord?
  @override
  Future<PlaylistRecord> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        PlaylistRecord();
  }

  /// This method returns int. [PlaylistRecord]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? playlistrecordCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlistrecordsFuture = await _mnPlaylistRecord!.toList(qparams);
    final int count = playlistrecordsFuture[0]['CNT'] as int;
    if (playlistrecordCount != null) {
      playlistrecordCount(count);
    }
    return count;
  }

  /// This method returns List<PlaylistRecord> [PlaylistRecord]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<PlaylistRecord>
  @override
  Future<List<PlaylistRecord>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PlaylistRecord> playlistrecordsData =
        await PlaylistRecord.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return playlistrecordsData;
  }

  /// This method returns Json String [PlaylistRecord]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PlaylistRecord]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PlaylistRecord]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPlaylistRecord!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PlaylistRecord]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM playlist_records WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnPlaylistRecord!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PlaylistRecord]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPlaylistRecord!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await PlaylistRecord.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPlaylistRecord!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistRecordFilterBuilder

// region PlaylistRecordFields
class PlaylistRecordFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fRank;
  static TableField get rank {
    return _fRank =
        _fRank ?? SqlSyntax.setField(_fRank, 'rank', DbType.integer);
  }

  static TableField? _fPlaylistsId;
  static TableField get playlistsId {
    return _fPlaylistsId = _fPlaylistsId ??
        SqlSyntax.setField(_fPlaylistsId, 'playlistsId', DbType.integer);
  }

  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }
}
// endregion PlaylistRecordFields

//region PlaylistRecordManager
class PlaylistRecordManager extends SqfEntityProvider {
  PlaylistRecordManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'playlist_records';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PlaylistRecordManager
// region Song
class Song extends TableBase {
  Song({this.id, this.name}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Song.withFields(this.id, this.name) {
    _setDefaultValues();
  }
  Song.withId(this.id, this.name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Song.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Song)
  int? id;
  String? name;
  bool? isSaved;
  // end FIELDS (Song)

// COLLECTIONS & VIRTUALS (Song)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyrics', 'plField2'..]) or so on..
  List<SongLyric>? plSongLyrics;

  /// get SongLyric(s) filtered by id=songsId
  SongLyricFilterBuilder? getSongLyrics(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongLyric()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .songsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Song)

  static const bool _softDeleteActivated = false;
  SongManager? __mnSong;

  SongManager get _mnSong {
    return __mnSong = __mnSong ?? SongManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }

// COLLECTIONS (Song)
    if (!forQuery) {
      map['SongLyrics'] = await getSongLyrics()!.toMapList();
    }
// END COLLECTIONS (Song)

    return map;
  }

  /// This method returns Json String [Song]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, name];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name];
  }

  static Future<List<Song>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Song>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song>[];
    try {
      objList = list
          .map((song) => Song.fromMap(song as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song> objList = <Song>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('songs.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Song] if exist, otherwise returns null
  Future<Song?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Song? obj;
    final data = await _mnSong.getById([id]);
    if (data.length != 0) {
      obj = Song.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('songs.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSong.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnSong.update(this);
    }

    return id;
  }

  /// Saves the (Song) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSong.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSong.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Song> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Song> songs) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in songs) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSong.rawInsert(
          'INSERT OR REPLACE INTO songs (id, name)  VALUES (?,?)',
          [id, name],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Song id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Song id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Song Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Song>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Song> songs) async {
    final results = await _mnSong.rawInsertAll(
        'INSERT OR REPLACE INTO songs (id, name)  VALUES (?,?)', songs);
    return results;
  }

  /// Deletes Song

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Song invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result =
          await SongLyric().select().songsId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSong.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Song] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SongFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SongFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion song

// region SongField
class SongField extends FilterBase {
  SongField(SongFilterBuilder songFB) : super(songFB);

  @override
  SongFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder isNull() {
    return super.isNull() as SongFilterBuilder;
  }

  @override
  SongFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SongFilterBuilder;
  }

  @override
  SongFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SongFilterBuilder;
  }

  @override
  SongField get not {
    return super.not as SongField;
  }
}
// endregion SongField

// region SongFilterBuilder
class SongFilterBuilder extends ConjunctionBase {
  SongFilterBuilder(Song obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnSong = obj._mnSong;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SongManager? _mnSong;

  /// put the sql keyword 'AND'
  @override
  SongFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SongFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SongFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SongFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SongFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SongFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SongFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SongFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SongFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SongFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SongFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SongField _setField(SongField? field, String colName, DbType dbtype) {
    return SongField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SongField? _id;
  SongField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SongField? _name;
  SongField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  /// Deletes List<Song> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (SongLyric) according to DeleteRule.CASCADE
    final idListSongLyricBYsongsId = toListPrimaryKeySQL(false);
    final resSongLyricBYsongsId = await SongLyric()
        .select()
        .where('songsId IN (${idListSongLyricBYsongsId['sql']})',
            parameterValue: idListSongLyricBYsongsId['args'])
        .delete(hardDelete);
    if (!resSongLyricBYsongsId.success) {
      return resSongLyricBYsongsId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSong!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSong!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from songs ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSong!.updateBatch(qparams, values);
  }

  /// This method always returns [Song] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Song?
  @override
  Future<Song?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSong!.toList(qparams);
    final data = await objFuture;
    Song? obj;
    if (data.isNotEmpty) {
      obj = Song.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songs.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('songs.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Song]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Song?
  @override
  Future<Song> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Song();
  }

  /// This method returns int. [Song]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? songCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songsFuture = await _mnSong!.toList(qparams);
    final int count = songsFuture[0]['CNT'] as int;
    if (songCount != null) {
      songCount(count);
    }
    return count;
  }

  /// This method returns List<Song> [Song]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Song>
  @override
  Future<List<Song>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Song> songsData = await Song.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return songsData;
  }

  /// This method returns Json String [Song]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSong!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM songs WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSong!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSong!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Song.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSong!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongFilterBuilder

// region SongFields
class SongFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }
}
// endregion SongFields

//region SongManager
class SongManager extends SqfEntityProvider {
  SongManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'songs';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SongManager
// region Songbook
class Songbook extends TableBase {
  Songbook(
      {this.id,
      this.name,
      this.shortcut,
      this.color,
      this.color_text,
      this.is_private,
      this.is_pinned}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Songbook.withFields(this.id, this.name, this.shortcut, this.color,
      this.color_text, this.is_private, this.is_pinned) {
    _setDefaultValues();
  }
  Songbook.withId(this.id, this.name, this.shortcut, this.color,
      this.color_text, this.is_private, this.is_pinned) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Songbook.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['shortcut'] != null) {
      shortcut = o['shortcut'].toString();
    }
    if (o['color'] != null) {
      color = o['color'].toString();
    }
    if (o['color_text'] != null) {
      color_text = o['color_text'].toString();
    }
    if (o['is_private'] != null) {
      is_private = o['is_private'].toString() == '1' ||
          o['is_private'].toString() == 'true';
    }
    if (o['is_pinned'] != null) {
      is_pinned = o['is_pinned'].toString() == '1' ||
          o['is_pinned'].toString() == 'true';
    }

    isSaved = true;
  }
  // FIELDS (Songbook)
  int? id;
  String? name;
  String? shortcut;
  String? color;
  String? color_text;
  bool? is_private;
  bool? is_pinned;
  bool? isSaved;
  // end FIELDS (Songbook)

// COLLECTIONS & VIRTUALS (Songbook)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongbookRecords', 'plField2'..]) or so on..
  List<SongbookRecord>? plSongbookRecords;

  /// get SongbookRecord(s) filtered by id=songbooksId
  SongbookRecordFilterBuilder? getSongbookRecords(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongbookRecord()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .songbooksId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Songbook)

  static const bool _softDeleteActivated = false;
  SongbookManager? __mnSongbook;

  SongbookManager get _mnSongbook {
    return __mnSongbook = __mnSongbook ?? SongbookManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (shortcut != null || !forView) {
      map['shortcut'] = shortcut;
    }
    if (color != null || !forView) {
      map['color'] = color;
    }
    if (color_text != null || !forView) {
      map['color_text'] = color_text;
    }
    if (is_private != null) {
      map['is_private'] = forQuery ? (is_private! ? 1 : 0) : is_private;
    } else if (is_private != null || !forView) {
      map['is_private'] = null;
    }
    if (is_pinned != null) {
      map['is_pinned'] = forQuery ? (is_pinned! ? 1 : 0) : is_pinned;
    } else if (is_pinned != null || !forView) {
      map['is_pinned'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (shortcut != null || !forView) {
      map['shortcut'] = shortcut;
    }
    if (color != null || !forView) {
      map['color'] = color;
    }
    if (color_text != null || !forView) {
      map['color_text'] = color_text;
    }
    if (is_private != null) {
      map['is_private'] = forQuery ? (is_private! ? 1 : 0) : is_private;
    } else if (is_private != null || !forView) {
      map['is_private'] = null;
    }
    if (is_pinned != null) {
      map['is_pinned'] = forQuery ? (is_pinned! ? 1 : 0) : is_pinned;
    } else if (is_pinned != null || !forView) {
      map['is_pinned'] = null;
    }

// COLLECTIONS (Songbook)
    if (!forQuery) {
      map['SongbookRecords'] = await getSongbookRecords()!.toMapList();
    }
// END COLLECTIONS (Songbook)

    return map;
  }

  /// This method returns Json String [Songbook]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Songbook]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, name, shortcut, color, color_text, is_private, is_pinned];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name, shortcut, color, color_text, is_private, is_pinned];
  }

  static Future<List<Songbook>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Songbook.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Songbook>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Songbook>[];
    try {
      objList = list
          .map((songbook) => Songbook.fromMap(songbook as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Songbook.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Songbook>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Songbook> objList = <Songbook>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Songbook.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('songbooks.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Songbook by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Songbook] if exist, otherwise returns null
  Future<Songbook?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Songbook? obj;
    final data = await _mnSongbook.getById([id]);
    if (data.length != 0) {
      obj = Songbook.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('songbooks.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Songbook) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongbook.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnSongbook.update(this);
    }

    return id;
  }

  /// Saves the (Songbook) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongbook.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongbook.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Songbook> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Songbook> songbooks) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in songbooks) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSongbook.rawInsert(
          'INSERT OR REPLACE INTO songbooks (id, name, shortcut, color, color_text, is_private, is_pinned)  VALUES (?,?,?,?,?,?,?)',
          [id, name, shortcut, color, color_text, is_private, is_pinned],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Songbook id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Songbook id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Songbook Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Songbook>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Songbook> songbooks) async {
    final results = await _mnSongbook.rawInsertAll(
        'INSERT OR REPLACE INTO songbooks (id, name, shortcut, color, color_text, is_private, is_pinned)  VALUES (?,?,?,?,?,?,?)',
        songbooks);
    return results;
  }

  /// Deletes Songbook

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Songbook invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await SongbookRecord()
          .select()
          .songbooksId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongbook
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongbook.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Songbook] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SongbookFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongbookFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SongbookFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongbookFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    is_pinned = is_pinned ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion songbook

// region SongbookField
class SongbookField extends FilterBase {
  SongbookField(SongbookFilterBuilder songbookFB) : super(songbookFB);

  @override
  SongbookFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder isNull() {
    return super.isNull() as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SongbookFilterBuilder;
  }

  @override
  SongbookField get not {
    return super.not as SongbookField;
  }
}
// endregion SongbookField

// region SongbookFilterBuilder
class SongbookFilterBuilder extends ConjunctionBase {
  SongbookFilterBuilder(Songbook obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSongbook = obj._mnSongbook;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SongbookManager? _mnSongbook;

  /// put the sql keyword 'AND'
  @override
  SongbookFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SongbookFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SongbookFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SongbookFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SongbookFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SongbookFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SongbookFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SongbookFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SongbookFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SongbookFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SongbookFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SongbookField _setField(SongbookField? field, String colName, DbType dbtype) {
    return SongbookField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SongbookField? _id;
  SongbookField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SongbookField? _name;
  SongbookField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  SongbookField? _shortcut;
  SongbookField get shortcut {
    return _shortcut = _setField(_shortcut, 'shortcut', DbType.text);
  }

  SongbookField? _color;
  SongbookField get color {
    return _color = _setField(_color, 'color', DbType.text);
  }

  SongbookField? _color_text;
  SongbookField get color_text {
    return _color_text = _setField(_color_text, 'color_text', DbType.text);
  }

  SongbookField? _is_private;
  SongbookField get is_private {
    return _is_private = _setField(_is_private, 'is_private', DbType.bool);
  }

  SongbookField? _is_pinned;
  SongbookField get is_pinned {
    return _is_pinned = _setField(_is_pinned, 'is_pinned', DbType.bool);
  }

  /// Deletes List<Songbook> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (SongbookRecord) according to DeleteRule.CASCADE
    final idListSongbookRecordBYsongbooksId = toListPrimaryKeySQL(false);
    final resSongbookRecordBYsongbooksId = await SongbookRecord()
        .select()
        .where('songbooksId IN (${idListSongbookRecordBYsongbooksId['sql']})',
            parameterValue: idListSongbookRecordBYsongbooksId['args'])
        .delete(hardDelete);
    if (!resSongbookRecordBYsongbooksId.success) {
      return resSongbookRecordBYsongbooksId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSongbook!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSongbook!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from songbooks ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSongbook!.updateBatch(qparams, values);
  }

  /// This method always returns [Songbook] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Songbook?
  @override
  Future<Songbook?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSongbook!.toList(qparams);
    final data = await objFuture;
    Songbook? obj;
    if (data.isNotEmpty) {
      obj = Songbook.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('songbooks.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('songbooks.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Songbook]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Songbook?
  @override
  Future<Songbook> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Songbook();
  }

  /// This method returns int. [Songbook]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? songbookCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songbooksFuture = await _mnSongbook!.toList(qparams);
    final int count = songbooksFuture[0]['CNT'] as int;
    if (songbookCount != null) {
      songbookCount(count);
    }
    return count;
  }

  /// This method returns List<Songbook> [Songbook]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Songbook>
  @override
  Future<List<Songbook>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Songbook> songbooksData = await Songbook.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return songbooksData;
  }

  /// This method returns Json String [Songbook]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Songbook]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Songbook]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSongbook!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Songbook]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM songbooks WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSongbook!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Songbook]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSongbook!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Songbook.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSongbook!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongbookFilterBuilder

// region SongbookFields
class SongbookFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fShortcut;
  static TableField get shortcut {
    return _fShortcut =
        _fShortcut ?? SqlSyntax.setField(_fShortcut, 'shortcut', DbType.text);
  }

  static TableField? _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.text);
  }

  static TableField? _fColor_text;
  static TableField get color_text {
    return _fColor_text = _fColor_text ??
        SqlSyntax.setField(_fColor_text, 'color_text', DbType.text);
  }

  static TableField? _fIs_private;
  static TableField get is_private {
    return _fIs_private = _fIs_private ??
        SqlSyntax.setField(_fIs_private, 'is_private', DbType.bool);
  }

  static TableField? _fIs_pinned;
  static TableField get is_pinned {
    return _fIs_pinned = _fIs_pinned ??
        SqlSyntax.setField(_fIs_pinned, 'is_pinned', DbType.bool);
  }
}
// endregion SongbookFields

//region SongbookManager
class SongbookManager extends SqfEntityProvider {
  SongbookManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'songbooks';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SongbookManager
// region SongbookRecord
class SongbookRecord extends TableBase {
  SongbookRecord({this.id, this.number, this.songbooksId, this.song_lyricsId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SongbookRecord.withFields(
      this.id, this.number, this.songbooksId, this.song_lyricsId) {
    _setDefaultValues();
  }
  SongbookRecord.withId(
      this.id, this.number, this.songbooksId, this.song_lyricsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SongbookRecord.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['number'] != null) {
      number = o['number'].toString();
    }
    songbooksId = int.tryParse(o['songbooksId'].toString());

    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongbook = o['songbook'] != null
        ? Songbook.fromMap(o['songbook'] as Map<String, dynamic>)
        : null;
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (SongbookRecord)
  int? id;
  String? number;
  int? songbooksId;
  int? song_lyricsId;
  bool? isSaved;
  // end FIELDS (SongbookRecord)

// RELATIONSHIPS (SongbookRecord)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongbook', 'plField2'..]) or so on..
  Songbook? plSongbook;

  /// get Songbook By SongbooksId
  Future<Songbook?> getSongbook(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Songbook().getById(songbooksId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (SongbookRecord)

  static const bool _softDeleteActivated = false;
  SongbookRecordManager? __mnSongbookRecord;

  SongbookRecordManager get _mnSongbookRecord {
    return __mnSongbookRecord = __mnSongbookRecord ?? SongbookRecordManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (number != null || !forView) {
      map['number'] = number;
    }
    if (songbooksId != null) {
      map['songbooksId'] = forView
          ? plSongbook == null
              ? songbooksId
              : plSongbook!.name
          : songbooksId;
    } else if (songbooksId != null || !forView) {
      map['songbooksId'] = null;
    }
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (number != null || !forView) {
      map['number'] = number;
    }
    if (songbooksId != null) {
      map['songbooksId'] = forView
          ? plSongbook == null
              ? songbooksId
              : plSongbook!.name
          : songbooksId;
    } else if (songbooksId != null || !forView) {
      map['songbooksId'] = null;
    }
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }

    return map;
  }

  /// This method returns Json String [SongbookRecord]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SongbookRecord]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, number, songbooksId, song_lyricsId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, number, songbooksId, song_lyricsId];
  }

  static Future<List<SongbookRecord>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SongbookRecord.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SongbookRecord>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SongbookRecord>[];
    try {
      objList = list
          .map((songbookrecord) =>
              SongbookRecord.fromMap(songbookrecord as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SongbookRecord.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SongbookRecord>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SongbookRecord> objList = <SongbookRecord>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SongbookRecord.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongbook'))) {
          obj.plSongbook =
              obj.plSongbook ?? await obj.getSongbook(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SongbookRecord by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SongbookRecord] if exist, otherwise returns null
  Future<SongbookRecord?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SongbookRecord? obj;
    final data = await _mnSongbookRecord.getById([id]);
    if (data.length != 0) {
      obj = SongbookRecord.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongbook'))) {
          obj.plSongbook =
              obj.plSongbook ?? await obj.getSongbook(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SongbookRecord) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongbookRecord.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnSongbookRecord.update(this);
    }

    return id;
  }

  /// Saves the (SongbookRecord) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongbookRecord.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongbookRecord.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<SongbookRecord> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SongbookRecord> songbookrecords) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in songbookrecords) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSongbookRecord.rawInsert(
          'INSERT OR REPLACE INTO songbook_records (id, number, songbooksId, song_lyricsId)  VALUES (?,?,?,?)',
          [id, number, songbooksId, song_lyricsId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SongbookRecord id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SongbookRecord id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SongbookRecord Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SongbookRecord>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<SongbookRecord> songbookrecords) async {
    final results = await _mnSongbookRecord.rawInsertAll(
        'INSERT OR REPLACE INTO songbook_records (id, number, songbooksId, song_lyricsId)  VALUES (?,?,?,?)',
        songbookrecords);
    return results;
  }

  /// Deletes SongbookRecord

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SongbookRecord invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongbookRecord
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongbookRecord.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SongbookRecord] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SongbookRecordFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongbookRecordFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SongbookRecordFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongbookRecordFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion songbookrecord

// region SongbookRecordField
class SongbookRecordField extends FilterBase {
  SongbookRecordField(SongbookRecordFilterBuilder songbookrecordFB)
      : super(songbookrecordFB);

  @override
  SongbookRecordFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder isNull() {
    return super.isNull() as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SongbookRecordFilterBuilder;
  }

  @override
  SongbookRecordField get not {
    return super.not as SongbookRecordField;
  }
}
// endregion SongbookRecordField

// region SongbookRecordFilterBuilder
class SongbookRecordFilterBuilder extends ConjunctionBase {
  SongbookRecordFilterBuilder(SongbookRecord obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSongbookRecord = obj._mnSongbookRecord;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SongbookRecordManager? _mnSongbookRecord;

  /// put the sql keyword 'AND'
  @override
  SongbookRecordFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SongbookRecordFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SongbookRecordFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SongbookRecordFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SongbookRecordFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SongbookRecordFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SongbookRecordFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SongbookRecordFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SongbookRecordFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SongbookRecordFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SongbookRecordFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SongbookRecordField _setField(
      SongbookRecordField? field, String colName, DbType dbtype) {
    return SongbookRecordField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SongbookRecordField? _id;
  SongbookRecordField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SongbookRecordField? _number;
  SongbookRecordField get number {
    return _number = _setField(_number, 'number', DbType.text);
  }

  SongbookRecordField? _songbooksId;
  SongbookRecordField get songbooksId {
    return _songbooksId =
        _setField(_songbooksId, 'songbooksId', DbType.integer);
  }

  SongbookRecordField? _song_lyricsId;
  SongbookRecordField get song_lyricsId {
    return _song_lyricsId =
        _setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  /// Deletes List<SongbookRecord> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSongbookRecord!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSongbookRecord!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from songbook_records ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSongbookRecord!.updateBatch(qparams, values);
  }

  /// This method always returns [SongbookRecord] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SongbookRecord?
  @override
  Future<SongbookRecord?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSongbookRecord!.toList(qparams);
    final data = await objFuture;
    SongbookRecord? obj;
    if (data.isNotEmpty) {
      obj = SongbookRecord.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongbook'))) {
          obj.plSongbook =
              obj.plSongbook ?? await obj.getSongbook(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SongbookRecord]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SongbookRecord?
  @override
  Future<SongbookRecord> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SongbookRecord();
  }

  /// This method returns int. [SongbookRecord]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? songbookrecordCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songbookrecordsFuture = await _mnSongbookRecord!.toList(qparams);
    final int count = songbookrecordsFuture[0]['CNT'] as int;
    if (songbookrecordCount != null) {
      songbookrecordCount(count);
    }
    return count;
  }

  /// This method returns List<SongbookRecord> [SongbookRecord]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SongbookRecord>
  @override
  Future<List<SongbookRecord>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SongbookRecord> songbookrecordsData =
        await SongbookRecord.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return songbookrecordsData;
  }

  /// This method returns Json String [SongbookRecord]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SongbookRecord]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SongbookRecord]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSongbookRecord!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SongbookRecord]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM songbook_records WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSongbookRecord!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SongbookRecord]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSongbookRecord!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SongbookRecord.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSongbookRecord!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongbookRecordFilterBuilder

// region SongbookRecordFields
class SongbookRecordFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fNumber;
  static TableField get number {
    return _fNumber =
        _fNumber ?? SqlSyntax.setField(_fNumber, 'number', DbType.text);
  }

  static TableField? _fSongbooksId;
  static TableField get songbooksId {
    return _fSongbooksId = _fSongbooksId ??
        SqlSyntax.setField(_fSongbooksId, 'songbooksId', DbType.integer);
  }

  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }
}
// endregion SongbookRecordFields

//region SongbookRecordManager
class SongbookRecordManager extends SqfEntityProvider {
  SongbookRecordManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'songbook_records';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SongbookRecordManager
// region SongLyric
class SongLyric extends TableBase {
  SongLyric(
      {this.id,
      this.name,
      this.secondary_name_1,
      this.secondary_name_2,
      this.lyrics,
      this.lang_string,
      this.type_enum,
      this.lilypond_svg,
      this.favorite_rank,
      this.transposition,
      this.show_chords,
      this.accidentals,
      this.songsId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SongLyric.withFields(
      this.id,
      this.name,
      this.secondary_name_1,
      this.secondary_name_2,
      this.lyrics,
      this.lang_string,
      this.type_enum,
      this.lilypond_svg,
      this.favorite_rank,
      this.transposition,
      this.show_chords,
      this.accidentals,
      this.songsId) {
    _setDefaultValues();
  }
  SongLyric.withId(
      this.id,
      this.name,
      this.secondary_name_1,
      this.secondary_name_2,
      this.lyrics,
      this.lang_string,
      this.type_enum,
      this.lilypond_svg,
      this.favorite_rank,
      this.transposition,
      this.show_chords,
      this.accidentals,
      this.songsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SongLyric.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['secondary_name_1'] != null) {
      secondary_name_1 = o['secondary_name_1'].toString();
    }
    if (o['secondary_name_2'] != null) {
      secondary_name_2 = o['secondary_name_2'].toString();
    }
    if (o['lyrics'] != null) {
      lyrics = o['lyrics'].toString();
    }
    if (o['lang_string'] != null) {
      lang_string = o['lang_string'].toString();
    }
    if (o['type_enum'] != null) {
      type_enum = o['type_enum'].toString();
    }
    if (o['lilypond_svg'] != null) {
      lilypond_svg = o['lilypond_svg'].toString();
    }
    if (o['favorite_rank'] != null) {
      favorite_rank = int.tryParse(o['favorite_rank'].toString());
    }
    if (o['transposition'] != null) {
      transposition = int.tryParse(o['transposition'].toString());
    }
    if (o['show_chords'] != null) {
      show_chords = o['show_chords'].toString() == '1' ||
          o['show_chords'].toString() == 'true';
    }
    if (o['accidentals'] != null) {
      accidentals = int.tryParse(o['accidentals'].toString());
    }
    songsId = int.tryParse(o['songsId'].toString());

    // RELATIONSHIPS FromMAP
    plSong = o['song'] != null
        ? Song.fromMap(o['song'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (SongLyric)
  int? id;
  String? name;
  String? secondary_name_1;
  String? secondary_name_2;
  String? lyrics;
  String? lang_string;
  String? type_enum;
  String? lilypond_svg;
  int? favorite_rank;
  int? transposition;
  bool? show_chords;
  int? accidentals;
  int? songsId;
  bool? isSaved;
  // end FIELDS (SongLyric)

// RELATIONSHIPS (SongLyric)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSong', 'plField2'..]) or so on..
  Song? plSong;

  /// get Song By SongsId
  Future<Song?> getSong(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Song()
        .getById(songsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (SongLyric)

// COLLECTIONS & VIRTUALS (SongLyric)
  ///(RelationType.MANY_TO_MANY) (song_lyricsAuthors) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAuthors', 'plField2'..]) or so on..
  List<Author>? plAuthors;

  /// get Author(s) filtered by authorsId IN song_lyricsAuthors
  AuthorFilterBuilder? getAuthors(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Author()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT authorsId FROM song_lyricsAuthors WHERE song_lyricsId=?)',
            parameterValue: id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plExternals', 'plField2'..]) or so on..
  List<External>? plExternals;

  /// get External(s) filtered by id=song_lyricsId
  ExternalFilterBuilder? getExternals(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return External()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .song_lyricsId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPlaylistRecords', 'plField2'..]) or so on..
  List<PlaylistRecord>? plPlaylistRecords;

  /// get PlaylistRecord(s) filtered by id=song_lyricsId
  PlaylistRecordFilterBuilder? getPlaylistRecords(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return PlaylistRecord()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .song_lyricsId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongbookRecords', 'plField2'..]) or so on..
  List<SongbookRecord>? plSongbookRecords;

  /// get SongbookRecord(s) filtered by id=song_lyricsId
  SongbookRecordFilterBuilder? getSongbookRecords(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SongbookRecord()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .song_lyricsId
        .equals(id)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (song_lyricsTags) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTags', 'plField2'..]) or so on..
  List<Tag>? plTags;

  /// get Tag(s) filtered by tagsId IN song_lyricsTags
  TagFilterBuilder? getTags(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Tag()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT tagsId FROM song_lyricsTags WHERE song_lyricsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (SongLyric)

  static const bool _softDeleteActivated = false;
  SongLyricManager? __mnSongLyric;

  SongLyricManager get _mnSongLyric {
    return __mnSongLyric = __mnSongLyric ?? SongLyricManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (secondary_name_1 != null || !forView) {
      map['secondary_name_1'] = secondary_name_1;
    }
    if (secondary_name_2 != null || !forView) {
      map['secondary_name_2'] = secondary_name_2;
    }
    if (lyrics != null || !forView) {
      map['lyrics'] = lyrics;
    }
    if (lang_string != null || !forView) {
      map['lang_string'] = lang_string;
    }
    if (type_enum != null || !forView) {
      map['type_enum'] = type_enum;
    }
    if (lilypond_svg != null || !forView) {
      map['lilypond_svg'] = lilypond_svg;
    }
    if (favorite_rank != null || !forView) {
      map['favorite_rank'] = favorite_rank;
    }
    if (transposition != null || !forView) {
      map['transposition'] = transposition;
    }
    if (show_chords != null) {
      map['show_chords'] = forQuery ? (show_chords! ? 1 : 0) : show_chords;
    } else if (show_chords != null || !forView) {
      map['show_chords'] = null;
    }
    if (accidentals != null || !forView) {
      map['accidentals'] = accidentals;
    }
    if (songsId != null) {
      map['songsId'] = forView
          ? plSong == null
              ? songsId
              : plSong!.name
          : songsId;
    } else if (songsId != null || !forView) {
      map['songsId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (secondary_name_1 != null || !forView) {
      map['secondary_name_1'] = secondary_name_1;
    }
    if (secondary_name_2 != null || !forView) {
      map['secondary_name_2'] = secondary_name_2;
    }
    if (lyrics != null || !forView) {
      map['lyrics'] = lyrics;
    }
    if (lang_string != null || !forView) {
      map['lang_string'] = lang_string;
    }
    if (type_enum != null || !forView) {
      map['type_enum'] = type_enum;
    }
    if (lilypond_svg != null || !forView) {
      map['lilypond_svg'] = lilypond_svg;
    }
    if (favorite_rank != null || !forView) {
      map['favorite_rank'] = favorite_rank;
    }
    if (transposition != null || !forView) {
      map['transposition'] = transposition;
    }
    if (show_chords != null) {
      map['show_chords'] = forQuery ? (show_chords! ? 1 : 0) : show_chords;
    } else if (show_chords != null || !forView) {
      map['show_chords'] = null;
    }
    if (accidentals != null || !forView) {
      map['accidentals'] = accidentals;
    }
    if (songsId != null) {
      map['songsId'] = forView
          ? plSong == null
              ? songsId
              : plSong!.name
          : songsId;
    } else if (songsId != null || !forView) {
      map['songsId'] = null;
    }

// COLLECTIONS (SongLyric)
    if (!forQuery) {
      map['Authors'] = await getAuthors()!.toMapList();
    }
    if (!forQuery) {
      map['Externals'] = await getExternals()!.toMapList();
    }
    if (!forQuery) {
      map['PlaylistRecords'] = await getPlaylistRecords()!.toMapList();
    }
    if (!forQuery) {
      map['SongbookRecords'] = await getSongbookRecords()!.toMapList();
    }
    if (!forQuery) {
      map['Tags'] = await getTags()!.toMapList();
    }
// END COLLECTIONS (SongLyric)

    return map;
  }

  /// This method returns Json String [SongLyric]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SongLyric]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      name,
      secondary_name_1,
      secondary_name_2,
      lyrics,
      lang_string,
      type_enum,
      lilypond_svg,
      favorite_rank,
      transposition,
      show_chords,
      accidentals,
      songsId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      secondary_name_1,
      secondary_name_2,
      lyrics,
      lang_string,
      type_enum,
      lilypond_svg,
      favorite_rank,
      transposition,
      show_chords,
      accidentals,
      songsId
    ];
  }

  static Future<List<SongLyric>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SongLyric.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SongLyric>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SongLyric>[];
    try {
      objList = list
          .map((songlyric) =>
              SongLyric.fromMap(songlyric as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SongLyric.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SongLyric>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SongLyric> objList = <SongLyric>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SongLyric.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('song_lyrics.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('song_lyrics.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('song_lyrics.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('song_lyrics.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTags'))) {
          /*_loadedfields!.add('song_lyrics.plTags'); */ obj.plTags =
              obj.plTags ??
                  await obj.getTags()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSong'))) {
          obj.plSong =
              obj.plSong ?? await obj.getSong(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SongLyric by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SongLyric] if exist, otherwise returns null
  Future<SongLyric?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SongLyric? obj;
    final data = await _mnSongLyric.getById([id]);
    if (data.length != 0) {
      obj = SongLyric.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('song_lyrics.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('song_lyrics.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('song_lyrics.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('song_lyrics.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTags'))) {
          /*_loadedfields!.add('song_lyrics.plTags'); */ obj.plTags =
              obj.plTags ??
                  await obj.getTags()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSong'))) {
          obj.plSong =
              obj.plSong ?? await obj.getSong(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SongLyric) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongLyric.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnSongLyric.update(this);
    }

    return id;
  }

  /// Saves the (SongLyric) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSongLyric.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSongLyric.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<SongLyric> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<SongLyric> songlyrics) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in songlyrics) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSongLyric.rawInsert(
          'INSERT OR REPLACE INTO song_lyrics (id, name, secondary_name_1, secondary_name_2, lyrics, lang_string, type_enum, lilypond_svg, favorite_rank, transposition, show_chords, accidentals, songsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            name,
            secondary_name_1,
            secondary_name_2,
            lyrics,
            lang_string,
            type_enum,
            lilypond_svg,
            favorite_rank,
            transposition,
            show_chords,
            accidentals,
            songsId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SongLyric id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'SongLyric id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SongLyric Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SongLyric>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<SongLyric> songlyrics) async {
    final results = await _mnSongLyric.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyrics (id, name, secondary_name_1, secondary_name_2, lyrics, lang_string, type_enum, lilypond_svg, favorite_rank, transposition, show_chords, accidentals, songsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
        songlyrics);
    return results;
  }

  /// Deletes SongLyric

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SongLyric invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await External()
          .select()
          .song_lyricsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await PlaylistRecord()
          .select()
          .song_lyricsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await SongbookRecord()
          .select()
          .song_lyricsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSongLyric
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSongLyric.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SongLyric] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SongLyricFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongLyricFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SongLyricFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongLyricFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    transposition = transposition ?? 0;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion songlyric

// region SongLyricField
class SongLyricField extends FilterBase {
  SongLyricField(SongLyricFilterBuilder songlyricFB) : super(songlyricFB);

  @override
  SongLyricFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder isNull() {
    return super.isNull() as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SongLyricFilterBuilder;
  }

  @override
  SongLyricField get not {
    return super.not as SongLyricField;
  }
}
// endregion SongLyricField

// region SongLyricFilterBuilder
class SongLyricFilterBuilder extends ConjunctionBase {
  SongLyricFilterBuilder(SongLyric obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSongLyric = obj._mnSongLyric;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SongLyricManager? _mnSongLyric;

  /// put the sql keyword 'AND'
  @override
  SongLyricFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SongLyricFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SongLyricFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SongLyricFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SongLyricFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SongLyricFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SongLyricFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SongLyricFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SongLyricFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SongLyricFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SongLyricFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SongLyricField _setField(
      SongLyricField? field, String colName, DbType dbtype) {
    return SongLyricField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SongLyricField? _id;
  SongLyricField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SongLyricField? _name;
  SongLyricField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  SongLyricField? _secondary_name_1;
  SongLyricField get secondary_name_1 {
    return _secondary_name_1 =
        _setField(_secondary_name_1, 'secondary_name_1', DbType.text);
  }

  SongLyricField? _secondary_name_2;
  SongLyricField get secondary_name_2 {
    return _secondary_name_2 =
        _setField(_secondary_name_2, 'secondary_name_2', DbType.text);
  }

  SongLyricField? _lyrics;
  SongLyricField get lyrics {
    return _lyrics = _setField(_lyrics, 'lyrics', DbType.text);
  }

  SongLyricField? _lang_string;
  SongLyricField get lang_string {
    return _lang_string = _setField(_lang_string, 'lang_string', DbType.text);
  }

  SongLyricField? _type_enum;
  SongLyricField get type_enum {
    return _type_enum = _setField(_type_enum, 'type_enum', DbType.text);
  }

  SongLyricField? _lilypond_svg;
  SongLyricField get lilypond_svg {
    return _lilypond_svg =
        _setField(_lilypond_svg, 'lilypond_svg', DbType.text);
  }

  SongLyricField? _favorite_rank;
  SongLyricField get favorite_rank {
    return _favorite_rank =
        _setField(_favorite_rank, 'favorite_rank', DbType.integer);
  }

  SongLyricField? _transposition;
  SongLyricField get transposition {
    return _transposition =
        _setField(_transposition, 'transposition', DbType.integer);
  }

  SongLyricField? _show_chords;
  SongLyricField get show_chords {
    return _show_chords = _setField(_show_chords, 'show_chords', DbType.bool);
  }

  SongLyricField? _accidentals;
  SongLyricField get accidentals {
    return _accidentals =
        _setField(_accidentals, 'accidentals', DbType.integer);
  }

  SongLyricField? _songsId;
  SongLyricField get songsId {
    return _songsId = _setField(_songsId, 'songsId', DbType.integer);
  }

  /// Deletes List<SongLyric> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (External) according to DeleteRule.CASCADE
    final idListExternalBYsong_lyricsId = toListPrimaryKeySQL(false);
    final resExternalBYsong_lyricsId = await External()
        .select()
        .where('song_lyricsId IN (${idListExternalBYsong_lyricsId['sql']})',
            parameterValue: idListExternalBYsong_lyricsId['args'])
        .delete(hardDelete);
    if (!resExternalBYsong_lyricsId.success) {
      return resExternalBYsong_lyricsId;
    }
// Delete sub records where in (PlaylistRecord) according to DeleteRule.CASCADE
    final idListPlaylistRecordBYsong_lyricsId = toListPrimaryKeySQL(false);
    final resPlaylistRecordBYsong_lyricsId = await PlaylistRecord()
        .select()
        .where(
            'song_lyricsId IN (${idListPlaylistRecordBYsong_lyricsId['sql']})',
            parameterValue: idListPlaylistRecordBYsong_lyricsId['args'])
        .delete(hardDelete);
    if (!resPlaylistRecordBYsong_lyricsId.success) {
      return resPlaylistRecordBYsong_lyricsId;
    }
// Delete sub records where in (SongbookRecord) according to DeleteRule.CASCADE
    final idListSongbookRecordBYsong_lyricsId = toListPrimaryKeySQL(false);
    final resSongbookRecordBYsong_lyricsId = await SongbookRecord()
        .select()
        .where(
            'song_lyricsId IN (${idListSongbookRecordBYsong_lyricsId['sql']})',
            parameterValue: idListSongbookRecordBYsong_lyricsId['args'])
        .delete(hardDelete);
    if (!resSongbookRecordBYsong_lyricsId.success) {
      return resSongbookRecordBYsong_lyricsId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSongLyric!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSongLyric!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from song_lyrics ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSongLyric!.updateBatch(qparams, values);
  }

  /// This method always returns [SongLyric] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SongLyric?
  @override
  Future<SongLyric?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSongLyric!.toList(qparams);
    final data = await objFuture;
    SongLyric? obj;
    if (data.isNotEmpty) {
      obj = SongLyric.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('song_lyrics.plAuthors') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAuthors'))) {
          /*_loadedfields!.add('song_lyrics.plAuthors'); */ obj.plAuthors =
              obj.plAuthors ??
                  await obj.getAuthors()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plExternals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExternals'))) {
          /*_loadedfields!.add('song_lyrics.plExternals'); */ obj.plExternals =
              obj.plExternals ??
                  await obj.getExternals()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plPlaylistRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylistRecords'))) {
          /*_loadedfields!.add('song_lyrics.plPlaylistRecords'); */ obj
                  .plPlaylistRecords =
              obj.plPlaylistRecords ??
                  await obj.getPlaylistRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plSongbookRecords') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongbookRecords'))) {
          /*_loadedfields!.add('song_lyrics.plSongbookRecords'); */ obj
                  .plSongbookRecords =
              obj.plSongbookRecords ??
                  await obj.getSongbookRecords()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('song_lyrics.plTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTags'))) {
          /*_loadedfields!.add('song_lyrics.plTags'); */ obj.plTags =
              obj.plTags ??
                  await obj.getTags()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSong'))) {
          obj.plSong =
              obj.plSong ?? await obj.getSong(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SongLyric]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SongLyric?
  @override
  Future<SongLyric> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SongLyric();
  }

  /// This method returns int. [SongLyric]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? songlyricCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final songlyricsFuture = await _mnSongLyric!.toList(qparams);
    final int count = songlyricsFuture[0]['CNT'] as int;
    if (songlyricCount != null) {
      songlyricCount(count);
    }
    return count;
  }

  /// This method returns List<SongLyric> [SongLyric]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SongLyric>
  @override
  Future<List<SongLyric>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SongLyric> songlyricsData = await SongLyric.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return songlyricsData;
  }

  /// This method returns Json String [SongLyric]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SongLyric]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SongLyric]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSongLyric!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SongLyric]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM song_lyrics WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSongLyric!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SongLyric]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSongLyric!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SongLyric.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSongLyric!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SongLyricFilterBuilder

// region SongLyricFields
class SongLyricFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fSecondary_name_1;
  static TableField get secondary_name_1 {
    return _fSecondary_name_1 = _fSecondary_name_1 ??
        SqlSyntax.setField(_fSecondary_name_1, 'secondary_name_1', DbType.text);
  }

  static TableField? _fSecondary_name_2;
  static TableField get secondary_name_2 {
    return _fSecondary_name_2 = _fSecondary_name_2 ??
        SqlSyntax.setField(_fSecondary_name_2, 'secondary_name_2', DbType.text);
  }

  static TableField? _fLyrics;
  static TableField get lyrics {
    return _fLyrics =
        _fLyrics ?? SqlSyntax.setField(_fLyrics, 'lyrics', DbType.text);
  }

  static TableField? _fLang_string;
  static TableField get lang_string {
    return _fLang_string = _fLang_string ??
        SqlSyntax.setField(_fLang_string, 'lang_string', DbType.text);
  }

  static TableField? _fType_enum;
  static TableField get type_enum {
    return _fType_enum = _fType_enum ??
        SqlSyntax.setField(_fType_enum, 'type_enum', DbType.text);
  }

  static TableField? _fLilypond_svg;
  static TableField get lilypond_svg {
    return _fLilypond_svg = _fLilypond_svg ??
        SqlSyntax.setField(_fLilypond_svg, 'lilypond_svg', DbType.text);
  }

  static TableField? _fFavorite_rank;
  static TableField get favorite_rank {
    return _fFavorite_rank = _fFavorite_rank ??
        SqlSyntax.setField(_fFavorite_rank, 'favorite_rank', DbType.integer);
  }

  static TableField? _fTransposition;
  static TableField get transposition {
    return _fTransposition = _fTransposition ??
        SqlSyntax.setField(_fTransposition, 'transposition', DbType.integer);
  }

  static TableField? _fShow_chords;
  static TableField get show_chords {
    return _fShow_chords = _fShow_chords ??
        SqlSyntax.setField(_fShow_chords, 'show_chords', DbType.bool);
  }

  static TableField? _fAccidentals;
  static TableField get accidentals {
    return _fAccidentals = _fAccidentals ??
        SqlSyntax.setField(_fAccidentals, 'accidentals', DbType.integer);
  }

  static TableField? _fSongsId;
  static TableField get songsId {
    return _fSongsId =
        _fSongsId ?? SqlSyntax.setField(_fSongsId, 'songsId', DbType.integer);
  }
}
// endregion SongLyricFields

//region SongLyricManager
class SongLyricManager extends SqfEntityProvider {
  SongLyricManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'song_lyrics';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SongLyricManager
// region Tag
class Tag extends TableBase {
  Tag({this.id, this.name, this.type_enum}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Tag.withFields(this.id, this.name, this.type_enum) {
    _setDefaultValues();
  }
  Tag.withId(this.id, this.name, this.type_enum) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Tag.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['type_enum'] != null) {
      type_enum = o['type_enum'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Tag)
  int? id;
  String? name;
  String? type_enum;
  bool? isSaved;
  // end FIELDS (Tag)

// COLLECTIONS & VIRTUALS (Tag)
  ///(RelationType.MANY_TO_MANY) (song_lyricsTags) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyrics', 'plField2'..]) or so on..
  List<SongLyric>? plSongLyrics;

  /// get SongLyric(s) filtered by song_lyricsId IN song_lyricsTags
  SongLyricFilterBuilder? getSongLyrics(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SongLyric()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT song_lyricsId FROM song_lyricsTags WHERE tagsId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Tag)

  static const bool _softDeleteActivated = false;
  TagManager? __mnTag;

  TagManager get _mnTag {
    return __mnTag = __mnTag ?? TagManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (type_enum != null || !forView) {
      map['type_enum'] = type_enum;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (type_enum != null || !forView) {
      map['type_enum'] = type_enum;
    }

// COLLECTIONS (Tag)
    if (!forQuery) {
      map['SongLyrics'] = await getSongLyrics()!.toMapList();
    }
// END COLLECTIONS (Tag)

    return map;
  }

  /// This method returns Json String [Tag]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Tag]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, name, type_enum];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name, type_enum];
  }

  static Future<List<Tag>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Tag.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Tag>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Tag>[];
    try {
      objList =
          list.map((tag) => Tag.fromMap(tag as Map<String, dynamic>)).toList();
    } catch (e) {
      debugPrint('SQFENTITY ERROR Tag.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Tag>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Tag> objList = <Tag>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Tag.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tags.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('tags.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Tag by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Tag] if exist, otherwise returns null
  Future<Tag?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Tag? obj;
    final data = await _mnTag.getById([id]);
    if (data.length != 0) {
      obj = Tag.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tags.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('tags.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Tag) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnTag.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnTag.update(this);
    }

    return id;
  }

  /// Saves the (Tag) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnTag.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTag.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Tag> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Tag> tags) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in tags) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTag.rawInsert(
          'INSERT OR REPLACE INTO tags (id, name, type_enum)  VALUES (?,?,?)',
          [id, name, type_enum],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Tag id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Tag id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Tag Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Tag>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Tag> tags) async {
    final results = await _mnTag.rawInsertAll(
        'INSERT OR REPLACE INTO tags (id, name, type_enum)  VALUES (?,?,?)',
        tags);
    return results;
  }

  /// Deletes Tag

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Tag invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTag
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnTag.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Tag] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TagFilterBuilder select({List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TagFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TagFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TagFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tag

// region TagField
class TagField extends FilterBase {
  TagField(TagFilterBuilder tagFB) : super(tagFB);

  @override
  TagFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder isNull() {
    return super.isNull() as TagFilterBuilder;
  }

  @override
  TagFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TagFilterBuilder;
  }

  @override
  TagFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TagFilterBuilder;
  }

  @override
  TagField get not {
    return super.not as TagField;
  }
}
// endregion TagField

// region TagFilterBuilder
class TagFilterBuilder extends ConjunctionBase {
  TagFilterBuilder(Tag obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnTag = obj._mnTag;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TagManager? _mnTag;

  /// put the sql keyword 'AND'
  @override
  TagFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TagFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TagFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TagFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TagFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TagFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TagFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TagFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TagFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TagFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TagFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TagField _setField(TagField? field, String colName, DbType dbtype) {
    return TagField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TagField? _id;
  TagField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  TagField? _name;
  TagField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  TagField? _type_enum;
  TagField get type_enum {
    return _type_enum = _setField(_type_enum, 'type_enum', DbType.text);
  }

  /// Deletes List<Tag> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTag!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTag!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from tags ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTag!.updateBatch(qparams, values);
  }

  /// This method always returns [Tag] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Tag?
  @override
  Future<Tag?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTag!.toList(qparams);
    final data = await objFuture;
    Tag? obj;
    if (data.isNotEmpty) {
      obj = Tag.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tags.plSongLyrics') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSongLyrics'))) {
          /*_loadedfields!.add('tags.plSongLyrics'); */ obj.plSongLyrics =
              obj.plSongLyrics ??
                  await obj.getSongLyrics()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Tag]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Tag?
  @override
  Future<Tag> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Tag();
  }

  /// This method returns int. [Tag]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? tagCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tagsFuture = await _mnTag!.toList(qparams);
    final int count = tagsFuture[0]['CNT'] as int;
    if (tagCount != null) {
      tagCount(count);
    }
    return count;
  }

  /// This method returns List<Tag> [Tag]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Tag>
  @override
  Future<List<Tag>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Tag> tagsData = await Tag.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tagsData;
  }

  /// This method returns Json String [Tag]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Tag]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Tag]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTag!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Tag]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM tags WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnTag!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Tag]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTag!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Tag.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTag!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TagFilterBuilder

// region TagFields
class TagFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fType_enum;
  static TableField get type_enum {
    return _fType_enum = _fType_enum ??
        SqlSyntax.setField(_fType_enum, 'type_enum', DbType.text);
  }
}
// endregion TagFields

//region TagManager
class TagManager extends SqfEntityProvider {
  TagManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'tags';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion TagManager
// region ExternalsAuthors
class ExternalsAuthors extends TableBase {
  ExternalsAuthors({this.externalsId, this.authorsId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ExternalsAuthors.withFields(this.externalsId, this.authorsId) {
    _setDefaultValues();
  }
  ExternalsAuthors.withId(this.externalsId, this.authorsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ExternalsAuthors.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    externalsId = int.tryParse(o['externalsId'].toString());

    authorsId = int.tryParse(o['authorsId'].toString());

    // RELATIONSHIPS FromMAP
    plExternal = o['external'] != null
        ? External.fromMap(o['external'] as Map<String, dynamic>)
        : null;
    plAuthor = o['author'] != null
        ? Author.fromMap(o['author'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (ExternalsAuthors)
  int? externalsId;
  int? authorsId;
  bool? isSaved;
  // end FIELDS (ExternalsAuthors)

// RELATIONSHIPS (ExternalsAuthors)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plExternal', 'plField2'..]) or so on..
  External? plExternal;

  /// get External By ExternalsId
  Future<External?> getExternal(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await External().getById(externalsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAuthor', 'plField2'..]) or so on..
  Author? plAuthor;

  /// get Author By AuthorsId
  Future<Author?> getAuthor(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Author().getById(authorsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (ExternalsAuthors)

  static const bool _softDeleteActivated = false;
  ExternalsAuthorsManager? __mnExternalsAuthors;

  ExternalsAuthorsManager get _mnExternalsAuthors {
    return __mnExternalsAuthors =
        __mnExternalsAuthors ?? ExternalsAuthorsManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (externalsId != null) {
      map['externalsId'] = forView
          ? plExternal == null
              ? externalsId
              : plExternal!.public_name
          : externalsId;
    } else if (externalsId != null || !forView) {
      map['externalsId'] = null;
    }
    if (authorsId != null) {
      map['authorsId'] = forView
          ? plAuthor == null
              ? authorsId
              : plAuthor!.name
          : authorsId;
    } else if (authorsId != null || !forView) {
      map['authorsId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (externalsId != null) {
      map['externalsId'] = forView
          ? plExternal == null
              ? externalsId
              : plExternal!.public_name
          : externalsId;
    } else if (externalsId != null || !forView) {
      map['externalsId'] = null;
    }
    if (authorsId != null) {
      map['authorsId'] = forView
          ? plAuthor == null
              ? authorsId
              : plAuthor!.name
          : authorsId;
    } else if (authorsId != null || !forView) {
      map['authorsId'] = null;
    }

    return map;
  }

  /// This method returns Json String [ExternalsAuthors]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ExternalsAuthors]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [externalsId, authorsId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [externalsId, authorsId];
  }

  static Future<List<ExternalsAuthors>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ExternalsAuthors.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ExternalsAuthors>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ExternalsAuthors>[];
    try {
      objList = list
          .map((externalsauthors) => ExternalsAuthors.fromMap(
              externalsauthors as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ExternalsAuthors.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ExternalsAuthors>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ExternalsAuthors> objList = <ExternalsAuthors>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ExternalsAuthors.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plExternal'))) {
          obj.plExternal =
              obj.plExternal ?? await obj.getExternal(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          obj.plAuthor =
              obj.plAuthor ?? await obj.getAuthor(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns ExternalsAuthors by ID if exist, otherwise returns null
  /// Primary Keys: int? externalsId, int? authorsId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ExternalsAuthors] if exist, otherwise returns null
  Future<ExternalsAuthors?> getById(int? externalsId, int? authorsId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (externalsId == null) {
      return null;
    }
    ExternalsAuthors? obj;
    final data = await _mnExternalsAuthors.getById([externalsId, authorsId]);
    if (data.length != 0) {
      obj = ExternalsAuthors.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plExternal'))) {
          obj.plExternal =
              obj.plExternal ?? await obj.getExternal(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          obj.plAuthor =
              obj.plAuthor ?? await obj.getAuthor(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ExternalsAuthors) object. If the Primary Key (externalsId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same externalsId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnExternalsAuthors.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO externalsAuthors ( externalsId, authorsId)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ExternalsAuthors> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ExternalsAuthors> externalsauthorses) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in externalsauthorses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnExternalsAuthors.rawInsert(
          'INSERT OR REPLACE INTO externalsAuthors ( externalsId, authorsId)  VALUES (?,?)',
          [externalsId, authorsId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ExternalsAuthors externalsId=$externalsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ExternalsAuthors externalsId=$externalsId did not update');
      }
      return externalsId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ExternalsAuthors Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ExternalsAuthors>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<ExternalsAuthors> externalsauthorses) async {
    final results = await _mnExternalsAuthors.rawInsertAll(
        'INSERT OR REPLACE INTO externalsAuthors ( externalsId, authorsId)  VALUES (?,?)',
        externalsauthorses);
    return results;
  }

  /// Deletes ExternalsAuthors

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete ExternalsAuthors invoked (externalsId=$externalsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExternalsAuthors.delete(QueryParams(
          whereString: 'externalsId=? AND authorsId=?',
          whereArguments: [externalsId, authorsId]));
    } else {
      return _mnExternalsAuthors.updateBatch(
          QueryParams(
              whereString: 'externalsId=? AND authorsId=?',
              whereArguments: [externalsId, authorsId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ExternalsAuthors] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ExternalsAuthorsFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExternalsAuthorsFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ExternalsAuthorsFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExternalsAuthorsFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      externalsId = null;
      authorsId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion externalsauthors

// region ExternalsAuthorsField
class ExternalsAuthorsField extends FilterBase {
  ExternalsAuthorsField(ExternalsAuthorsFilterBuilder externalsauthorsFB)
      : super(externalsauthorsFB);

  @override
  ExternalsAuthorsFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder isNull() {
    return super.isNull() as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ExternalsAuthorsFilterBuilder;
  }

  @override
  ExternalsAuthorsField get not {
    return super.not as ExternalsAuthorsField;
  }
}
// endregion ExternalsAuthorsField

// region ExternalsAuthorsFilterBuilder
class ExternalsAuthorsFilterBuilder extends ConjunctionBase {
  ExternalsAuthorsFilterBuilder(ExternalsAuthors obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnExternalsAuthors = obj._mnExternalsAuthors;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ExternalsAuthorsManager? _mnExternalsAuthors;

  /// put the sql keyword 'AND'
  @override
  ExternalsAuthorsFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ExternalsAuthorsFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ExternalsAuthorsFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ExternalsAuthorsFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ExternalsAuthorsFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ExternalsAuthorsFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ExternalsAuthorsFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExternalsAuthorsFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExternalsAuthorsFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExternalsAuthorsFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExternalsAuthorsFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ExternalsAuthorsField _setField(
      ExternalsAuthorsField? field, String colName, DbType dbtype) {
    return ExternalsAuthorsField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ExternalsAuthorsField? _externalsId;
  ExternalsAuthorsField get externalsId {
    return _externalsId =
        _setField(_externalsId, 'externalsId', DbType.integer);
  }

  ExternalsAuthorsField? _authorsId;
  ExternalsAuthorsField get authorsId {
    return _authorsId = _setField(_authorsId, 'authorsId', DbType.integer);
  }

  /// Deletes List<ExternalsAuthors> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnExternalsAuthors!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnExternalsAuthors!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'externalsId IN (SELECT externalsId from externalsAuthors ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnExternalsAuthors!.updateBatch(qparams, values);
  }

  /// This method always returns [ExternalsAuthors] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ExternalsAuthors?
  @override
  Future<ExternalsAuthors?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnExternalsAuthors!.toList(qparams);
    final data = await objFuture;
    ExternalsAuthors? obj;
    if (data.isNotEmpty) {
      obj = ExternalsAuthors.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plExternal'))) {
          obj.plExternal =
              obj.plExternal ?? await obj.getExternal(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          obj.plAuthor =
              obj.plAuthor ?? await obj.getAuthor(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ExternalsAuthors]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ExternalsAuthors?
  @override
  Future<ExternalsAuthors> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ExternalsAuthors();
  }

  /// This method returns int. [ExternalsAuthors]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? externalsauthorsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final externalsauthorsesFuture = await _mnExternalsAuthors!.toList(qparams);
    final int count = externalsauthorsesFuture[0]['CNT'] as int;
    if (externalsauthorsCount != null) {
      externalsauthorsCount(count);
    }
    return count;
  }

  /// This method returns List<ExternalsAuthors> [ExternalsAuthors]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ExternalsAuthors>
  @override
  Future<List<ExternalsAuthors>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ExternalsAuthors> externalsauthorsesData =
        await ExternalsAuthors.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return externalsauthorsesData;
  }

  /// This method returns Json String [ExternalsAuthors]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ExternalsAuthors]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ExternalsAuthors]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnExternalsAuthors!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ExternalsAuthors]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `externalsId`authorsId` FROM externalsAuthors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<externalsId,authorsId> [ExternalsAuthors]
  /// <returns>List<externalsId,authorsId>
  @override
  Future<List<ExternalsAuthors>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['externalsId', 'authorsId'];
    final externalsauthorsFuture = await _mnExternalsAuthors!.toList(qparams);
    return await ExternalsAuthors.fromMapList(externalsauthorsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ExternalsAuthors]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnExternalsAuthors!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ExternalsAuthors.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnExternalsAuthors!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExternalsAuthorsFilterBuilder

// region ExternalsAuthorsFields
class ExternalsAuthorsFields {
  static TableField? _fExternalsId;
  static TableField get externalsId {
    return _fExternalsId = _fExternalsId ??
        SqlSyntax.setField(_fExternalsId, 'externalsId', DbType.integer);
  }

  static TableField? _fAuthorsId;
  static TableField get authorsId {
    return _fAuthorsId = _fAuthorsId ??
        SqlSyntax.setField(_fAuthorsId, 'authorsId', DbType.integer);
  }
}
// endregion ExternalsAuthorsFields

//region ExternalsAuthorsManager
class ExternalsAuthorsManager extends SqfEntityProvider {
  ExternalsAuthorsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'externalsAuthors';
  static const List<String> _primaryKeyList = ['externalsId', 'authorsId'];
  static const String _whereStr = 'externalsId=? AND authorsId=?';
}

//endregion ExternalsAuthorsManager
// region Song_lyricsAuthors
class Song_lyricsAuthors extends TableBase {
  Song_lyricsAuthors({this.song_lyricsId, this.authorsId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Song_lyricsAuthors.withFields(this.song_lyricsId, this.authorsId) {
    _setDefaultValues();
  }
  Song_lyricsAuthors.withId(this.song_lyricsId, this.authorsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Song_lyricsAuthors.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    authorsId = int.tryParse(o['authorsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    plAuthor = o['author'] != null
        ? Author.fromMap(o['author'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Song_lyricsAuthors)
  int? song_lyricsId;
  int? authorsId;
  bool? isSaved;
  // end FIELDS (Song_lyricsAuthors)

// RELATIONSHIPS (Song_lyricsAuthors)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAuthor', 'plField2'..]) or so on..
  Author? plAuthor;

  /// get Author By AuthorsId
  Future<Author?> getAuthor(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Author().getById(authorsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Song_lyricsAuthors)

  static const bool _softDeleteActivated = false;
  Song_lyricsAuthorsManager? __mnSong_lyricsAuthors;

  Song_lyricsAuthorsManager get _mnSong_lyricsAuthors {
    return __mnSong_lyricsAuthors =
        __mnSong_lyricsAuthors ?? Song_lyricsAuthorsManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }
    if (authorsId != null) {
      map['authorsId'] = forView
          ? plAuthor == null
              ? authorsId
              : plAuthor!.name
          : authorsId;
    } else if (authorsId != null || !forView) {
      map['authorsId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }
    if (authorsId != null) {
      map['authorsId'] = forView
          ? plAuthor == null
              ? authorsId
              : plAuthor!.name
          : authorsId;
    } else if (authorsId != null || !forView) {
      map['authorsId'] = null;
    }

    return map;
  }

  /// This method returns Json String [Song_lyricsAuthors]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song_lyricsAuthors]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [song_lyricsId, authorsId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [song_lyricsId, authorsId];
  }

  static Future<List<Song_lyricsAuthors>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song_lyricsAuthors.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Song_lyricsAuthors>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song_lyricsAuthors>[];
    try {
      objList = list
          .map((song_lyricsauthors) => Song_lyricsAuthors.fromMap(
              song_lyricsauthors as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song_lyricsAuthors.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song_lyricsAuthors>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song_lyricsAuthors> objList = <Song_lyricsAuthors>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song_lyricsAuthors.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          obj.plAuthor =
              obj.plAuthor ?? await obj.getAuthor(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song_lyricsAuthors by ID if exist, otherwise returns null
  /// Primary Keys: int? song_lyricsId, int? authorsId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Song_lyricsAuthors] if exist, otherwise returns null
  Future<Song_lyricsAuthors?> getById(int? song_lyricsId, int? authorsId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (song_lyricsId == null) {
      return null;
    }
    Song_lyricsAuthors? obj;
    final data =
        await _mnSong_lyricsAuthors.getById([song_lyricsId, authorsId]);
    if (data.length != 0) {
      obj = Song_lyricsAuthors.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          obj.plAuthor =
              obj.plAuthor ?? await obj.getAuthor(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song_lyricsAuthors) object. If the Primary Key (song_lyricsId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same song_lyricsId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnSong_lyricsAuthors.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO song_lyricsAuthors ( song_lyricsId, authorsId)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Song_lyricsAuthors> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Song_lyricsAuthors> song_lyricsauthorses) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in song_lyricsauthorses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSong_lyricsAuthors.rawInsert(
          'INSERT OR REPLACE INTO song_lyricsAuthors ( song_lyricsId, authorsId)  VALUES (?,?)',
          [song_lyricsId, authorsId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Song_lyricsAuthors song_lyricsId=$song_lyricsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Song_lyricsAuthors song_lyricsId=$song_lyricsId did not update');
      }
      return song_lyricsId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'Song_lyricsAuthors Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Song_lyricsAuthors>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<Song_lyricsAuthors> song_lyricsauthorses) async {
    final results = await _mnSong_lyricsAuthors.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyricsAuthors ( song_lyricsId, authorsId)  VALUES (?,?)',
        song_lyricsauthorses);
    return results;
  }

  /// Deletes Song_lyricsAuthors

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Song_lyricsAuthors invoked (song_lyricsId=$song_lyricsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong_lyricsAuthors.delete(QueryParams(
          whereString: 'song_lyricsId=? AND authorsId=?',
          whereArguments: [song_lyricsId, authorsId]));
    } else {
      return _mnSong_lyricsAuthors.updateBatch(
          QueryParams(
              whereString: 'song_lyricsId=? AND authorsId=?',
              whereArguments: [song_lyricsId, authorsId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Song_lyricsAuthors] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Song_lyricsAuthorsFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Song_lyricsAuthorsFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Song_lyricsAuthorsFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Song_lyricsAuthorsFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      song_lyricsId = null;
      authorsId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion song_lyricsauthors

// region Song_lyricsAuthorsField
class Song_lyricsAuthorsField extends FilterBase {
  Song_lyricsAuthorsField(Song_lyricsAuthorsFilterBuilder song_lyricsauthorsFB)
      : super(song_lyricsauthorsFB);

  @override
  Song_lyricsAuthorsFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder isNull() {
    return super.isNull() as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Song_lyricsAuthorsFilterBuilder;
  }

  @override
  Song_lyricsAuthorsField get not {
    return super.not as Song_lyricsAuthorsField;
  }
}
// endregion Song_lyricsAuthorsField

// region Song_lyricsAuthorsFilterBuilder
class Song_lyricsAuthorsFilterBuilder extends ConjunctionBase {
  Song_lyricsAuthorsFilterBuilder(Song_lyricsAuthors obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSong_lyricsAuthors = obj._mnSong_lyricsAuthors;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Song_lyricsAuthorsManager? _mnSong_lyricsAuthors;

  /// put the sql keyword 'AND'
  @override
  Song_lyricsAuthorsFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Song_lyricsAuthorsFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Song_lyricsAuthorsFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Song_lyricsAuthorsFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Song_lyricsAuthorsFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Song_lyricsAuthorsFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Song_lyricsAuthorsFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Song_lyricsAuthorsFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Song_lyricsAuthorsFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Song_lyricsAuthorsFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Song_lyricsAuthorsFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Song_lyricsAuthorsField _setField(
      Song_lyricsAuthorsField? field, String colName, DbType dbtype) {
    return Song_lyricsAuthorsField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Song_lyricsAuthorsField? _song_lyricsId;
  Song_lyricsAuthorsField get song_lyricsId {
    return _song_lyricsId =
        _setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  Song_lyricsAuthorsField? _authorsId;
  Song_lyricsAuthorsField get authorsId {
    return _authorsId = _setField(_authorsId, 'authorsId', DbType.integer);
  }

  /// Deletes List<Song_lyricsAuthors> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSong_lyricsAuthors!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSong_lyricsAuthors!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'song_lyricsId IN (SELECT song_lyricsId from song_lyricsAuthors ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSong_lyricsAuthors!.updateBatch(qparams, values);
  }

  /// This method always returns [Song_lyricsAuthors] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Song_lyricsAuthors?
  @override
  Future<Song_lyricsAuthors?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSong_lyricsAuthors!.toList(qparams);
    final data = await objFuture;
    Song_lyricsAuthors? obj;
    if (data.isNotEmpty) {
      obj = Song_lyricsAuthors.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAuthor'))) {
          obj.plAuthor =
              obj.plAuthor ?? await obj.getAuthor(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Song_lyricsAuthors]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Song_lyricsAuthors?
  @override
  Future<Song_lyricsAuthors> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Song_lyricsAuthors();
  }

  /// This method returns int. [Song_lyricsAuthors]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? song_lyricsauthorsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final song_lyricsauthorsesFuture =
        await _mnSong_lyricsAuthors!.toList(qparams);
    final int count = song_lyricsauthorsesFuture[0]['CNT'] as int;
    if (song_lyricsauthorsCount != null) {
      song_lyricsauthorsCount(count);
    }
    return count;
  }

  /// This method returns List<Song_lyricsAuthors> [Song_lyricsAuthors]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Song_lyricsAuthors>
  @override
  Future<List<Song_lyricsAuthors>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Song_lyricsAuthors> song_lyricsauthorsesData =
        await Song_lyricsAuthors.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return song_lyricsauthorsesData;
  }

  /// This method returns Json String [Song_lyricsAuthors]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song_lyricsAuthors]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song_lyricsAuthors]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSong_lyricsAuthors!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song_lyricsAuthors]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `song_lyricsId`authorsId` FROM song_lyricsAuthors WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<song_lyricsId,authorsId> [Song_lyricsAuthors]
  /// <returns>List<song_lyricsId,authorsId>
  @override
  Future<List<Song_lyricsAuthors>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['song_lyricsId', 'authorsId'];
    final song_lyricsauthorsFuture =
        await _mnSong_lyricsAuthors!.toList(qparams);
    return await Song_lyricsAuthors.fromMapList(song_lyricsauthorsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song_lyricsAuthors]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSong_lyricsAuthors!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Song_lyricsAuthors.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSong_lyricsAuthors!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Song_lyricsAuthorsFilterBuilder

// region Song_lyricsAuthorsFields
class Song_lyricsAuthorsFields {
  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }

  static TableField? _fAuthorsId;
  static TableField get authorsId {
    return _fAuthorsId = _fAuthorsId ??
        SqlSyntax.setField(_fAuthorsId, 'authorsId', DbType.integer);
  }
}
// endregion Song_lyricsAuthorsFields

//region Song_lyricsAuthorsManager
class Song_lyricsAuthorsManager extends SqfEntityProvider {
  Song_lyricsAuthorsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'song_lyricsAuthors';
  static const List<String> _primaryKeyList = ['song_lyricsId', 'authorsId'];
  static const String _whereStr = 'song_lyricsId=? AND authorsId=?';
}

//endregion Song_lyricsAuthorsManager
// region Song_lyricsTags
class Song_lyricsTags extends TableBase {
  Song_lyricsTags({this.song_lyricsId, this.tagsId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Song_lyricsTags.withFields(this.song_lyricsId, this.tagsId) {
    _setDefaultValues();
  }
  Song_lyricsTags.withId(this.song_lyricsId, this.tagsId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Song_lyricsTags.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    song_lyricsId = int.tryParse(o['song_lyricsId'].toString());

    tagsId = int.tryParse(o['tagsId'].toString());

    // RELATIONSHIPS FromMAP
    plSongLyric = o['songLyric'] != null
        ? SongLyric.fromMap(o['songLyric'] as Map<String, dynamic>)
        : null;
    plTag =
        o['tag'] != null ? Tag.fromMap(o['tag'] as Map<String, dynamic>) : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Song_lyricsTags)
  int? song_lyricsId;
  int? tagsId;
  bool? isSaved;
  // end FIELDS (Song_lyricsTags)

// RELATIONSHIPS (Song_lyricsTags)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSongLyric', 'plField2'..]) or so on..
  SongLyric? plSongLyric;

  /// get SongLyric By Song_lyricsId
  Future<SongLyric?> getSongLyric(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SongLyric().getById(song_lyricsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTag', 'plField2'..]) or so on..
  Tag? plTag;

  /// get Tag By TagsId
  Future<Tag?> getTag(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Tag()
        .getById(tagsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Song_lyricsTags)

  static const bool _softDeleteActivated = false;
  Song_lyricsTagsManager? __mnSong_lyricsTags;

  Song_lyricsTagsManager get _mnSong_lyricsTags {
    return __mnSong_lyricsTags =
        __mnSong_lyricsTags ?? Song_lyricsTagsManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }
    if (tagsId != null) {
      map['tagsId'] = forView
          ? plTag == null
              ? tagsId
              : plTag!.name
          : tagsId;
    } else if (tagsId != null || !forView) {
      map['tagsId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (song_lyricsId != null) {
      map['song_lyricsId'] = forView
          ? plSongLyric == null
              ? song_lyricsId
              : plSongLyric!.name
          : song_lyricsId;
    } else if (song_lyricsId != null || !forView) {
      map['song_lyricsId'] = null;
    }
    if (tagsId != null) {
      map['tagsId'] = forView
          ? plTag == null
              ? tagsId
              : plTag!.name
          : tagsId;
    } else if (tagsId != null || !forView) {
      map['tagsId'] = null;
    }

    return map;
  }

  /// This method returns Json String [Song_lyricsTags]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Song_lyricsTags]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [song_lyricsId, tagsId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [song_lyricsId, tagsId];
  }

  static Future<List<Song_lyricsTags>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song_lyricsTags.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Song_lyricsTags>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Song_lyricsTags>[];
    try {
      objList = list
          .map((song_lyricstags) =>
              Song_lyricsTags.fromMap(song_lyricstags as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Song_lyricsTags.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Song_lyricsTags>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Song_lyricsTags> objList = <Song_lyricsTags>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Song_lyricsTags.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTag'))) {
          obj.plTag = obj.plTag ?? await obj.getTag(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Song_lyricsTags by ID if exist, otherwise returns null
  /// Primary Keys: int? song_lyricsId, int? tagsId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Song_lyricsTags] if exist, otherwise returns null
  Future<Song_lyricsTags?> getById(int? song_lyricsId, int? tagsId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (song_lyricsId == null) {
      return null;
    }
    Song_lyricsTags? obj;
    final data = await _mnSong_lyricsTags.getById([song_lyricsId, tagsId]);
    if (data.length != 0) {
      obj = Song_lyricsTags.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTag'))) {
          obj.plTag = obj.plTag ?? await obj.getTag(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Song_lyricsTags) object. If the Primary Key (song_lyricsId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same song_lyricsId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnSong_lyricsTags.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO song_lyricsTags ( song_lyricsId, tagsId)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Song_lyricsTags> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Song_lyricsTags> song_lyricstagses) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Model().batchStart();
    for (final obj in song_lyricstagses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Model().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSong_lyricsTags.rawInsert(
          'INSERT OR REPLACE INTO song_lyricsTags ( song_lyricsId, tagsId)  VALUES (?,?)',
          [song_lyricsId, tagsId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Song_lyricsTags song_lyricsId=$song_lyricsId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Song_lyricsTags song_lyricsId=$song_lyricsId did not update');
      }
      return song_lyricsId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Song_lyricsTags Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Song_lyricsTags>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<Song_lyricsTags> song_lyricstagses) async {
    final results = await _mnSong_lyricsTags.rawInsertAll(
        'INSERT OR REPLACE INTO song_lyricsTags ( song_lyricsId, tagsId)  VALUES (?,?)',
        song_lyricstagses);
    return results;
  }

  /// Deletes Song_lyricsTags

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Song_lyricsTags invoked (song_lyricsId=$song_lyricsId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSong_lyricsTags.delete(QueryParams(
          whereString: 'song_lyricsId=? AND tagsId=?',
          whereArguments: [song_lyricsId, tagsId]));
    } else {
      return _mnSong_lyricsTags.updateBatch(
          QueryParams(
              whereString: 'song_lyricsId=? AND tagsId=?',
              whereArguments: [song_lyricsId, tagsId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Song_lyricsTags] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Song_lyricsTagsFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Song_lyricsTagsFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Song_lyricsTagsFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Song_lyricsTagsFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      song_lyricsId = null;
      tagsId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion song_lyricstags

// region Song_lyricsTagsField
class Song_lyricsTagsField extends FilterBase {
  Song_lyricsTagsField(Song_lyricsTagsFilterBuilder song_lyricstagsFB)
      : super(song_lyricstagsFB);

  @override
  Song_lyricsTagsFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder isNull() {
    return super.isNull() as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Song_lyricsTagsFilterBuilder;
  }

  @override
  Song_lyricsTagsField get not {
    return super.not as Song_lyricsTagsField;
  }
}
// endregion Song_lyricsTagsField

// region Song_lyricsTagsFilterBuilder
class Song_lyricsTagsFilterBuilder extends ConjunctionBase {
  Song_lyricsTagsFilterBuilder(Song_lyricsTags obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSong_lyricsTags = obj._mnSong_lyricsTags;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Song_lyricsTagsManager? _mnSong_lyricsTags;

  /// put the sql keyword 'AND'
  @override
  Song_lyricsTagsFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Song_lyricsTagsFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Song_lyricsTagsFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Song_lyricsTagsFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Song_lyricsTagsFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Song_lyricsTagsFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Song_lyricsTagsFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Song_lyricsTagsFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Song_lyricsTagsFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Song_lyricsTagsFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Song_lyricsTagsFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Song_lyricsTagsField _setField(
      Song_lyricsTagsField? field, String colName, DbType dbtype) {
    return Song_lyricsTagsField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Song_lyricsTagsField? _song_lyricsId;
  Song_lyricsTagsField get song_lyricsId {
    return _song_lyricsId =
        _setField(_song_lyricsId, 'song_lyricsId', DbType.integer);
  }

  Song_lyricsTagsField? _tagsId;
  Song_lyricsTagsField get tagsId {
    return _tagsId = _setField(_tagsId, 'tagsId', DbType.integer);
  }

  /// Deletes List<Song_lyricsTags> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSong_lyricsTags!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSong_lyricsTags!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'song_lyricsId IN (SELECT song_lyricsId from song_lyricsTags ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSong_lyricsTags!.updateBatch(qparams, values);
  }

  /// This method always returns [Song_lyricsTags] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Song_lyricsTags?
  @override
  Future<Song_lyricsTags?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSong_lyricsTags!.toList(qparams);
    final data = await objFuture;
    Song_lyricsTags? obj;
    if (data.isNotEmpty) {
      obj = Song_lyricsTags.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSongLyric'))) {
          obj.plSongLyric = obj.plSongLyric ??
              await obj.getSongLyric(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTag'))) {
          obj.plTag = obj.plTag ?? await obj.getTag(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Song_lyricsTags]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Song_lyricsTags?
  @override
  Future<Song_lyricsTags> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Song_lyricsTags();
  }

  /// This method returns int. [Song_lyricsTags]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? song_lyricstagsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final song_lyricstagsesFuture = await _mnSong_lyricsTags!.toList(qparams);
    final int count = song_lyricstagsesFuture[0]['CNT'] as int;
    if (song_lyricstagsCount != null) {
      song_lyricstagsCount(count);
    }
    return count;
  }

  /// This method returns List<Song_lyricsTags> [Song_lyricsTags]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Song_lyricsTags>
  @override
  Future<List<Song_lyricsTags>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Song_lyricsTags> song_lyricstagsesData =
        await Song_lyricsTags.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return song_lyricstagsesData;
  }

  /// This method returns Json String [Song_lyricsTags]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Song_lyricsTags]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Song_lyricsTags]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSong_lyricsTags!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Song_lyricsTags]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `song_lyricsId`tagsId` FROM song_lyricsTags WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<song_lyricsId,tagsId> [Song_lyricsTags]
  /// <returns>List<song_lyricsId,tagsId>
  @override
  Future<List<Song_lyricsTags>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['song_lyricsId', 'tagsId'];
    final song_lyricstagsFuture = await _mnSong_lyricsTags!.toList(qparams);
    return await Song_lyricsTags.fromMapList(song_lyricstagsFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Song_lyricsTags]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSong_lyricsTags!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Song_lyricsTags.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSong_lyricsTags!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Song_lyricsTagsFilterBuilder

// region Song_lyricsTagsFields
class Song_lyricsTagsFields {
  static TableField? _fSong_lyricsId;
  static TableField get song_lyricsId {
    return _fSong_lyricsId = _fSong_lyricsId ??
        SqlSyntax.setField(_fSong_lyricsId, 'song_lyricsId', DbType.integer);
  }

  static TableField? _fTagsId;
  static TableField get tagsId {
    return _fTagsId =
        _fTagsId ?? SqlSyntax.setField(_fTagsId, 'tagsId', DbType.integer);
  }
}
// endregion Song_lyricsTagsFields

//region Song_lyricsTagsManager
class Song_lyricsTagsManager extends SqfEntityProvider {
  Song_lyricsTagsManager()
      : super(Model(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'song_lyricsTags';
  static const List<String> _primaryKeyList = ['song_lyricsId', 'tagsId'];
  static const String _whereStr = 'song_lyricsId=? AND tagsId=?';
}

//endregion Song_lyricsTagsManager
class ModelSequenceManager extends SqfEntityProvider {
  ModelSequenceManager() : super(Model());
}
// END OF ENTITIES
